<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[简介并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 简而言之，并查集就是将一些具有一定关系的元素进行合并，以此来减少查询的时间。 并查集是基于树形结构的数据而使用的。 问题提出接下来看一个题目： 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input 测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最少还需要建设的道路数目。 这个题就是经典的并查集。可以看出，当两个城镇互相联通（直接或间接）时，这两个城镇之间就不需要再进行任何道路建设。所以我们需要找出有多少个城镇集合是互不联通的。 如何说明和标记两个城镇是否互相联通？解决这个问题，就是我们的最终目的。 并查集给出一个上面题目的一个样例： 5 2 1 2 3 5 它所对应的图形为： 如果仅仅从图片上看，我们很明显的可以看出来答案是2。 由于所有元素各不相同，对于每个集合，总会有一个最小值，而我们一般把这个最小值作为每个集合的根节点。 以上图为例，1,2,3,4,5对应的根节点分别为 1,1,3,3,4。总共有3种根节点，因此答案为3-1=2； 也可以说，总共有3个元素对应的根节点是其本身。 并查集的作用就是是每个集合里面的元素都找到其对应的根节点。 当我们合并两个元素时，这两个元素可能并不是自己所在集合的根节点，因此我们需要找到其对应的根节点，然后将两个根节点进行合并。 网上有一个很形象的比喻： 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？ 我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。 但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1000+10;const int INF=0x3f3f3f3f;int n,m,u,v;int dep[maxn];void init()&#123;//刚开始每个节点的根节点都是其本身 for(int i=1;i&lt;=n;i++)&#123; dep[i]=i; &#125;&#125;int find(int x)&#123; if(x!=dep[x]) dep[x]=find(dep[x]);//这个的作用就是递归找到最后的根节点 return dep[x];&#125;void Union(int x,int y)&#123;//将两个元素进行合并，两个根节点不一样，就将两个根节点进行合并，大的合并到小的根节点上 int dx=find(x); int dy=find(y); if(dx&lt;dy) dep[dy]=dx;//将大的合并到小的上面 else dep[dx]=dy;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); init(); for(int i=0;i&lt;m;i++)&#123; scanf("%d %d",&amp;u,&amp;v); if(find(u)!=find(v)) Union(u,v);//如果两个元素根节点不一样，就进行合并 &#125; int res=0; for(int i=1;i&lt;=n;i++)&#123;//统计总共有多少个根节点，即集合 if(dep[i]==i) res++; &#125; printf("%d\n",res-1); return 0;&#125; 按照上面的例子，函数init()就是创造一个最初的江湖，find()就是用来找到自己的队长，Union()就是来将两位大侠所在的队伍结盟。对于一个队伍来说，队伍的操作只能由队长来进行，所以我们最后只需要将两个队长串联起来就可以了。]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2019%2F03%2F02%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背包问题是很经典的dp问题，在许多基础的比赛中都会用到。可以这样说，背包问题就是学习dp的第一步，但是其难度对于初学者来说也并不小。 这篇文章主要介绍一下基础的01背包和完全背包。 01背包01背包是最简单的背包问题，其大致描述为： 有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。 二维dp这里我们用一个二维数组dp[maxn][maxn] 来求解背包问题。 其中第一维表示前 i 个物品，第二维表示前 i 个物品在容量为 j 时的最大价值总和。 这里有一个状态方程： 1dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); dp[ i ][ j ]上面说过，表示的是前 i 件物品在容量为 j 时的最大价值，那么得到dp[ i ][ j ]，其中就涉及到了关于第 i 件物品选和不选的问题。 当我们选择第 i 件物品时，总容量为 j ，我们需要腾出来 w[ i ] 的空间来装第 i 件物品，因此得出当选择第 i 件物品时的最大价值 dp[ i - 1 ][ j - w[ i ] ] + v[ i ]。 当我们不选择第 i 件物品时，那么之前的容量也必然为 j ，因为没有东西放进去，所以我们可以得到当不选择第 i 件物品时的最大价值 dp[ i - 1 ][ j ]。 理解了方程的意义，我们就可以写出来解决背包问题的代码了。 123456for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=V;j++)&#123; if(j&lt;v[i]) dp[i][j]=dp[i-1][j];//容量太小，装不下第 i 个物品 else dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]); &#125;&#125; 最终求出来的dp[N][V]即为答案。 这是用二维数组来求解最大价值。我们如果在纸上模拟这个过程，会发现在两层 for 循环的情况下，每个位置的值只会变化一次，当第 i 行求解完之后，我们就再也不会改变第 i 行的值了。 那么这对空间的要求是巨大的，我们是否可以把二维数组压缩成一位数组？答案是可以！ 一维dp我们如果在纸上模拟这个过程，会发现在两层 for 循环的情况下，每个位置的值只会变化一次，当第 i 行求解完之后，我们就再也不会改变第 i 行的值了。 上面的代码过程用图像可以表示为： 从上面代码和图片中可以看出，影响dp[ i ][ j ]的值为 dp[ i - 1][ j ] 和dp[ i - 1 ][ j - w[ i ] ]，两个数的一维二维坐标均小于等于 i , j ，所以我们第一步先改变一下循环的顺序： 123456for(int i=1;i&lt;=N;i++)&#123; for(int j=V;j&gt;=1;j--)&#123;//这里的循环顺序改变了 if(j&lt;v[i]) dp[i][j]=dp[i-1][j]; else dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]); &#125;&#125; 如果表示成一维的话，那么过程就变成了： 可以发现，此时代码中 if(j&lt;v[i]) dp[i][j]=dp[i-1][j] 已经失去了原本的作用。 然后将二维数组压缩成一位数组： 12345for(int i=1;i&lt;=n;i++)&#123; for(int j=V;j&gt;=w[i];j--)&#123;//根据上面的代码，这里假如j&lt;w[i]时，dp[j]=dp[j],可以直接省略 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125;&#125; 在这里可能有人疑问，为什么循环顺序要变化？ 当我们从前往后改变一维数组的值时，我们可能会改变了后面的数的正确的值，因为后面的数还会用到前面的是，从而导致最终结果偏离正确结果。 所以我们选用从后往前的方式进行遍历，前面已经说过，影响这个元素的值一维二维坐标均小于当前坐标，所以即使我们改变了后面的数值，也不会对前面的值有影响。 这样，我们就可以节省大量的空间（还在第二层循环时减少了时间）。 完全背包 有N种物品和一个容量为V的背包。第i种物品的重量是w[i]，价值是v[i]。每种物品都可以无限件使用。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。 完全背包和01背包最大的区别就是物品件数的改变。完全背包每种物品可以无限次使用，而01背包只是用一次。 我们再来看一下01背包一维dp时循环顺序的问题。 上面已经说过，假如第二层for循环的顺序是j++，那么最终结果会偏离正确结果。但是是怎么偏离的呢？我们继续深入探讨一下。 假如dp[ j ]&lt;dp[ j - w[ i ] ] + v[ i ] ，那么dp[ j ]=dp[ j - w[ i ] ] + v[ i ]， 然后对于 k ( j &lt; k &lt;= V)，如果dp[ j ]影响到了dp[ k ] ，那么影响的结果一定是dp[ k ] = dp[ k - w[ i ] ] + v[ i ],其中 k - w[ i ] = j ( 只考虑直接影响 )， 所以我们可以继续递推得出dp[ k ] = dp[ j - w[ i ] ] +v[ i ] +v[ i ]=dp[ j - w[ i ] ] + 2 * v[ i ]。 这里我们就发现，v[ i ]被使用了两次，这在01背包中肯定是错误的，但是在完全背包中却没有任何问题，因为每件物品可以无限次使用，因此我们就可以得出完全背包的求解方法： 12345for(int i=1;i&lt;=n;i++)&#123; for(int j=w[i];j&lt;=V;j++)&#123; dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125;&#125; 这和01背包的区别只在于第二层循环的顺序。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长单调子序列]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[最长上升子序列（LIS） 问题描述： ​ 给你一个序列，让你求出其中的最长的上升子序列。 ​ 比如数组{1,5,3,2,4},其最长递增子序列为{1,3,4}或{1,2,4}。 dp求解（小范围数据）在长度 n 较小的情况下，我们可以用dp的方式来求解，复杂度为O(n^2) : 1234567891011121314int n;int dp[maxn];int a[maxn]; int LIS()&#123; int res=0; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(a[i]&lt;a[j]) dp[j]=max(dp[j],dp[i]+1); //如果是最长非递减的话，则if(a[i]&lt;=a[j]) &#125; res=max(res,dp[i]); &#125; return res+1;&#125; 这个理解起来还算容易，当我们求出前m（m&lt;=n）个数的LIS长度时，那么我们就可以求出当前状态下m后面的数的最长长度。 因为m和m+1之间没有其他的数字，所以我们可以认为我们求出了前m+1个数的LIS长度。 然后依次递推，就可以求出n个数的LIS。 dp求解（大范围数据）当n比较大时,O(N^2)的时间复杂度明显没办法满足需要，所以我们需要更高效的方法。 当我们循环遍历时，我们可以把当前的最长的LIS存储下来。 对于样例{1,5,3,2,4}，我们储存的顺序依次为： {1}， {1,5} {1,3} {1,2} {1,2,,4} 这个刚开始理解起来比较难理解。对于第二步{1,5}来说，当前的LIS长度为2，由LIS的特性可知，我们希望前面的元素尽量的小。 所以当遍历到第三个元素时，由于{1,5}，{1,3}长度均为2，但我们更希望值小一点，所以我们就用3来代替了5的值。 第四个元素也一样。 第五个元素{4}，由于当前我们保存的LIS{1,2}最大值小于4，因此我们就把4放进来，所以最终结果就为3。 注意：储存的元素并不是LIS的值，这个储存的值只是用来寻找LIS的。 再来看一个样例：{1,3,5,4,6,2}，存储的顺序依次为： {1} {1,3} {1,3,5} {1,3,4} {1,3,4,6} {1,2,4,6} 对于第6步，因为2&lt;6，所以我们一定能找到替换2的元素。而我们希望储存的序列尽可能的小，所以我们需要找到2能替换的最小的元素。因此我们的替换操作为3 -&gt; 2。 这一步可以理解为：找到储存的序列中比当前元素大（或者相等）的第一个元素，进行替换。 因为我们在储存时保证了储存的元素单调，因此我们在寻找替换位置时可以用高效的二分法，所以这种方法的复杂度为O( n*log(n) )。 12345678910111213141516171819202122232425int n;int dp[maxn];int a[maxn];int find(int x)&#123; int l=0,r=n-1,mid; while(l&lt;r)&#123; mid=(l+r)/2; if(dp[mid]&lt;x)&#123;//小于的话肯定不是被替换的元素，因此可以+1 l=mid+1; &#125; else&#123;//大于等于的情况下这个元素可能是被替换的元素，所以我们不能忽略这个元素 r=mid; &#125; &#125; return l;&#125;int LIS()&#123; fill(dp,dp+n,INF);//将dp里面的元素全部替换为INF for(int i=0;i&lt;n;i++)&#123; int pos=find(a[i]); dp[pos]=a[i]; &#125; int res=find(INF); return res;&#125; 输出LIS的元素在前面已经说过，储存的值并不是LIS的元素，那么我们如何来输出LIS呢？ 前面已经说过，我们的操作都是找到储存的序列中第一个比当前元素大（或者相等）的位置，那么这个元素的前面一个元素一定是它左边的那个元素，因此我们需要用一个数组来储存每个元素的前驱。 因此我们在上面的代码上做一些小修改： 1234567891011121314151617181920212223242526272829303132int n;int dp[maxn];int a[maxn];int pre[maxn];//用来记录每个元素的前驱void output(int x)&#123;//用来输出LIS的元素（可能有多个答案，这里只取其中一种） if(pre[x]!=0) output(pre[x]); printf("%d ",x);&#125;int find(int x)&#123; int l=0,r=n-1,mid; while(l&lt;r)&#123; mid=(l+r)/2; if(dp[mid]&lt;x)&#123;//小于的话肯定不是被替换的元素，因此可以+1 l=mid+1; &#125; else&#123;//大于等于的情况下这个元素可能是被替换的元素，所以我们不能忽略这个元素 r=mid; &#125; &#125; return l;&#125;int LIS()&#123; fill(dp,dp+n,INF);//将dp里面的元素全部替换为INF for(int i=0;i&lt;n;i++)&#123; int pos=find(a[i]); dp[pos]=a[i]; pre[ dp[pos] ]=dp[pos-1];//当前元素所对应的前一个元素的值。 &#125; int res=find(INF); output(dp[res-1]); return res;&#125; 这样，我们就可以输出LIS的元素了。 最长下降子序列（LDS)最长下降子序列求解方法和LIS相似，只需要把元素的位置翻一下即可求解。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD与LCM及其部分性质]]></title>
    <url>%2F2019%2F02%2F01%2FGCD%E4%B8%8ELCM%E5%8F%8A%E5%85%B6%E9%83%A8%E5%88%86%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[GCDGCD，即最大公约数，指两个或多个整数共有约数中最大的一个。 求最大公约数有多种方法，常见的有质因数分解法、短除法、辗转相除法、更相减损法。 在一般竞赛中，求GCD一般使用辗转相除法。其复杂度约为O(log(max(n,m)))，是一种很高效的算法。而且其代码量也非常少 1int gcd(int a,int b) &#123; return b ? gcd(b,a%b) : a; &#125; 拓展性质如果GCD( n , a ) = 1 , n&gt;a 则GCD( n , n - a ) = 1。 可以用反证法证明 假设GCD( n , n - a ) = i ( i &gt; 1 )，设 n = k1 * i，n - a = k2 * i（ k1 &gt; k2 &gt; 0 ）， 则 n -( n -a ) = a = (k1-k2) * i，与GCD( n , a ) = 1 矛盾，所以上述性质成立。 扩展欧几里得算法设a , b为常数，对于一个表达式 a * x + b * y =GCD( a , b ) ，一定存在解（ x , y）使之成立。 我们就可以通过扩展原来的辗转相除法来求解。 求解的过程如下（最好自己手推一下）： 初始表达式$$a * x + b * y =GCD( a , b )$$由之前的知识可得$$GCD( a , b ) =GCD( b , a \% b )$$因此$$a*x_1+b*y_1=GCD( a , b ) =GCD( b , a\%b ) =b*x_2+(a\%b)*y_2$$ $$a\%b=a-[a/b]*b$$ 其中[a/b]表示整除。带入化简可得：$$a*x_1+b*y_1=a*x_2+b*(x_2-[a/b])*y_2$$由恒等关系可得$$x_1=y_2$$ $$y_1=(x_2-[a/b])$$ 因此我们只要求出 x2 和 y2 的值就可以求解 x1 和 y1。而 x2 , y2 可通过同种方法求解。 特别的，当 b=0时，表达式为 a * x + b * y = GCD( a , b ) =GCD( a , 0 ) = 0 此时,可求得 x = 1 。y 的值对表达式的值没有影响。 上面就是求解初始表达式的方法。 代码如下： 12345678910111213int extGcd(int a,int b,int &amp;x,int &amp;y)//这里取 x , y的地址 &#123; if(b==0) &#123; x=1;y=0; return a;//函数的返回值一直是 gcd(a,b) &#125; int r=exGcd(b,a%b,x,y); int t=x; x=y; //x1=y2 y=t-a/b*y; //y1=x2-[a/b]*b return r;&#125; LCMLCM，即最小公倍数，指两个或多个整数共有倍数中最小的一个。 LCM的求法可以基于GCD的基础上：$$LCM(a,b)=a*b/GCD(a,b)$$证明略。 一般题目求解时使用GCD更多一些，所以LCM相关知识就不多写了。(我也没找到太多关于LCM的相关文献)]]></content>
      <tags>
        <tag>数论</tag>
        <tag>GCD</tag>
        <tag>LCM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数及其部分性质]]></title>
    <url>%2F2019%2F02%2F01%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E9%83%A8%E5%88%86%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[欧拉函数欧拉函数在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。 从欧拉函数引伸出来在环论方面的事实和拉格朗日定理构成了欧拉定理的证明。 欧拉函数的适用范围非常大，许多题目中都会用到欧拉函数的性质。 欧拉函数表达式1：欧拉函数的表达为：$$\varphi (x)=x\prod_{i=1}^{n}{(1-\frac{1}{p_i})}$$ 其中p1,p2,…,pn 表示x的所有质因子，x是不为0的整数。 欧拉函数表达式2：假设$$x= {p_1}^{k_1} * {p_2}^{k_2} * … * {p_n}^{k_n}$$ p1,p2,…,pn同上，则其另一种表达为：$$\varphi(x)=\prod_{i=1}^{n}{(p_i-1)*p_i^{k_i-1}}$$ 特别的，$$\varphi(1)=1$$ 欧拉函数证明容斥定理来证明对于正整数 x 而言，假设其质因子为p1,p2,p3,…,pn，则小于等于 x 且与 x 不互质的数字的个数为：$$g(x)=\frac{x}{p_1}+\frac{x}{p_2}+…+\frac{x}{p_n}-\frac{x}{p_1*p_2}-\frac{x}{p_1*p_3}- …$$ 小于 x 且与 x 互质的数字的个数：$$f(x)=x-g(x)=n-\frac{x}{p_1}-\frac{x}{p_2}- … -\frac{x}{p_n}+\frac{x}{p_1*p_2}+\frac{x}{p_1*p_3}+ …$$ 化简即可得表达式1。（具体化简过程我也不会） 欧拉函数计算单值计算在编程时，习惯上，我们经常用表达式2计算欧拉函数的值： 12345678910111213141516171819int eular(int n)&#123; int ret=1,i; for(i=2;i*i&lt;=n;i++) &#123; /* n%i==0时，i为n的质因子，因为如果i不是质因子， 则一i定能分成更小的因子，对应的更小的因子一定在之前出现过了，与之矛盾， 所以i一定不能分割成更小的因子，即i为n的质因子。 */ if(n%i==0) &#123; n/=i,ret*=i-1; while(n%i==0) n/=i,ret*=i; &#125; &#125; if(n&gt;1) ret*=n-1; return ret;&#125; 打表计算欧拉函数性质互质数之和小于n的正整数中与n互质的数的数字之和为$$f(n)={n}*\frac{\varphi(n)}{2}$$ 证明如下： 对于每个小于 n 的数正整数 a ，如果gcd( n , a )=1,则gcd( n , n-a )=1（ 此处为gcd相关性质，不再证明。）。 所以对于每个与 n 互质的正整数 a ，一定有一个与之对应的与 n 互质数的 n - a ; 由此可知，欧拉函数的值总为偶数（1除外），并且总有一对之和为 n， 至此，小于n的正整数中与n互质的数的数字之和就可以计算出来了。 积性函数欧拉函数是一个积性函数，如果 n , m 互质，则：$$\varphi(nm)=\varphi(n)*\varphi(m)$$可以推出，如果n为质数，则：$$\varphi(2n)=\varphi(n)$$ 欧拉定理变式对于任何两个互质的正整数 a , n ，(n&gt;2)$${a}^{\varphi(n)}\equiv 1 mod n$$ 费马小定理当 n = p 且 a 与素数 p 互质时，上式可变为 $${a}^{p-1}\equiv 1 mod p$$ n的因数（包括1和它自己）的欧拉函数之和等于n写成数学表达式的形式即为$$n=\sum_{d|n}\varphi(d)$$其中 d|n 表示 n 能被 d 整除。 证明如下： 对于每个 x ( 0 &lt;= x &lt;= n ) 都存在一个gcd( x , n )，可以证得，其值必然为n的因子。 假设gcd( x , n ) = d ,（ d | n ） ，则gcd（ x / d , n / d ）= 1 ，即 x / d 与 n / d 互质。 因此，我们可以求出 gcd( x , n ) 的值为 d 时对应的的数字个数，个数就是 n / d 所对应的欧拉函数值。 由第一行可知，gcd( x , n )的值必然为n的因子，并且只有唯一对应值，因此就可推导出上述公式。]]></content>
      <tags>
        <tag>欧拉函数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2036（多边形面积）]]></title>
    <url>%2F2019%2F01%2F17%2FHDU-2036%2F</url>
    <content type="text"><![CDATA[题目大意： 给你一个多边形，求它的面积。 多边形面积可以用向量知识来求解。 对于一个凸多边形，如下： 其面积可以表示为 S = S△OAB+S△OBC+S△OCD+S△ODE 对于△OAB 其面积用向量表示为 0.5 * |OA| * |OB| * sin∠AOB=0.5 * | OA x OB| 其中OA x OB表示叉乘（非点乘，具体详见百度百科“向量积”） 但因为向量叉乘有正有负，所以我们取的是绝对值，保证题目答案的正负。（正负取决于两条边的位置状态） 这时候就可以简单的计算出多边形的面积。 对于一个 凹多边形，如下： 其面积依然就可以用向量的方法求解 假设点O为坐标原点，则 S = S△OAB+S△OBC+S△OCD+S△ODE+S△OEA S△OAB = 0.5 * OA x OB =0.5 * ( A.x * B.y - A.y * B.x ) 其中S均表示在叉乘意义下的值，由于其具有正负之分，所以可以用来计算凹多边形的面积（具体证明过程略）。 这时候就可以计算出多边形的面积。 代码如下： 12345678910111213141516171819202122232425# include&lt;bits/stdc++.h&gt;using namespace std;# define ll long longint main()&#123; int n,i; double a[1000]; double b[1000]; while(~scanf("%d",&amp;n) &amp;&amp; n)&#123; for(i=1;i&lt;=n;i++)&#123; scanf("%lf %lf",&amp;a[i],&amp;b[i]); &#125; a[0]=a[n]; b[0]=b[n]; double res=0; for(i=0;i&lt;n;i++)&#123; res=res+(a[i]*b[i+1]-b[i]*a[i+1])/2;//由于是逆时针方向，所以求出来结果为正。 &#125; printf("%.1lf\n",res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广西大学第一届程序设计大赛-数论只会GCD]]></title>
    <url>%2F2019%2F01%2F16%2F%E5%B9%BF%E8%A5%BF%E5%A4%A7%E5%AD%A6%E7%AC%AC%E4%B8%80%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-D%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述 小西买了一堆肥宅快乐水和肥宅快乐茶，准备和室友比谁更肥宅。 快乐水有A瓶，快乐茶B瓶。 小西和室友的规则是这样的： 小西先手，轮流到每个人的回合，每个回合只能喝剩余数量较多的饮料 满足规则1的同时，每次只能喝另一种饮料剩余数量的正整数倍 满足1、2的同时，不能超额喝饮料，也就是说剩下2瓶的时候不能喝大于2瓶的数量。 每个人在自己的回合如果能喝完剩下的其中一种饮料，那么就获得胜利。 例如A=10，B=2。 小西只能喝快乐水，且只能喝2/4/6/8/10瓶快乐水。小西可以喝10瓶快乐水直接获得胜利。 小西和室友都是肥宅，所以他们都会才采取为了胜利最优的行动。 现在请你判断小西是否能赢得胜利。 输入描述: 第一行输入一个整数T，表示有T组数据 接下来T行，每行为一组数据，每行有两个正整数表示A和B的初始数量 1 ≤ T ≤ 500 , 1 ≤ A,B ≤ 10^12 输出描述: 对于每组数据，若小西可以获得胜利则输出一行“wula”，否则输出一行“mmp”，不需要输出引号 你真的会GCD吗 这道题其实就和求GCD的过程有关。 求GCD的过程就是GCD( a , b ) = GCD( b , a % b )，其过程就是把 a 减去 b 的正整数倍，然后依次递归求解。 那么对于这个题，最后的状态一定是一个数量为 0 ，一个数量为正整数。而逆推就可以得到题目给出的 A , B 值。 假设 A &lt; 2 * B,那么接下来的操作之后一定是（ A - B , B），接下来也一直持续这个过程，而且这个过程是可以一直递推求出来唯一解的。 假如 A &gt; 2 * B , 那么因为两人足够聪明，接下来的状态可以变为（ A , A%B）或者（ A , A % B + A ）。 可以看到，第二个状态只能有一种操作：（ A , A % B + A ）- &gt;（ A , A%B）,因此这个时候可操作的人就能够随意挑选这两种状态之一来掌握自己的胜负。 假设A % B=0 那就不多说了，直接就赢了。 代码如下： 12345678910111213141516171819202122232425262728293031# include&lt;bits/stdc++.h&gt;using namespace std;# define ll long longint main()&#123; ll t,a,b; scanf("%lld",&amp;t); while(t--)&#123; scanf("%lld %lld",&amp;a,&amp;b); ll flag=1;//用flag来记录当前的赢家，因为此时我们并不知道谁有主动权 while(true)&#123;//遇到可以判断赢家的条件时，循环就结束了 if(a&gt;b) swap(a,b); if(b%a==0) break; else if(a*2&lt;b) break; else&#123; flag*=-1; b=b-a; &#125; &#125; if(flag==1)&#123; printf("wula\n"); &#125; else&#123; printf("mmp\n"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数筛选法]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95%2F</url>
    <content type="text"><![CDATA[素数，是指因子只包含1和其本身的数，那么，我们怎么判断素数呢？ （以下代码均基于打表（1~1e6）的基础上完成） 1.按照定义计算素数的定义就是一个数的因子只包含1和其本身，那么我们直接就按照定义写： 12345678910111213141516171819202122# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int pri[maxn];int isprime(int n)&#123; for(int i=2;i&lt;n;i++) if(n%i==0) return 0; return 1;&#125;int main()&#123; pri[1]=0; for(int i=2;i&lt;=maxn;i++)&#123; pri[i]=isprime(i); &#125; return 0;&#125; 这是最基础的写法，也是最小白的写法。毕竟，当时我刚高一加入大学的某个协会时，考的就有判断素数… 这种算法的复杂度为O(n^2),复杂度非常的大，对于1e6的数据范围来说肯定要超时，那么还有没有更优化的算法？答案是肯定的 2.基于定义计算的优化算法我们对一个合数进行考虑，例如12： 它的因子有1 2 3 4 6 12 ，而且112=12 ， 26=12 ， 3*4=12 可见，每一个因子都会有另一个对应的因子，观察可得，它们的分布是平均的，左边的一半对应右边的一半，那么最中间的分界线应该是什么？ √n 。 因此，我们只需要对√n 前面的数字进行判断即可。 12345678910111213141516171819202122# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int pri[maxn];int isprime(int n)&#123; for(int i=2;i*i&lt;=n;i++)//只需要将i变成i*i即可 if(n%i==0) return 0; return 1;&#125;int main()&#123; pri[1]=0; for(int i=2;i&lt;maxn;i++)&#123; pri[i]=isprime(i); &#125; return 0;&#125; 这种算法的复杂度要比上一种好的多，复杂度为O(n√n),但是对于1e6的数据范围来说还是太大了。有没有再快一点的算法？ 3.素数筛选法素数筛选法的思想为： 从2开始，因为2的倍数一定不是素数，所以先把2的倍数全部删去； 接着找下一个素数3，把3的倍数全部删去； 因为4是2的倍数，已经被删去，所以直接找下一个素数5，把5的倍数全部删去； 接着7的倍数，11的倍数，……直到把1e6范围内的合数全部筛选出去，剩下的即为素数： //以下优化均基于打表的基础上 1234567891011121314151617181920212223242526# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int vis[maxn];void isprime()&#123; memset(vis,0,sizeof(vis));//此处vis[i]=1表示不是素数，vis[i]=0表示是素数 vis[1]=1; //由于i*i的数据范围可能会超过int，所以需要用long long表示 for(long long i=2;i*i&lt;=maxn;i++)&#123;//此处有优化，因为如果一个合数&gt;sqrt(maxn),那么他必定在前面已经被标记过。 if(!vis[i])&#123; for(long long j=i*i;j&lt;=maxn;j+=i)&#123;//此处也有优化，我们只需要判断从i*i开始判断即可。 vis[j]=1; &#125; &#125; &#125;&#125;int main()&#123; int n; isprime(); return 0;&#125; 这种算法的复杂度应该为O(n);，是一种非常快速的判断素数的算法。 上述代码有两处优化，第一处优化的证明如下： 假设 maxn &gt; i &gt; sqrt(maxn)并且为合数，那么，他肯定会有一个因子小于等于sqrt(maxn)，因此，i一定在之前已经被标记过了。 第二处优化证明为： 假设i&gt;2，那么对于 i * ( i - 1 )： 如果 i - 1是素数，那么 i * ( i - 1 ) 一定在之前已经被标记过； 否则，如果 i - 1 是合数，那么 i - 1能被分成更小的素数。设其中一个为a，那么 i ( i - 1 )= i ( i - 1 ) / a * a 也一定被标记过。 优化后的算法时间会节省非常多，在平常的算法竞赛中，用上述代码就已经可以解决大部分的涉及素数打表的问题。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马小定理--轻松判断大质数]]></title>
    <url>%2F2019%2F01%2F09%2F%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86-%E8%BD%BB%E6%9D%BE%E5%88%A4%E6%96%AD%E5%A4%A7%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述在算法竞赛中你会遇到各种各样的有关素数的问题，今天你来解决一个最基础的问题：如何判定一个素数。对于给定的正整数p，若p非素数，输出-1若p是素数 输出 ：{sigma(a^(p-1) % p) ，其中a的下界为1，上界为p-1} 即： 输入 多实例测试，每组数据包含一个正整数p（p &lt; 10^16）。 输出 根据情况输出一个正整数，保证答案在int64之内，输出占一行。 样例输入 2 样例输出 1 这个题一般方法是就是暴力求解了，首先判断是不是素数，如果不是素数，那么输出-1，如果是素数，那么就实处上面那个式子的值。 但是题目要求的数据范围为1e16，如果我们用一般判断素数的方法（sqrt(n)）去求解的话，必定会超时，那么我们如何解决这个问题呢，费马小定理出现了。 费马小定理 假如p是质数，且gcd(a,p)=1，那么 a(p-1)≡1（mod p），例如：假如a是整数，p是质数，则a,p显然互质(即两者只有一个公约数1)，那么我们可以得到费马小定理的一个特例，即当p为质数时候， a^(p-1)≡1(mod p)。 从费马小定理的定义我们可以知道，一般情况下，只要一个数字a，gcd(a,p)=1，那么p就是一个质数。 因此，我们可以随机几个数字（与p互质），如果a(p-1)≡1（mod p）对这些数字恒成立，那么p就是一个指数。 一般情况下，我们只需要列举十个左右的数字即可确定一个数字是否为质数。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849include&lt;stdio.h&gt;long long n,res,x;long long gcd(long long a,long long b)&#123;​ return b?gcd(b,a%b):a;&#125;long long feima(long long a)&#123;​ long long sum;​ if(x&lt;=1)&#123;​ return (a*res)%n;​ &#125;​ if(x%2==0)&#123;​ a=(a*a)%n;​ x/=2;​ return feima(a);​ &#125;​ else&#123;​ res=(res*a)%n;​ a=(a*a)%n;​ x/=2;​ return feima(a);​ &#125;&#125;int main()&#123;​ long long t,i;​ //以下是我自己列举的一些随机数，我们也可以用一些随机数函数来找一些随机数 ​ long long a[20]=&#123;7,43,64,69,87,31,45,72,81,79,47,33,43,97,121,199,173,153,157,53&#125;; ​ while(~scanf("%lld",&amp;n))&#123;​ if(n==2)&#123;​ printf("1\n");​ continue;​ &#125;​ for(i=0;i&lt;20;i++)&#123;​ res=1;​ x=n-1;​ if(gcd(a[i],n)!=1 || feima(a[i])!=1)&#123;//两个判断条件，两个数字互质且符合费马小定理 ​ break;​ &#125;​ &#125;​ if(i==20)&#123;​ printf("%lld\n",n-1);​ &#125;​ else​ printf("-1\n");​ &#125;​ return 0;&#125; 用以上方法即可迅速判断一个数是否是质数，对特别大的数字尤其适用。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>费马小定理</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算数基本定理 + 容斥定理]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%AE%97%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86-%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[算数基本定理定义：任何一个大于1的自然数，如果N不为质数，那么N可以分解成有限个质数的乘积，并且在不计次序的情况下，这种分解方式是唯一的。 例如：60可以分解为 2^2 * 3 * 5 数学公式描述 N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn （P1&lt;P2&lt;P3&lt;…=0） 质因子分解计算方法 算法复杂度 ( O(√n) )123456789101112map&lt;int,int&gt; prime_factor(int n)&#123; map&lt;int,int&gt;ans; for(int i=2;i*i&lt;n;i++)&#123; while(n%i==0)&#123; ++ans[i]; n/=i; &#125; &#125; if(n!=1) ans[n]=1; return ans;&#125; 算数基本定理的应用如何求N有几个因子？ 根据算数基本定理：N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn 根据排列组合得到结果： ans=(1+r1) * (1+r2) * (1+r3) * … * (1+rn) 如何求N的所有因子之和？ 根据算数基本定理：N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn 求GCD(X,Y)和LCM(X,Y) 根据算数基本定理： X=P1^x1 * P2^x2 * P3^x3 * … * Pn^xn Y=P1^y1 * P2^y2 * P3^y3 *… * Pn^yn 根据GCD和LCM的定义 容斥定理要计算几个集合并集的大小，我们要先将所有单个集合的大 小计算出来，然后减去所有两个集合相交的部分，再加回所 有三个集合相交的部分，再减去所有四个集合相交的部分， 依此类推，一直计算到所有集合相交的部分。 用Venn图来表示 数学公式描述 如果要对n个物体进行选择，那么有多少种情况？ 代码 复杂度为O(2^n) 123456for(int i=0;i&lt;(1 &lt;&lt; m);i++)&#123; for(int j=0;j&lt;n;j++)&#123; printf("%d",i&gt;&gt;j &amp; 1); &#125; puts("");&#125; 容斥定理的应用问题：魔镜给小明m个数字（a1、a2 …… am）和一个整数n，魔镜定义：如果有一个数，是这m个数字里面任意一 个数的倍数，那么这个数称为LuckyNumber。而小明会的题 数为[1,n]闭区间内LuckyNumber的数量。 (0 &lt; m &lt; 15) 那么请你帮小明计算一下他会的题目数。 代码 复杂度为O(2^n) 123456789101112131415LL ans=0;for(int i=1; i&lt;(i&lt;&lt;m);i++)&#123; int cnt=0; LL LCM=1; for(int j=0;j&lt;m;j++)&#123; if(1&amp;(i&gt;&gt;j))&#123;//按位运算判断第m个数是否使用 cnt++; LCM=lcm(LCM,a[j]); &#125; &#125; if(cnt&amp;1) ans+=n/LCM;//判断n中元素使用的个数，奇加偶减 else ans-=n/LCM;&#125;printf("%lld\n",ans);]]></content>
      <tags>
        <tag>算法</tag>
        <tag>算数基本定理</tag>
        <tag>容斥定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS与DFS]]></title>
    <url>%2F2019%2F01%2F08%2FBFS%E4%B8%8EDFS%2F</url>
    <content type="text"><![CDATA[BFS(宽度优先搜索)宽度优先搜索算法（又称广度优先搜索算法）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。 他并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。 举例： 由橙色位置出发，进行BFS： ​ 灰色位置表示已经走过，橙色标示当前位置 首先进行第一步： ​ 已经走过的位置，不需要再走了 进行第二步： ​ 同上，状态继承，进行第三步： ​ 进行第四步，到达终点，当前步数表示最小步数： ​ 对于一个迷宫而言，我们要进行的步骤是一样的。 ​ 蓝色是起点，红色是终点，黑色为障碍物。 第一步，我们可以走以下几步： ​ 接下来依次为： 当我们走到第十步时，走到了终点，因此，从起点到终点最少的步数即为10步。 接下来看一道基础的例题（HDU1242）Rescue： Problem Description Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison. Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards. You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.) Input First line contains two integers stand for N and M. Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend. Process to the end of the file. Output For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.” Sample Input 123456787 8#.#####.#.a#..r.#..#x.....#..#.##...##...#.............. Sample Output 113 这个题大概的意思就是求从字符a出发，到达字符r的最少时间，其中 . 代表空地，#代表墙，x代表守卫，每杀死一个守卫我们就需要消耗一秒的时间。 这个题可以用BFS直接求解，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;# include&lt;string.h&gt;# include&lt;algorithm&gt;# include&lt;queue&gt;using namespace std;# define MAXN 510char str[MAXN][MAXN];//用来储存地图 int vis[MAXN][MAXN];//用来标记已经走过的地点 int n,m;struct name&#123; int x; int y; int step;&#125;;bool operator &lt;(name i,name j)&#123;//对走过的地点顺序进行排序 return i.step&gt;j.step;&#125;int d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;//表示行走的四个方向，顺序为右，左，上，下 int BFS(int sx,int sy,int ex,int ey)&#123; memset(vis,0,sizeof(vis)); priority_queue&lt;name&gt;que;//使用队列用来储存上一步走过的地点 name e1,e2; e1.x=sx,e1.y=sy,e1.step=0; que.push(e1);//输入起点 vis[sx][sy]=1; int ans=-1; int i; while(!que.empty())&#123;//当队列为空时，即表示我们已经把所有的能走的地点都走了一遍 e1=que.top();//将队列第一个地点的信息赋给e1； 此时e1即表示上一步走过的地点的信息 que.pop(); if(e1.x==ex &amp;&amp; e1.y==ey)&#123;//对这个地点进行判断，看是否是是终点 ans=e1.step; break; &#125; for(i=0;i&lt;4;i++)&#123;//如果e1不是终点，那么对e1的上下左右进行判断，如果可以走，那么就将信息储存在队列中 e2.x=e1.x+d[i][0]; e2.y=e1.y+d[i][1]; if(e2.x&lt;0 || e2.x&gt;=n || e2.y&lt;0 || e2.y&gt;=m) continue;//对边界进行判断，如果超出边界，则不进行保存 if(vis[e2.x][e2.y]==1) continue;//如果当前位置已经走过，那么就不进行保存 if(str[e2.x][e2.y]=='#') continue;//如果是墙壁,不进行保存 if(str[e2.x][e2.y]=='x') e2.step=e1.step+2;//如果是守卫的话，需要消耗两个单位时间 else e2.step=e1.step+1;//如果是空地,一个单位时间 que.push(e2);//将地点存入队列 vis[e2.x][e2.y]=1;//降低点进行标记 &#125; &#125; if(ans==-1)&#123; printf("Poor ANGEL has to stay in the prison all his life.\n"); &#125; else&#123; printf("%d\n",ans); &#125; &#125;int main()&#123; int i,j; while(~scanf("%d %d",&amp;n,&amp;m))&#123; for(i=0;i&lt;n;i++)&#123; scanf("%s",str[i]); &#125; int sx,sy,ex,ey; for(i=0;i&lt;n;i++)&#123;//找寻起点和终点 for(j=0;j&lt;m;j++)&#123; if(str[i][j]=='a') sx=i,sy=j; if(str[i][j]=='r') ex=i,ey=j; &#125; &#125; BFS(sx,sy,ex,ey);//开始BFS &#125; return 0;&#125; 从代码中可以看出，我们使用BFS的步骤为： 1.对地图信息进行保存 2.找到起点和终点信息 3.从起点开始，对所走过的每一步进行判断 4.如果走的这一步可行，那么储存这一步的信息，并标记这个位置，表示不会再走到这个位置 5.如果不可行，那么就不进行操作 6.找到终点 以上，即为BFS的功能。 DFS(深度优先搜索)DFS的目的是要达到被搜索结构的叶结点。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。 DFS的使用基础为递归，当我们顺着一个节点向下走时，如果走不下去了，就回溯，如果上一个节点还有其他的节点，那么我们就会对这个节点再进行搜索。 对于下面这个图 首先我们将从第一个节点开始出发，然后搜索第二个节点， 因为第二个节点下面还有第四个节点，因此我们继续向下搜索， 第四个节点下面已经没有其他节点，因此我们回溯到第二个节点 第二个节点下面还有第五个节点，因此我们搜索第五个节点 然后继续回溯，到第一个节点， 接下来就搜索第三个节点，第五个节点 当再次回溯到第一个节点时，已经没有其他的节点可进行搜索，因此搜索的过程到此结束，DFS也到此结束。 上面就是DFS的功能，DFS是对所有可能的结果进行一次彻底的搜索，这样会保证不会有任何情况会被遗漏。 接下来看一道例题（HDU1312）Red and Black： There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. Write a program to count the number of black tiles which he can reach by repeating the moves described above. Input The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. ‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set) Output For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input 1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output 12344559613 这个题的大概意思就是给你一个起点，你能够走到多少个地点。 其中 ‘ . ‘是空地，#是墙壁，@是起点。 接下来看一下代码，思想和BFS类似： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define clr(a) memset(a,0,sizeof(a))const int MAXN = 1e5+10;const int INF = 0x3f3f3f3f;const int N = 30;int n,m,sum;char mapp[N][N];//储存地图 int vis[N][N];//标记位置 int dx[4] = &#123;1,-1,0,0&#125;;//四个行走方向 int dy[4] = &#123;0,0,1,-1&#125;;bool check(int x,int y)&#123;//检测不能走通的条件 if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||mapp[x][y]=='#')&#123; return false; &#125; else return true;&#125;void DFS(int x,int y)&#123; if(!check(x,y)||vis[x][y])&#123;//如果不能走通，那么直接返回 return ; &#125; else&#123; sum++; int fx,fy; for(int i=0;i&lt;4;i++)&#123;//在此节点的基础上，再对周围四个节点进行判断 vis[x][y] = true; fx = x + dx[i]; fy = y + dy[i]; DFS(fx,fy);//此处使用递归求解 &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n)!=EOF&amp;&amp;(n||m))&#123; clr(mapp);clr(vis); sum = 0; for(int i=0;i&lt;n;i++)&#123; scanf("%s",mapp[i]); &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(mapp[i][j] == '@')&#123; DFS(i,j); break; &#125; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125; 从代码中我们可以看出，DFS的使用方法为： 1.找出起点 2.对起点四个方向的状态进行判断，如果是空地，就进行递归，继续对这四个方向的位置的四周进行判断，如果不是空地，就结束递归 3.输出结果 DFS与BFS有很多相似的地方，不过BFS求的是最短路，DFS求的是方案数，我们可以根据题目要求选择这两种方法。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[现在已经是2019年。我加入HPU-ACM（现为算法协会）是在18年3月份左右，虽然时间不长，但是已经成为这个大家庭的一份子了。经过了近一年的学习与比赛，我觉得收获了很多，但是回头一想，却又想不起来我到底学过了多少的东西。看着协会里的成员一个个的在努力，在进步，我也希望能够继续深入学习，在ACM的路上走的更远。]]></content>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2019%2F01%2F07%2FFirst%20blog%2F</url>
    <content type="text"><![CDATA[纪念我的第一篇博客 ^_^]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最大子段和]]></title>
    <url>%2F2019%2F08%2F08%2F%E6%9C%80%E5%A4%A7%E5%8C%BA%E9%97%B4%E5%AD%90%E6%AE%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[最大字段和问题为： 给你一个数组，求这个数组中连续子区间和的最大值。 最大字段和前置知识：线段树。 我们将数组中所有的元素存入线段树，然后利用线段树求解此问题。我们需要开四个数组：$pre[\space],nxt[\space],sum[\space],val[\space]$，其分别对应于： $pre[\space]$:最大前缀$nxt[\space]$:最大后缀$sum[\space]$:区间和$val[\space]$:区间最大字段和 对于每个数组，其更新为： 1234pre[i]=max(pre[i*2+1],sum[i*2+1]+pre[i*2+2]);nxt[i]=max(nxt[i*2+2],sum[n*2+2]+nxt[i*2+1]);sum[i]=sum[i*2+1]+sum[i*2+2];val[i]=max(max(val[i*2+1],val[i*2+2]),nxt[i*2+1]+pre[i*2+2]); 其更新原理为： pre[]对于下面这个区间： 他的最大前缀可能为 其对应的子区间状态为(pre[i]=pre[i*2+1])： 而对于另一种前缀: 其对应子区间状态为(pre[i]=sum[i*2+1]+pre[i*2+2])： nxt[]同上,略。 sum[]区间求和，线段树基本操作。 val[]对于一个最大字段和，其有可能是只在左半边或右半边，也有可能左右兼有。即可得。]]></content>
      <categories>
        <category>区间子段和</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Snowy Smile--2019杭电暑期多校训练营(第六场)-E题]]></title>
    <url>%2F2019%2F08%2F08%2FSnowy-Smile-2019%E6%9D%AD%E7%94%B5%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AD%E5%9C%BA-E%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目传送门 题目大意为： 给你 $n(1 \leq n \leq 2000)$个宝箱的坐标，每个宝箱都有一个坐标$(x_i,y_i)(-1e9 \leq x_i,y_i \leq 1e9) $ 价值 $w_i(-1e9 \leq w_i \leq 1e9)$，让你构造一个矩形，使得这个矩形中包含的值总和最大，并输出这个值。 这是一个非常好的题目，我们先把点进行离散化，然后就能够将坐标范围缩小到2000，然后就可以利用线段树动态的来求区间最大子段和。 将坐标离散化后，开始枚举矩形的左右边界。对每一个左边界，我们依次枚举右边界,将处于左右边界之间的点根据 $y$ 值存入一维线段树，然后对当前状态在线段树上 $log$ 时间查询区间最大子段和（计算上下边界）即可。时间复杂度约为$O(n^2log(n))$ 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=10000+10;const int maxm=20000+10;struct node&#123; ll x,y,w;&#125;p[maxn];ll t,q,n,m,N,a[maxn],b[maxn];ll pre[maxm],nxt[maxm],s[maxm],tree[maxm];bool cmp(node i,node j)&#123;return i.x&lt;j.x; &#125;void init()&#123; N=1; while(N&lt;m) N*=2; &#125;void build()&#123; for(int i=0;i&lt;N*2;i++) pre[i]=nxt[i]=s[i]=tree[i]=0;&#125;void update(ll k,ll x)&#123; k+=N-1; s[k]+=x; if(s[k]&gt;0) pre[k]=nxt[k]=tree[k]=s[k]; else pre[k]=nxt[k]=tree[k]=0; while(k)&#123; k=(k-1)/2; s[k]=s[k*2+1]+s[k*2+2]; pre[k]=max(pre[k*2+1],s[k*2+1]+pre[k*2+2]); nxt[k]=max(nxt[k*2+2],s[k*2+2]+nxt[k*2+1]); tree[k]=max(max(tree[k*2+1],tree[k*2+2]),nxt[k*2+1]+pre[k*2+2]); &#125;&#125;void solve()&#123; ll ans=0; ll i,j,k; for(i=1;i&lt;=q;i++)&#123; if(i==1 || p[i].x!=p[i-1].x)&#123; build(); for(j=i;j&lt;=q;j=k)&#123; for(k=j;k&lt;=q &amp;&amp; p[j].x==p[k].x;k++) update(p[k].y,p[k].w); ans=max(ans,tree[0]); &#125; &#125; &#125; printf("%lld\n",ans);&#125;int main()&#123; scanf("%lld",&amp;t); while(t--)&#123; scanf("%lld",&amp;q); for(int i=1;i&lt;=q;i++)&#123; scanf("%lld %lld %lld",&amp;p[i].x,&amp;p[i].y,&amp;p[i].w); a[i]=p[i].x;b[i]=p[i].y; &#125; sort(a+1,a+q+1);n=unique(a+1,a+q+1)-(a+1); sort(b+1,b+q+1);m=unique(b+1,b+q+1)-(b+1); for(int i=1;i&lt;=q;i++)&#123; p[i].x=lower_bound(a+1,a+n+1,p[i].x)-a-1; p[i].y=lower_bound(b+1,b+m+1,p[i].y)-b-1; &#125; sort(p+1,p+q+1,cmp); init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
        <category>最大子段和</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[康托展开和逆康托展开]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E5%92%8C%E9%80%86%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。（源于百度百科） 康托展开康托展开可以在非常短的时间内计算出某个全排列在所有长度相同的全排列中的顺序，其基本思想为： 从左至右计算出当前位所对应的贡献，将每一位的贡献累加即可计算出这个全排列的顺序，其贡献为 $a_i * (n-i)!+1(1 \leq i \leq n)$ ,其中 $a_i $ 表示第 $i$ 位后面有多少位的值小于当前位的值。 举例说明：$5, 3, 2, 4, 1$ ，其顺序为：$$4*(5-1)!+2*(5-2)!+1*(5-3)!+1*(5-4)!+0*(5-5)!+1=112$$所以其是第$112$个全排列，至于最后为什么加$1$，因为对于全排列 $1,2,3,4,5$ ，计算出来的值为：$$0*(5-1)!+0*(5-2)!+0*(5-3)!+0*(5-4)!+0*(5-5)!=0$$其对应的顺序为$0$，所以需要$+1$来修正这个顺序。 代码如下： 12345678910void cantor()&#123; ll sum=1,fac=1; for(int i=n-1;i&gt;0;i--)&#123; fac*=(n-i); for(int j=i+1;j&lt;=n;j++)&#123; if(a[i]&gt;a[j]) sum+=fac; &#125; &#125; printf("%lld\n",sum);&#125; 至于为什么这样算，略……（毕竟证明确实不算难） 逆康托展开逆康托展开与康托展开相对应，求第 $i$ 个全排列的值。 其求解过程与康托展开类似，也是从左至右一位一位进行求解，但过程相对康托展开有些繁琐： 1234567891011121314151617181920void inverse_cantor()&#123; ll fac=1,num; k--; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;n;i++) fac*=i; for(int i=1;i&lt;=n;i++)&#123; num=k/fac; k%=fac; if(n-i) fac/=(n-i); for(int j=1;j&lt;=n;j++)&#123; if(num==0 &amp;&amp; !vis[j])&#123; printf("%d ",j); vis[j]=1; break; &#125; if(!vis[j]) num--; &#125; &#125; printf("\n");&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[subsequence 2--2019牛客暑期多校训练营(第五场)-H题]]></title>
    <url>%2F2019%2F08%2F05%2Fsubsequence-2-2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%94%E5%9C%BA-H%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接（暂未开放） 题目大意为： 给你一个长度为 $n$ 的字符串，字符串中最多只包含有小写字母的前 $m$ 位。给你 $n,m$ 的值，接下来给你 $m*(m-1)/2$ 组字母，每组两个字母，从字符串中按顺序挑出这两种字符串，问能否还原本来的字符串。如果不能，则输出$-1$，否则输出原本的字符串。 样例输入： 12345678&gt; 3 3&gt; ab 2&gt; ab&gt; bc 2&gt; bc&gt; ca 2&gt; ac&gt; 样例输出： 12&gt; abc&gt; 这是一个非常有意思的题目， 如果我们把每个字母都当成一个节点，按照输入的顺序将其进行连有向边，那么这个字符串就能够被表示成一个有向图的形式，接下来我们就能够按照拓扑排序的方法对其进行判断。 我们把每种出现的字母都进行标号，然后开一个数组对每个标号进行连线处理，由于是有向图，只需要对输入的相邻的两个字母进行连边即可. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000+10;int n,m,cnt,len;char tp[maxn],str[maxn];int rudu[maxn];//拓扑排序用int pos[maxn];//每种字符第一次出现的位置int num[maxn];//每种字符的数量int sum[maxn];//用来保存当前字符所对应的标号vector&lt;int&gt;vec[maxn];int ans[maxn];void out(int x)&#123; for(int i=0;i&lt;26;i++)&#123; if(pos[i]&lt;=x &amp;&amp; x&lt;pos[i]+num[i])&#123; printf("%c",i+'a'); return ; &#125; &#125;&#125;int main()&#123; memset(pos,-1,sizeof(pos)); cnt=0; scanf("%d %d",&amp;n,&amp;m); for(int i=0;i&lt;m*(m-1)/2;i++)&#123; memset(sum,0,sizeof(sum)); scanf("%s %d",tp,&amp;len); if(len==0) continue; scanf("%s",str); if(pos[tp[0]-'a']==-1)&#123;//判断是否出现过,下同 pos[tp[0]-'a']=cnt; for(int i=0;i&lt;len;i++) if(str[i]==tp[0]) num[tp[0]-'a']++; cnt+=num[tp[0]-'a']; &#125; if(pos[tp[1]-'a']==-1)&#123; pos[tp[1]-'a']=cnt; for(int i=0;i&lt;len;i++) if(str[i]==tp[1]) num[tp[1]-'a']++; cnt+=num[tp[1]-'a']; &#125; sum[str[0]-'a']++; for(int i=1;i&lt;len;i++)&#123;//连边 int x=str[i-1]-'a'; int y=str[i]-'a'; rudu[pos[y]+sum[y]]++; // printf("%d\n",pos[y]+sum[y]); vec[pos[x]+sum[x]-1].push_back(pos[y]+sum[y]); sum[y]++; &#125; &#125; int flag=0; queue&lt;int&gt;que; for(int i=0;i&lt;cnt;i++)&#123; if(rudu[i]==0)&#123; que.push(i); flag++; &#125; &#125; if(flag!=1) printf("-1\n"); else&#123; bool flag=0; int q=0; while(!que.empty())&#123; int x=que.front(); que.pop(); ans[q++]=x; for(int i=0;i&lt;vec[x].size();i++)&#123; rudu[vec[x][i]]--; if(rudu[vec[x][i]]==0) que.push(vec[x][i]); &#125; &#125; if(flag || q!=n) printf("-1\n"); else&#123; for(int i=0;i&lt;q;i++)&#123; out(ans[i]); &#125; printf("\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[十进制下的矩阵快速幂优化]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%8B%E7%9A%84%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[矩阵快速幂是一种用来求解递推式问题的高效算法，能在 $log$ 的时间内求解递推式的某一项。但是当 $n$ 变得非常大时（远远超过了 $long long$ 的表示范围，比如$10^{10^{5}}$），单纯的矩阵快速幂就会浪费大量的时间在处理字符串上，这是就需要使用十进制的优化了。 2019牛客多校第五场B题（暂未开放） 题目大意为： 给你一个递推式的第零项 $x_0$ 和第一项 $x_1$ 以及通项公式 $x_i=a*x_{i-1}+b*x_{i-2}(i&gt;1)$ , 求该数列第 $n(1\leq n \leq 10^{10^6})$ 项模 $mod$ 的值。 假如使用二进制模拟，那么时间复杂度为 $log(n)*len(n)$ ，$len$ 为 $n$ 的长度，那么超时是在所难免的，此时就需要用一下(奇)技(淫)巧了。 十进制的表示下，1234可以分解成$1*1000+2*100+3*10+4$ ，矩阵快速幂的优化也基于此，我们计算出系数矩阵的第 $10^x$ 次方项，然后计算出当前十进制下从低到高第 $x$ 位所对应的值，就可以计算出当前为所对应的系数矩阵的值，然后再用二进制下求解矩阵快速幂的方法求出系数矩阵第 $10^{x+1}$ 项的值，就可以继续依次求解了。 题目代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll x0,x1,a,b,mod;char n[1000000+10];struct node&#123; ll a[2][2];&#125;;node operator *(node x,node y)&#123; node res; for(ll i=0;i&lt;2;i++)&#123; for(ll j=0;j&lt;2;j++)&#123; res.a[i][j]=0; for(ll k=0;k&lt;2;k++)&#123; res.a[i][j]=(res.a[i][j]+x.a[i][k]*y.a[k][j])%mod; &#125; &#125; &#125; return res;&#125;node qp(node a,ll b)&#123; node res; res.a[0][0]=res.a[1][1]=1; res.a[0][1]=res.a[1][0]=0; while(b)&#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf("%lld %lld %lld %lld %s %lld",&amp;x0,&amp;x1,&amp;a,&amp;b,&amp;n,&amp;mod); node x; x.a[0][0]=a;x.a[0][1]=b; x.a[1][0]=1;x.a[1][1]=0; node ans; ans.a[0][0]=ans.a[1][1]=1; ans.a[1][0]=ans.a[0][1]=0; ll len=strlen(n); //由于是n-1次方，所以需要减1 for(ll i=len-1;i&gt;=0;i--)&#123; if(n[i]!='0')&#123; n[i]--; for(ll j=i+1;j&lt;len;j++) n[j]='9'; break; &#125; &#125; for(ll i=len-1;i&gt;=0;i--)&#123; ans=ans*qp(x,n[i]-'0'); x=qp(x,10); &#125; printf("%lld\n",(ans.a[0][0]*x1+ans.a[0][1]*x0)%mod); return 0;&#125;]]></content>
      <categories>
        <category>矩阵快速幂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线性基]]></title>
    <url>%2F2019%2F07%2F23%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[线性基是用来求解数组子集最大异或和的一种方法。其思想与线性代数中的最大线性无关组相似。 线性基的性质线性基有以下几种性质： 数组中的所有元素都能够用线性基中的元素相互异或计算出来 线性基中不存在异或值为0的子集 满足性质1的前提下，线性基中的元素个数是最少的。 线性基中每个元素二进制位数均不相同 线性基的计算对于当前所求出来的线性基，我们在插入一个新的元素时（即使得其表示范围多一个数 $x$），要保证插入的元素与其他元素异或不为零。 根据性质4，我们能够通过位运算对插入的元素进行异或计算：$$x = p_1 \bigoplus p_2 \bigoplus … \bigoplus p_i \bigoplus p_x$$$p_i$ 为线性基中的某个基，则：$$p_x = p_1 \bigoplus p_2 \bigoplus … \bigoplus p_i \bigoplus x$$根据性质4，我们求解的线性基中不能包含二进制位数相同的数，因此我们把x按照最高位向最低位异或的方式进行计算，假如当前x的二进制最高位所对应的基存在，则x异或这个基（此时x的值会改变），这样能够保证x的二进制位数至少能够减少1位，然后继续进行计算，计算终点有两种结果： x二进制最高位对应的基不存在，则把x插入线性基，运算结束 x值变为0，说明当前线性基能够表示最开始的x，则直接结束。 这样就能够求出来 $p_x$ 的值，即线性基需要插入的元素。 代码如下： 1234567891011void update(int x)&#123; for(int i=30;i&gt;=0;i--)&#123; if(x&gt;&gt;i)&#123; if(!f[i])&#123; f[i]=x; return ; &#125; x^=f[i]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>线性基</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Operation--2019杭电多校训练第一场-B题]]></title>
    <url>%2F2019%2F07%2F23%2FOperation-2019%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%B8%80%E5%9C%BA-B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目传送门 题目大意为： 给你一个1~n的数组,然后有m个操作，0操作为在数组最后添加一个新元素，1操作为查询区间 $[l,r]$ 子集异或最大值。 其中输入经过加密操作，需要经过解密才能获取正确数据（强制在线） 看到了子集异或值就应该知道是使用线性基的知识。 如果按照暴力的解法一定会超时，但是我们可以通过一定贪心策略找到当前的最优解。 （下面就需要对线性基有清晰的认识了） 添加元素对于区间$[1,x]$$(1 \leq x \leq n)$，我们可以通过继承的方式找到每个区间的线性基： 1234for(int j=30;j&gt;=0;j--)&#123; f[i][j]=f[i-1][j];//将上一个区间[1,i-1]的线性基继承到[1,i] pos[i][j]=pos[i-1][j];//pos数组用来保存 计算出线性基第j个基的元素的位置&#125; 继承之后我们就可以求解当前区间的线性基了。 在求解时，我们需要用贪心的策略对线性基进行更新： 12345678910111213141516171819k=i;for(int j=30;j&gt;=0;j--)&#123; if(x&gt;&gt;j)&#123; if(!f[i][j])&#123; f[i][j]=x; pos[i][j]=k; break; &#125; else&#123; //这一步是贪心策略，将计算出基的元素尽量的靠右 //由线性基的性质可知，在替换掉当前元素后，线性基的性质和表示范围不会发生改变。 if(k&gt;pos[i][j])&#123; swap(k,pos); swap(x,f[i][j]); &#125; x^=f[i][j]; &#125; &#125;&#125; 查询区间最大值假设需要计算的区间为 $[l,r]$ （已经过转换），那么我们接下来就要根据利用线性基求子集最大值的方法来进行求解了。 对于 $f[i][j]$ ,我们可以知道这个基的有效范围为 $[1,pos[i][j]]$ ,当 $l&gt;pos[i][j]时$ 这个基就已经没有了计算的意义。 所以使用 $S=\lbrace f[r][j]~| l \leq pos[r][j] \rbrace$ 就能够用来表示区间 $[l,r]$ 的所有子集异或和： 12345ans=0;for(int j=30;j&gt;=0;j--)&#123; if((ans^f[r][j])&gt;ans &amp;&amp; pos[r][j]&gt;=l) ans^=f[r][j];&#125; 这样就能够简便的计算出区间 $[l,r]$ 子集的异或和最大值。 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000+10;int t,n,m,l,r,op,res;int a[maxn];int f[maxn][32],pos[maxn][32];void add(int i,int x)&#123; int k=i; for(int j=30;j&gt;=0;j--)&#123; f[i][j]=f[i-1][j]; pos[i][j]=pos[i-1][j]; &#125; for(int j=30;j&gt;=0;j--)&#123; if(x&gt;&gt;j)&#123; if(!f[i][j])&#123; f[i][j]=x; pos[i][j]=k; break; &#125; else&#123; if(k&gt;pos[i][j])&#123; swap(k,pos[i][j]); swap(x,f[i][j]); &#125; x^=f[i][j]; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d %d",&amp;n,&amp;m); res=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); add(i,a[i]); &#125; while(m--)&#123; scanf("%d",&amp;op); if(op)&#123; scanf("%d",&amp;a[++n]); a[n]=a[n]^res; add(n,a[n]); &#125; else&#123; scanf("%d %d",&amp;l,&amp;r); l=(l^res)%n+1;r=(r^res)%n+1; if(l&gt;r) swap(l,r); res=0; for(int j=30;j&gt;=0;j--)&#123; if((res^f[r][j])&gt;res &amp;&amp; pos[r][j]&gt;=l) res^=f[r][j]; &#125; printf("%d\n",res); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=30;j&gt;=0;j--)&#123; f[i][j]=pos[i][j]=0; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线性基</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[换根dp]]></title>
    <url>%2F2019%2F07%2F22%2F%E6%8D%A2%E6%A0%B9dp%2F</url>
    <content type="text"><![CDATA[换根dp是用来求解树上各点到其他点的距离之和的问题。 在进行换根dp时，需要先利用 $dfs$ 计算出根节点到其他节点的距离之和，以及以每个节点为根节点的子树的节点数量。然后再对其进行换根dp。 Part1:计算根节点到其他节点距离之和我们在求解时利用递归的思想进行求解： 假设 $a$ 为根节点，$b$ 为直系子节点，那么对于 $b$ 所在子树对 $a$ 的贡献为 $dis[b]+point[b]$ ,其中 $dis[b]$为 $b$到以b为根节点的子树中所有点的距离之和。$point[b]$为以 $b$ 为根节点的子树中的点的个数，其实很好理解，就相当于以 $b$ 为根节点中的所有路径长度全部 $+1$，然后就到达了 $a$ 节点。 代码如下： 1234567891011121314151617181920int dis[maxn];//第一次dfs每个节点到其子节点距离之和 int point[maxn];//每个节点下子节点个数（包括这个节点本身） int dp[maxn];//最终结果 bool vis[maxn];vector&lt;int&gt;vec[maxn];void dfs(int x)&#123; vis[x]=true; int sum=0; for(int i=0;i&lt;vec[x].size();i++)&#123; int y=vec[x][i]; if(!vis[y])&#123; dfs(y); sum+=point[y]; dis[x]+=dis[y]+point[y]; &#125; &#125; point[x]=sum+1; return ;&#125; Part2:进行换根dp准备工作做完之后，我们就可以开始换根dp，换根dp的思想就是把与根相连的节点通过一定的操作将其变为根。 依然利用上述节点 $a,b$ ,将根节点从 $a$ 移动到 $b$ ，$dp[b]$ 的值为：$dp[a]+-point[b]+(n-point[b])$，其中： $-point[b]$ 表示从 $b$ 引申出来的 $point[b]$ 条路径长度全部 $- 1$. $n-point[b]$ 表示从 $a$ 引申出来的不包含 $b$ 的其他路径长度全部 $+1$ 状态转移方程计算出来之后就可以利用 $dfs$ 进行换根dp了。 代码如下（初始状态下$dp[a]=dis[a]$）： 12345678910void Dp(int x)&#123; vis[x]=true; for(int i=0;i&lt;vec[x].size();i++)&#123; int y=vec[x][i]; if(!vis[y])&#123; dp[y]=dp[x]-point[y]+n-point[y]; Dp(y); &#125; &#125;&#125; 这样就能计算出所有的点到其他节点的距离之和了。]]></content>
      <categories>
        <category>换根dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cotree--2019CCPC-江西省赛-A题]]></title>
    <url>%2F2019%2F07%2F22%2FCotree-2019CCPC-%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9B-A%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接（杭电重现赛） 题目大意： 给你两棵树，在这两棵树上分别找一个点，将其连接，使得$\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}dis(i,j)$ 最小，其中$dis(i,j)$表示从节点 $i$ 到节点 $j$ 的边数。 Part1首先我们需要判断我们找的这两个点应该是哪个点，对于两棵树，他们的 $dis$ 和是固定的,因此我们需要讨论将两个点连接起来所增加的花费。 假设需要连接的两棵树$A,B$,两棵树上进行连接的点为 $u,v$ ， 点 $u,v$ 到其所在子树其他点的距离之和为$Dis_u,Dis_v$ ，$A,B$ 上点的个数为 $P_A,P_B$, 那么将其连接后增加的 $dis$ 值为：$$Dis_u*P_B+Dis_v*P_A+P_A*P_B$$很容易理解： 对于树 $A$ 上的任意一个点 $w$ ，我们需要将其和 $B$ 上的所有点进行一次连接，等同于需要将$dis(w,u)$ 重复计算 $P_B$ 次，其他点同理，因此 $A$ 树上增加的 $dis$ 值为 $Dis_u*P_B$ ，B树同理。 而对于刚建立的通道 $dis(u,v)=1$ 被使用了 $P_A*P_B$ 因此总的增加量即为上式。 $P_A,P_B$为定值，所以我们只需要最小化 $Dis_u,Dis_v$ 即可。 Part2现在的问题已经简化成了如何求一棵树上的 $Dis$ 的最小值。 首先我们需要一遍dfs将树的根节点的 $Dis$ 值找出来，找出来之后，我们就使用换根dp计算出树上所有节点的$Dis$值。 然后找出 $Dis$ 最小的点，进行连接，再次进行上述操作即可。 最后将所有节点的 $Dis$ 全部求和，由于这个值是求的双向的，因此需要除以2。 代码如下（代码有些冗长）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair&lt;int,int&gt;const ll INF=0x3f3f3f3f3f3f3f3f;const int maxn=1000000+10;const ll mod=1e9+7;vector&lt;ll&gt;vec[maxn];ll n;ll dp[maxn];ll num[maxn];ll vis[maxn];ll vis2[maxn];ll value[maxn];ll flag,point;void init()&#123;//清空数组 memset(dp,0,sizeof(dp)); memset(num,0,sizeof(num)); memset(vis,0,sizeof(vis)); memset(vis2,0,sizeof(vis2)); memset(value,0,sizeof(value));&#125;ll dfs(ll x)&#123;//dfs找所有的值，num表示以这个点为根节点下面有几个点（包括这个点，dp用），value是这个点到所有子树的距离之和 vis[x]=flag; ll sum=0; for(ll i=0;i&lt;vec[x].size();i++)&#123; ll y=vec[x][i]; if(!vis[y])&#123; int q=dfs(y); sum+=q; value[x]+=value[y]+q; &#125; &#125; num[x]=sum+1; return sum+1;&#125;void Dp(ll x)&#123;//dp数组表示当前这个点到其他点的距离之和 vis2[x]=flag; for(ll i=0;i&lt;vec[x].size();i++)&#123; ll y=vec[x][i]; if(!vis2[y])&#123; dp[y]=dp[x]-num[y]+point-num[y];//换根dp方程 Dp(y); &#125; &#125;&#125;void solve()&#123; for(int i=1;i&lt;=n;i++) vec[i].clear(); init(); ll u,v; for(ll i=0;i&lt;n-2;i++)&#123; scanf("%lld %lld",&amp;u,&amp;v); vec[u].push_back(v); vec[v].push_back(u); &#125; //使用flag的值对第一颗子树和第二棵子树进行区分，下同 flag=1; dfs(1); dp[1]=value[1]; flag++; for(ll i=1;i&lt;=n;i++) if(!vis[i])&#123; dfs(i); dp[i]=value[i]; break; &#125; //point是当前两个子树之一的点的个数 point=0; for(int i=1;i&lt;=n;i++) if(vis[i]==1) point++; flag=1; Dp(1); flag++; point=n-point; for(ll i=1;i&lt;=n;i++) if(!vis2[i])&#123; Dp(i); break; &#125; //找到两个树上到其他点距离最小的点 ll v1=INF,v2=INF,p1,p2; for(ll i=1;i&lt;=n;i++)&#123; if(vis2[i]==1 &amp;&amp; dp[i]&lt;=v1)&#123; p1=i; v1=dp[i]; &#125; if(vis2[i]==2 &amp;&amp; dp[i]&lt;=v2)&#123; p2=i; v2=dp[i]; &#125; &#125; vec[p1].push_back(p2); vec[p2].push_back(p1); //重新进行dfs 和 dp 计算出这棵大树的所有dp值 init(); flag=1; dfs(1); dp[1]=value[1]; point=n; Dp(1); //a-&gt;b b-&gt;a计算两次，所以 /2 ll res=0; for(ll i=1;i&lt;=n;i++) res+=dp[i]; printf("%lld\n",res/2ll);&#125;int main()&#123; while(~scanf("%lld",&amp;n)) solve(); return 0;&#125;]]></content>
      <categories>
        <category>换根dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ABAB--2019牛客暑期多校训练营(第一场)- E题]]></title>
    <url>%2F2019%2F07%2F18%2FABAB-2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%9C%BA-E%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目传送门 题目大意： 构造一个长为 $2*(n+m)$ 的字符串，使得能从中按顺序挑出 $n$ 个”AB”子串和 $m$ 个”BA”子串，问这样的字符串一共有多少个。 一个似乎比较明显的dp问题，类似于括号配对。 二维dp,dp[i][j],表示前i个字符,字母A和字母B的差为j个，然后就可以进行dp了。 代码如下： 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair&lt;int,int&gt;const int maxn=1000000+10;const ll mod=1000000007;const int INF=0x3f3f3f3f;ll dp[1000*4+10][1000*4];int main()&#123; int n,m; while(~scanf("%d %d",&amp;n,&amp;m))&#123; for(int i=1;i&lt;=(n+m)*2;i++)&#123; for(int j=1000-m-1;j&lt;=1000+n+1;j++)&#123; dp[i][j]=0; &#125; &#125; dp[0][1000]=1; for(int i=1;i&lt;=(n+m)*2;i++)&#123; for(int j=1000-m;j&lt;=1000+n;j++)&#123; dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]; dp[i][j]%=mod; &#125; &#125; printf("%lld\n",dp[(n+m)*2][1000]%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>dp</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Count The Rectangles(Educational Codeforces Round 68-E题)]]></title>
    <url>%2F2019%2F07%2F15%2FCount-The-Rectangles-Educational-Codeforces-Round-68-E%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目传送门 题目大意为： 给你n条水平或竖直的线段，问利用这些线段能够圈出多少个不同的矩形。 如果利用四条线段圈出了一个矩形，那么两条平行线一定与竖直线都相交。因此，我们只需要求与任意两条水平线均相交的竖直线的数量，然后进行排列组合 $(n*(n-1)/2)$ ,就能够找出用这两条水平线所能够圈出来的矩形的个数。 所以我们首先需要将所有的水平线与竖直线的相交情况计算出来，之后再进行枚举计算即可。 但是由于数据范围过大，在枚举两条水平线后如果再用一个循环来寻找竖直线的相交情况会超时，因此我们需要用bitset来处理最后一个循环。bitset 用法详见bitset用法。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair&lt;int,int&gt;const int maxn=1000000+10;const int INF=0x3f3f3f3f;struct node&#123; int x1,y1,x2,y2;&#125;R[5000+10],C[5000+10];bitset&lt;5000+10&gt;p1[5000+10],p2[5000+10];bool judge(node i,node j)&#123; if((i.y2&gt;=j.y1 &amp;&amp; j.y1&gt;=i.y1) &amp;&amp; (j.x2&gt;=i.x1 &amp;&amp; i.x1&gt;=j.x1) return true; return false;&#125;int main()&#123; int n,a,b,c,d; int sum1=0,sum2=0; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d %d %d %d",&amp;a,&amp;b,&amp;c,&amp;d); if(a==c)&#123; R[sum1].x1=a; R[sum1].y1=min(b,d); R[sum1].x2=c; R[sum1++].y2=max(b,d); &#125; else&#123; C[sum2].x1=min(a,c); C[sum2].y1=b; C[sum2].x2=max(a,c); C[sum2++].y2=d; &#125; &#125; for(int i=0;i&lt;sum1;i++)&#123; for(int j=0;j&lt;sum2;j++)&#123; if(judge(R[i],C[j]))&#123; p1[i][j]=1; p2[j][i]=1; &#125; &#125; &#125; ll res=0,sum; //选择数量较少的水平线或竖直线进行计算 int N=min(sum1,sum2); for(int i=0;i&lt;N;i++)&#123; for(int j=i+1;j&lt;N;j++)&#123; if(sum1&lt;sum2) sum=(p1[i] &amp; p1[j]).count(); else sum=(p2[i] &amp; p2[j]).count(); res+=sum*(sum-1)/2; &#125; &#125; printf("%lld\n",res); return 0;&#125;]]></content>
      <categories>
        <category>bitset</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bitset用法]]></title>
    <url>%2F2019%2F07%2F15%2Fbitset%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[bitset 与map,vector,queue等相似，为C++标准函数库中的一类容器。其结构类似于数组，但是只能够存放0或1。 bitset的定义在定义bitset 时，一般有以下几种方法： 123456789//定义一个大小为10的bitsetbitset&lt;10&gt;bit1;//定义一个大小为10，初始数据为10的bitsetbitset&lt;10&gt;bit2(10);//定义一个大小为10，初始数据为10110的bitsetstring str1="10110";bitset&lt;10&gt;bit3(str1); 以上三种方法构造出来的bitset所储存的数据分别为： 123cout &lt;&lt; bit1 &lt;&lt; endl; //0000000000cout &lt;&lt; bit2 &lt;&lt; endl; //0000001010cout &lt;&lt; bit3 &lt;&lt; endl; //0000010110 在定义时后面加的(10) 、（str1)作用均为初始化。其中利用string进行初始化时字符串中只能包含0或1，包含其他字符时就会报错。 在初始化时，如果初始化数据大小小于定义的bitset大小，那么就直接右对齐，否则： 如果初始化的数字大于定义的bitset大小，则留下后面部分，舍去高位数据如果初始化的字符串长度大于定义的bitset大小，则留下前面部分，舍去低位数据 从其储存的数据来看，其结构类似于bool数组，但其功能要比bool数组多得多。 bitset位运算对bitset进行位运算时，可以把它当作数字来进行计算。 123456789bitset&lt;10&gt;bit1(3);bitset&lt;10&gt;bit2(5);cout &lt;&lt; (bit1&lt;&lt;1) &lt;&lt; endl; //0000000110cout &lt;&lt; (bit2&gt;&gt;1) &lt;&lt; endl; //0000000010cout &lt;&lt; (bit1 &amp; bit2) &lt;&lt; endl; //0000000001cout &lt;&lt; (bit1 | bit2) &lt;&lt; endl; //0000000111cout &lt;&lt; (bit1 ^ bit2) &lt;&lt; endl; //0000000110...... 需要注意的是，两个bitset进行位运算时，只能够数组大小相同才能够运算，否则就会报错。 另外，对bitset中元素进行修改时，可按照数组的方式进行修改。但是其下标顺序为从右到左，最右数组元素下标为0。 bitset功能函数bitset与其他容器一样，也有许多函数： 统计判断函数12345bitset&lt;10&gt;bit1(3);cout &lt;&lt; bit1.count() &lt;&lt; endl; //2 //计算bit1中又多少个1cout &lt;&lt; bit1.any() &lt;&lt; endl; //1 //判断其中是否有1cout &lt;&lt; bit1.none() &lt;&lt; endl; //0 //判断其中是否全为0cout &lt;&lt; bit1.all() &lt;&lt; endl; //0 //盘但其中是否全为1 位运算函数12345678910bitset&lt;10&gt;bit1(10);cout &lt;&lt; bit1.flip() &lt;&lt; endl; //1111110101 //将所有元素倒置cout &lt;&lt; bit1.flip(3) &lt;&lt; endl; //1111111101 //将数组下标为3的元素倒置cout &lt;&lt; bit1.set() &lt;&lt; endl; //1111111111 //全部重置1cout &lt;&lt; bit1.set(3,0) &lt;&lt; endl;//1111110111 //将数组下标为3的元素置为0cout &lt;&lt; bit1.set(3) &lt;&lt; endl; //1111111111 //如果没有第二个参数，默认为1cout &lt;&lt; bit1.reset(3) &lt;&lt; endl;//1111110111 //将数组下标为3的元素置为0cout &lt;&lt; bit1.reset() &lt;&lt; endl; //0000000000 //将所有元素置为0 转化函数12345bitset&lt;10&gt;bit1(10);string str=bit1.to_string(); //转化为字符串unsigned long a=bit1.to_ulong();//转化为unsigned long cout &lt;&lt; str &lt;&lt; endl; //0000001010cout &lt;&lt; a &lt;&lt; endl; //10 本文参考于长岛冰茶、的博客]]></content>
      <categories>
        <category>bitset</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Tokitsukaze and Strange Rectangle(codeforces Round #573(Div.2)-F)]]></title>
    <url>%2F2019%2F07%2F14%2FTokitsukaze-and-Strange-Rectangle-codeforces-Round-573-Div-2-F%2F</url>
    <content type="text"><![CDATA[题目传送门 题目大意为： 给你n个一维象限的坐标，用$y=a,y=INF,x=l,x=r$ 所组成的的矩形包含的点构成一个点集，求所有不相同的点集数量。 非常复杂的一个题(just for me)。 对于一个点集，一定会有最靠左的点 $x_L$,最靠右的点 $x_R$ ，最靠下的点 $y_D$ .通过观察可知，只要固定了这三个点，就可以确定出一个点集。因此我们现在的任务就变成了如何计算所有的$x_L,x_R,y_D$。 首先我们固定 $y_D$ 的值，然后根据 $y_D$ 的值求出所有在 $y=y_D$ 上面的点，由定义可知$x_L \leq x_D \leq x_R$ ,$x_D$为$y_D$ 所对定的点的横坐标，因此我们需要计算纵坐标大于等于y_D的点中横坐标小于等于x_D的点的数量和大于等于x_D的点的数量。 在计算点的数量时，我们可以先离散化所有点的横坐标，然后利用线段树或树状数组进行查询。 但是有一种情况，如果有两个点的横坐标相同，那么求出来的点集就会有重复的情况。所以我们需要对所求的值进行某些简化。 我们在计算以 $y_{1D}$ 为底的点集时，如果 $y_{2D}==y_{1D} 并且 x_{1D} \leq x_{2D}$ , 那么我们在求大于等于 $x_{1D}$的点的数量时只需要求横坐标在区间$[ x_{1D} , x_{2D} - 1 ]$的数即可。这样就能避免某些点集被重复计算。 代码如下（查询方式实现为线段树）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll INF=0x3f3f3f3f3f3f3f3f;const ll mod=1000000007;const ll maxn=1000000+10;struct node&#123; int x,y; bool friend operator &lt;(node i,node j)&#123; if(i.y==j.y) return i.x&lt;j.x; return i.y&gt;j.y; &#125;&#125;a[maxn];int c[maxn],vis[maxn];int sum[maxn];int n,N;void init(int x)&#123; N=1; while(N&lt;x) N*=2;&#125;void update(int k)&#123; k+=N-1; sum[k]++; while(k)&#123; k=(k-1)/2; sum[k]++; &#125;&#125;int query(int a,int b,int l,int r,int k)&#123; if(b&lt;0) return 0; if(r&lt;a || b&lt;l) return 0; if(a&lt;=l &amp;&amp; r&lt;=b) return sum[k]; else&#123; int vl=query(a,b,l,(l+r)/2,k*2+1); int vr=query(a,b,(l+r)/2+1,r,k*2+2); return vl+vr; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d %d",&amp;a[i].x,&amp;a[i].y); c[i]=a[i].x; &#125; sort(c,c+n); int p=unique(c,c+n)-c; for(int i=0;i&lt;n;i++) a[i].x=lower_bound(c,c+n,a[i].x)-c; sort(a,a+n); init(n); ll res=0; int list=0;//list用来标记相同的纵坐标的数的起点。 for(int i=0;i&lt;n;i++)&#123; if(a[i].y!=a[i+1].y)&#123; //每次都对相同的纵坐标的数进行一次统一的计算 for(int j=last;j&lt;=i;j++)&#123; if(!vis[a[j].x])&#123; vis[a[j].x]=1; update(a[j].x); &#125; ll vl=query(0,a[j].x,0,N-1,0); //当j==i时，没有最右边的限制，因此我们就把N-1作为最右边的边界 ll vr=query(0,(j==i)?N-1:a[j+1].x-1,0,N-1,0) - query(0,a[j].x-1,0,N-1,0); res+=vl*vr; &#125; last=i+1; &#125; &#125; printf("%lld\n",res); return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kiki & Little Kiki 2(HDU-2276)]]></title>
    <url>%2F2019%2F06%2F30%2FKiki-Little-Kiki-2-HDU-2276%2F</url>
    <content type="text"><![CDATA[题目传送门 这道题的大致意思为： 给你一圈灯，0表示灭，1表示亮。 对于任意一个灯，如果在这一秒它的左边的灯（1的左边为n）为亮，那么下一秒这个灯的状态就改变（亮变灭，灭变亮）。问经过n秒后所有灯的状态是什么样的。 这个题非常的巧妙，假如前一个灯是1，那么后一个灯状态就会改变，不是1就不变。 这个操作与二进制中的异或操作十分相似，即 $ a[i]=a[i-1]$ ^ $a[i]$。 那么每个灯每轮亮或灭对应的操作就转化成了前面这个公式。 那么我们就把问题简化成了： 对于每个灯，我们分别求 $ a[i]=a[i-1]$ ^ $a[i]$，问经过n轮后所有灯的状态是什么样的。 既然我们已经求出了通项公式，那么我们就可以利用矩阵乘法去求解：$$\begin{bmatrix}a[i] \\a[i-1] \\a[i-2] \\… \\a[1]\end{bmatrix}=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; …&amp; 0 &amp; 1 \\1 &amp; 1 &amp; 0 &amp; …&amp; 0 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; …&amp; 0 &amp; 0 \\… \\0 &amp; 0 &amp; 0 &amp; …&amp; 1 &amp; 1 \\\end{bmatrix}*\begin{bmatrix}a[i] \\a[i-1] \\a[i-2] \\… \\a[1]\end{bmatrix}$$这里用到了一个关于异或的性质：异或是不进位的加法，因此对于求出来的 $a[i]$ ，我们只需要对其进行%2（或&amp;1）操作即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;#define PI acos(-1.0)#define clc(x) memset(x,0,sizeof(x))char str[10000];int len;struct node&#123; int a[100+10][100+10];&#125;;node operator *(node x,node y)&#123; node z; for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;len;j++)&#123; z.a[i][j]=0; for(int k=0;k&lt;len;k++)&#123; z.a[i][j]+=x.a[i][k]*y.a[k][j]; &#125; z.a[i][j]&amp;=1; &#125; &#125; return z;&#125;node operator *(node x,int b)&#123; node res; clc(res.a); for(int i=0;i&lt;len;i++) res.a[i][i]=1; while(b)&#123; if(b&amp;1) res=res*x; x=x*x; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; scanf("%s",str); len=strlen(str); node x; memset(x.a,0,sizeof(x.a)); for(int i=0;i&lt;len;i++) x.a[i][i]=x.a[i][(i-1+len)%len]=1; node res; clc(res.a); res=x*n; node b; clc(b.a); for(int i=0;i&lt;len;i++) b.a[i][0]=str[i]-'0'; res=res*b; for(int i=0;i&lt;len;i++) printf("%d",res.a[i][0]); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>矩阵快速幂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lower_bound()基本操作方法]]></title>
    <url>%2F2019%2F06%2F18%2Flower-bound-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[lower_bound()函数是一个非常有用的查找函数，其作用为在log级别的时间内查找数组中所需要的元素。 lower_bound()的使用数组的lower_bound()lower_bound()所在函数头文件为： 1#include&lt;algorithm&gt; 其基本格式为： 1lower(a+x,a+y,z) 上面这个代码作用为查找数组 a[] 中 a[x]~a[y] 之间第一个大于等于 z 的值。其返回值是一个地址，并不是一个数，因此在赋值时使用下面这两种形式： 123456//查找到的位置减去数组初始位置就是该元素在数组中的位置int pos = lower_bound(a+x,a+y,z) - a;a[pos] = t;//直接对该位置进行赋值操作*lower_bound(a+x,a+y,z) = t; 这是最基本的使用方式。 而它很巧妙的一种应用就是计算一个数组的最长连续递增子序列（LIS）： 12345memset(dp,INF,sizeof(dp));for(int i=0;i&lt;n;i++)&#123; *lower_bound(dp,dp+n,a[i])=a[i];&#125;int res=lower_bound(dp,dp+n,INF)-a; 这个代码对初学者来说有点难理解，但是理解之后感觉到这个代码的精彩之处。 结构体的lower_bound()先来看一道题目：数据结构题 这个题目就使用到了lower_bound()，但是并不那么容易直接想到。 首先我们对输入的信息进行处理： 12345678910111213struct node&#123; int x,pos; bool friend operator &lt;(node i,node j)&#123; if(i.x==j.x) return i.pos&lt;j.pos; return i.x&lt;j.x; &#125;&#125;a[maxn];for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].x); a[i].pos=i;&#125;sort(a+1,a+n+1); 上述操作是为了将输入的数组元素从小到大排序，如果相同，则按照输入顺序进行排序。 当我们处理完数据后，我们就可以使用 lower_bound() 直接来进行操作。 我们的目的是找到所有的 x 中位于 l 和 r 之间的个数： 12345int query(int l,int r,int x)&#123; int s=lower_bound(a+1,a+n+1,(node)&#123;x,l&#125;)-a; int t=upper_bound(a+1,a+n+1,(node)&#123;x,r&#125;)-a; return t-s;&#125; s 是找到的第一个等于符合条件的 x 的位置。 t 是找到的第一个大于符合条件的 x 的位置。 两者相减即为符合条件的元素的个数。 其中，如何进行查找则是根据结构体中重载的规则。 AC代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000+10;const int INF=0x3f3f3f3f;int n,m;int mod=20180623;struct node&#123; int x,pos; bool friend operator &lt;(node i,node j)&#123; if(i.x==j.x) return i.pos&lt;j.pos; return i.x&lt;j.x; &#125;&#125;a[maxn];int query(int l,int r,int x)&#123; int s=lower_bound(a+1,a+n+1,(node)&#123;x,l&#125;)-a; int t=upper_bound(a+1,a+n+1,(node)&#123;x,r&#125;)-a; return t-s;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].x); a[i].pos=i; &#125; sort(a+1,a+n+1); int l,r,l1,r1,x; while(m--)&#123; scanf("%d %d %d %d %d",&amp;l,&amp;r,&amp;l1,&amp;r1,&amp;x); if(l&gt;r) swap(l,r); if(l1&gt;r1) swap(l1,r1); int s=query(l,r,x),t=query(l1,r1,x); printf("%d\n%d\n%lld\n",s%mod,t%mod,(1ll*s*t)%mod); &#125; return 0;&#125; upper_bound()的使用upper_bound()的作用于lower_bound()类似，只是查找位置变成了第一个大于查找元素的位置，其他操作与lower_bound()相同，因此不再赘述。]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈梯度下降]]></title>
    <url>%2F2019%2F05%2F18%2F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%2F</url>
    <content type="text"><![CDATA[梯度下降是迭代法的一种,可以用于求解最小二乘问题(线性和非线性都可以)。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。反过来，如果我们需要求解损失函数的最大值，这时就需要用梯度上升法来迭代了。在机器学习中，基于基本的梯度下降法发展了两种梯度下降方法，分别为随机梯度下降法和批量梯度下降法。 梯度下降法梯度下降法是使用迭代的方法求解曲线的近似函数。 梯度下降主要的步骤为： 猜想近似函数 $h(x)$ 计算出损失函数 $J(θ)= \frac{1}{2}*( h(x) - y )^2$,其中 $y$ 为 $θ$ 对应的实际值。 迭代求解。 猜想近似函数梯度下降的第一步就是猜想近似函数，猜想出来后才能根据这个函数进行函数求解。一般是根据实际值在图像中所形成的图形进行猜想。 计算损失函数实际值和近似函数计算出来的值会有一些差异，梯度下降就是尽量减少这个差异。因此我们需要计算损失函数，使得损失函数尽可能的接近0. 前两步是准备工作。 迭代求解在我们计算出损失函数后，我们需要对其函数系数值进行修正。梯度下降是按照函数在某一点的导数进行修正，当迭代的次数足够多时，系数值趋于稳定时，我们就可以认为近似的求出来了曲线的近似函数。 单变量线性回归问题房屋价格与面积（数据在下面表格中） 序号 面积 价格 1 150 6450 2 200 7450 3 250 8450 4 300 9450 5 350 11450 6 400 15450 7 600 18450 使用梯度下降求解线性回归（求 $θ_0 , θ_1$ ）: $$h_{θ(x)}=θ_0+θ_1*x$$ 首先我们要写出损失函数：$$J(θ)=\frac{1}{2m}\sum_{i=1}^{m}{(h_θ(x^{(i)}）-y^{(i)})^2}$$其中 $x^{(i)} ，y^{(i)}$ 分别表示房屋面积和价格的值。$\frac{1}{2}$ 方便函数化简，不影响最终结果。$\frac{1}{m}$ 中 $m$ 表示数据集中元素个数，本题 $m=7$ . 然后我们求解导函数： $$\nabla J_{θ0} =\frac{1}{m}\sum_{i=1}^{m}{(h_{θ_1}(x^{(i)})-y^{(i)})}*θ_1$$ $$\nabla {J_{θ1}}= \frac{1}{m} \sum_{i=1}^{m}{(h_{θ_1}(x^{(i)})-y^{(i)})}*θ_1$$ 上面两式是对 $θ_1,θ_2$ 求偏导所得到的函数。然后我们根据两个函数的函数值进行迭代求解即可。 12345678910111213141516171819202122232425262728293031323334353637383940from math import *#设置数据集m=7alpha=0.000000001#步长，即每次迭代距离area=[150,200,250,300,350,400,600]price=[6450,7450,8450,9450,11450,15450,18450]#初始值，可在合理范围内任意选，迭代次数足够多后对结果没有太大影响，建议选在数据集中的值Theta0=150Theta1=6450#求Theta0的偏导，即斜率def get_theta0(Theta0,Theta1): ans=0 for i in range(0,m): ans=ans+(Theta0+Theta1*area[i]-price[i]) return ans/m#求Theta1的偏导，即斜率def get_Theta1(Theta0,Theta1): ans=0 for i in range(0,m): ans=ans+(Theta0+Theta1*area[i]-price[i])*area[i] return ans/m;#nxt_Theta0,nxt_Theta1分别表示当前的Theta0,Theta1下一步的位置#alpha * get_theta() 步长*斜率=函数值变化的多少nxt_Theta0 = Theta0 - alpha * get_theta0(Theta0,Theta1)nxt_Theta1 = Theta1 - alpha * get_Theta1(Theta0,Theta1)#如果当前位置到下一个位置函数值差距小于给定值，则退出迭代while fabs(Theta1-nxt_Theta1)&gt;=0.000000001 : Theta0 = nxt_Theta0 Theta1 = nxt_Theta1 a = Theta0 - alpha * get_theta0(nxt_Theta0,nxt_Theta1) b = Theta1 - alpha * get_Theta1(nxt_Theta0,nxt_Theta1) nxt_Theta0 = a nxt_Theta1 = bprint(Theta0,Theta1) 运行结果为： 1133.20781607232527 33.07613925785978 接下来画图验证结果： 12345678910111213141516from numpy import *from matplotlib import pyplotfrom matplotlib.pyplot import *area=[150,200,250,300,350,400,600]price=[6450,7450,8450,9450,11450,15450,18450]scatter(area,price) #画出点阵图x=arange(100,700,100) #设置范围和步长y=133.20781607232527 + 33.07613925785978 * xplot(x,y)xlabel('area')ylabel('price')show() 图像为： 结果与实际情况与和很好，可认为求出近似函数。]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配]]></title>
    <url>%2F2019%2F05%2F16%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。（源于百度百科） 通俗来讲，有一堆人（图中的点），每个人都有一定的人际关系（图中的边），你需要使他们和他们的朋友两两组队，每个人只能在一个队伍。这就是二分图匹配。 极大匹配(Maximal Matching)是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。 最大匹配(maximum matching)是所有极大匹配当中边数最大的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。 一般问题都是求解二分图最大匹配问题。求解最大匹配最常用的算法为匈牙利算法。 匈牙利算法匈牙利算法 这是网上最好的一篇关于匈牙利算法的文章，我不能写的比他更好了。 匈牙利算法代码量并不多，记忆起来也不复杂，在做题时遇到最主要的问题就是建图。如何将问题转化成简单的二分图匹配问题，是最需要解决的。 建图接下来直接看一个比较复杂的二分图问题： poj3020 这个题大致意思就是一个天线可以覆盖本身以及相邻四个方向其中一个，问最少需要多少个天线才能覆盖所有点。 建图思路（懒得码字了→_→）。]]></content>
      <categories>
        <category>匈牙利算法</category>
      </categories>
      <tags>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan算法]]></title>
    <url>%2F2019%2F05%2F12%2FTarjan%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Tarjan算法是用来求强连通的一种算法。在学习算法之前，我们需要了解强连通的概念。 强联通： ​ 在一张有向图中，对于任意两个点v1,v2,存在从v1-&gt;v2 和v2-&gt;v1 的路径，则称这张图为强连通图。 强联通子图： ​ 在一张有向图中，存在一张子图是强连通图，则称这个子图为强连通子图，其极大强连通子图称之为强连通分量。 Tarjan的作用就是求强连通分量。 在遍历之前，我们需要建立一个栈来统计当前未被处理的节点。 对于下图： 我们从节点1开始dfs遍历，其中DFN表示遍历的编号，LOW表示连通块中最小的遍历的编号： （此时栈中元素为：1 2 3 6） 遍历到节点6后，开始回溯，此时判断DFN是否等于LOW，如果相等，那么这是强连通分量上的一个点： （此时栈中元素为：1 2 3） 回溯到节点3时，没有其他路可走，那么就判断DFN是否等于LOW，同时更新LOW[ 3 ]的值： （此时栈中元素为：1 2） 接下来从节点2向下遍历： （此时栈中元素为：1 2 5） 由于5 -&gt; 1 中节点1已经访问过了，那么此时我们更新LOW[ 5 ] = LOW[ 1 ] = 1,然后回溯更新LOW[2]=LOW[ 1 ]： （此时栈中元素为：1 2 5） 回溯到节点1，向下搜节点4，节点5被访问过，回溯LOW[ 4 ]=LOW[ 5 ] = 1 ： （此时栈中元素：1 2 5 4） 继续回溯到节点1，此时节点1相邻边已被访问完毕，判断DFN是否等于LOW，相等就开始标记强连通分量。将栈中元素LOW相等的全部连通。 完毕。 模板为： 123456789101112131415161718192021222324252627282930313233343536373839404142int n,m,tt,cnt,sig;int vis[maxn],low[maxn],dfn[maxn];int color[maxn];//color[]为染色，即强连通中的元素染成同一种颜色。stack&lt;int&gt;st;vector&lt;int&gt;vec[maxn];void init()&#123; memset(vis,0,sizeof(vis)); memset(low,0,sizeof(low)); memset(dfn,0,sizeof(dfn)); memset(color,0,sizeof(color)); for(int i=1;i&lt;=n;i++) vec[i].clear(); while(!st.empty()) st.pop();&#125;void tarjan(int x)&#123; vis[x]=1; dfn[x]=low[x]=cnt++; st.push(x); for(int i=0;i&lt;vec[x].size();i++)&#123; int y=vec[x][i]; if(vis[y]==0) tarjan(y);//未被访问过，向下遍历 if(vis[y]==1) low[x]=min(low[x],low[y]);//更新LOW下标 &#125; if(low[x]==dfn[x])&#123; sig++;//染色序号 int flag=0; while(!flag)&#123;//将栈中x及其以后的节点全部标记为同一种颜色（sig） int t=st.top(); st.pop(); if(t==x) flag=1; color[t]=sig; vis[t]=-1; &#125; &#125;&#125;void solve()&#123; tt=-1;cnt=1;sig=0; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]==0) tarjan(i); &#125; /* 此处添加其他操作 */&#125;]]></content>
      <categories>
        <category>Tarjan</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最短编辑距离]]></title>
    <url>%2F2019%2F05%2F09%2F%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。 例如两个字符串 “main” 和 “mian”，从前一个字符串变成后一个串，需要先删除一个字符 ‘ a ’ ,然后再在字符 ‘ i ‘ 后面加一个 ‘ a ‘ ,那么他们的最短编辑距离就为2。 求解这类问题的方法一般为动态规划。 不加权最短编辑距离这是最基本的裸题，只求字符串操作次数。 假设当前第一个串位置为 i ,第二个串位置为 j ，dp[ i ][ j ] 表示最短编辑距离。 我们看一下三种操作：替换，插入，删除 替换： ​ 如果仅仅是替换，假设我们已经求出来了 dp[ i - 1 ][ j - 1 ] , 那么从dp[ i - 1 ][ j - 1 ] 到 dp[ i ][ j ] $只操作了一次，即 dp[ i ][ j ] = dp[ i - 1 ][ j - 1 ] +1 。 插入： ​ 如果插入后串的长度分别为 i , j ,那么当前状态可以是从 i - 1 , j 的情况下第一个串插入一个字符得到的，因此 dp[ i ][ j ]= dp[ i - 1 ][ j ] + 1 ； 删除： ​ 删除同上，当前状态可以是从 i , j - 1 的情况下删除了一个字符得到的，因此dp[ i ][ j ]= dp[ i ][ j - 1 ] + 1 ； 这就是三种状态分别对应的状态方程，特殊的，当 i = 0 或 j = 0 时，最短编辑距离就是当前两个串的差值，即另一个变量对应的值。 代码如下： 123456789101112//字符串数组下标从1开始//初始化i=0或j=0的情况。for(int i=0;i&lt;=n;i++) dp[i][0]=i;for(int j=0;j&lt;=m;j++) dp[0][j]=j;//四种状态 按顺序为：删除，插入，字符匹配（不需要编辑），替换for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; dp[i][j]=min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+(a[i]==b[j]?0:1)); &#125;&#125; 加权最短编辑距离省赛原题： 多组输入 第一行输入四个数 a,b,c,d,表示字符匹配加 a 分，替换减b分，插入减c分，删除减d分。 接下来两行，每行一个字符串。 输出最大得分。 这个题其实也算是编辑距离的裸题，当时状态方程写了出来，但是不知道为什么wa了（可能还是不熟悉）。 加权的转移方程其实和不加权的差不多，只是在转移方程的加减上做了一点变化。 代码如下： 123456789//由于对应的权值不同，初始化的值也不同for(int i=0;i&lt;=n;i++) dp[i][0]=-i*d;for(int j=0;j&lt;=m;j++) dp[0][j]=-j*c;for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; dp[i][j]=max(max(dp[i-1][j]-c,dp[i][j-1]-d),dp[i-1][j-1]+(s1[i]==s2[j]?a:-b)); &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板库（持续更新）]]></title>
    <url>%2F2019%2F05%2F05%2F%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[整理一下我学过的部分算法模板。 AC自动机HDU2222 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000+10;int trie[maxn][26];//trie树 每个节点对应一个数字 int cntword[maxn];//统计每个节点为单词终点的个数 int fail[maxn];//fail指针 char s[maxn];int cnt;void init()&#123; memset(trie,0,sizeof(trie)); memset(cntword,0,sizeof(cntword)); memset(fail,0,sizeof(fail)); cnt=0;&#125;void insert(char* s)&#123; int len=strlen(s); int root=0; for(int i=0;i&lt;len;i++)&#123; if(!trie[root][s[i]-'a']) trie[root][s[i]-'a']=++cnt; root=trie[root][s[i]-'a']; &#125; cntword[root]++;&#125;void getfail()&#123; queue&lt;int&gt;que; for(int i=0;i&lt;26;i++)&#123; if(trie[0][i]) que.push(trie[0][i]); &#125; while(!que.empty())&#123; int now=que.front(); que.pop(); for(int i=0;i&lt;26;i++)&#123; if(trie[now][i])&#123; fail[trie[now][i]]=trie[fail[now]][i]; que.push(trie[now][i]); &#125; else&#123; trie[now][i]=trie[fail[now]][i]; &#125; &#125; &#125;&#125;int query(char *s)&#123; int len=strlen(s); int res=0,now=0; for(int i=0;i&lt;len;i++)&#123; now=trie[now][s[i]-'a']; for(int j=now;j &amp;&amp; cntword[j]!=-1;j=fail[j])&#123; res+=cntword[j]; cntword[j]=-1; &#125; &#125; return res;&#125;int main()&#123; int t,n; scanf("%d",&amp;t); while(t--)&#123; init(); scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%s",s); insert(s); &#125; cnt=0; getfail(); scanf("%s",s); printf("%d\n",query(s)); &#125; return 0;&#125; 并查集123456789101112void init()&#123; for(int i=1;i&lt;=n;i++) pre[i]=i;&#125;int find(int x)&#123; return x==pre[x]?x:pre[x]=find(pre[x]);&#125;void Union(int x,int y)&#123; x=find(x); y=find(y); if(x&lt;y) pre[y]=x; else pre[x]=y;&#125; GCD123int gcd(int x,int y)&#123; return y?gcd(y,x%y):x;&#125; 康托展开123456789101112131415161718192021222324252627282930void cantor()&#123; ll sum=1,fac=1; for(int i=n-1;i&gt;0;i--)&#123; fac*=(n-i); for(int j=i+1;j&lt;=n;j++)&#123; if(a[i]&gt;a[j]) sum+=fac; &#125; &#125; printf("%lld\n",sum);&#125;void inverse_cantor()&#123; ll fac=1,num; k--; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;n;i++) fac*=i; for(int i=1;i&lt;=n;i++)&#123; num=k/fac; k%=fac; if(n-i) fac/=(n-i); for(int j=1;j&lt;=n;j++)&#123; if(num==0 &amp;&amp; !vis[j])&#123; printf("%d ",j); vis[j]=1; break; &#125; if(!vis[j]) num--; &#125; &#125; printf("\n");&#125; KM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int love[maxn][maxn];int exgirl[maxn],exboy[maxn];bool visgirl[maxn],visboy[maxn];int match[maxn],slack[maxn];int n,m;bool dfs(int x)&#123; visgirl[x]=true; for(int i=0;i&lt;n;i++)&#123; if(!visboy[i])&#123; int gap=exgirl[x]+exboy[i]-love[x][i]; if(gap==0)&#123; visboy[i]=true; if(match[i]==-1 || dfs(match[i]))&#123; match[i]=x; return true; &#125; &#125; else&#123; slack[i]=min(slack[i],gap); &#125; &#125; &#125; return false;&#125;int km()&#123; memset(match,-1,sizeof(match)); memset(exboy,0,sizeof(exboy)); for(int i=0;i&lt;n;i++)&#123; exgirl[i]=love[i][0]; for(int j=1;j&lt;n;j++)&#123; exgirl[i]=max(exgirl[i],love[i][j]); &#125; &#125; for(int i=0;i&lt;n;i++)&#123; fill(slack,slack+n,INF); while(true)&#123; memset(visgirl,false,sizeof(visgirl)); memset(visboy,false,sizeof(visboy)); if(dfs(i)) break; int d=INF; for(int i=0;i&lt;n;i++)&#123; if(!visboy[i]) d=min(d,slack[i]); &#125; for(int i=0;i&lt;n;i++)&#123; if(visgirl[i]) exgirl[i]-=d; if(visboy[i]) exboy[i]+=d; else slack[i]-=d; &#125; &#125; &#125; int res=0; for(int i=0;i&lt;n;i++)&#123; res+=love[match[i]][i]; &#125; return res;&#125; KMP12345678910111213void get_nxt()&#123; int i=1,next[1]=0,j=0; int len=strlen(str); while(i&lt;len)&#123; if(j==0 || str[i]==str[j])&#123; i++; j++; next[i]=j; &#125; else j=next[i]; &#125;&#125; Tarjan1234567891011121314151617181920212223242526272829303132333435363738int n,m,tt,cnt,sig;int vis[maxn],low[maxn],dfn[maxn];int color[maxn],st[maxn];vector&lt;int&gt;vec[maxn];void init()&#123; memset(vis,0,sizeof(vis)); memset(low,0,sizeof(low)); memset(dfn,0,sizeof(dfn)); memset(color,0,sizeof(color)); memset(st,0,sizeof(st)); for(int i=1;i&lt;=n;i++) vec[i].clear();&#125;void tarjan(int x)&#123; vis[x]=1; dfn[x]=low[x]=cnt++; st.push(x); for(int i=0;i&lt;vec[x].size();i++)&#123; int y=vec[x][i]; if(vis[y]==0) tarjan(y); if(vis[y]==1) low[x]=min(low[x],low[y]); &#125; if(low[x]==dfn[x])&#123; sig++; do&#123; color[st[tt]]=sig; vis[st[tt]]=-1; &#125;while(st[tt--]!=x); &#125;&#125;void solve()&#123; tt=-1;cnt=1;sig=0; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]==0) tarjan(i); &#125; /* 此处添加其他操作 */&#125; 凸包1234567891011121314151617181920212223242526272829303132struct node&#123; int x,y; int pos;&#125;p[maxn],q[maxn];int n,l;node getmag(node a,node b)&#123; node s; s.x=b.x-a.x; s.y=b.y-a.y; return s;&#125;int multiX(node a,node b)&#123; return a.x*b.y-a.y*b.x;&#125;bool cmp(node a,node b)&#123; return multiX(getmag(p[1],a),getmag(p[1],b))&gt;0;&#125;void graham()&#123; int id=1; for(int i=2;i&lt;=n;i++)&#123; if(p[i].x&lt;p[id].x || (p[i].x==p[id].x &amp;&amp; p[i].y&lt;p[id].y)) id=i; &#125; if(id!=1) swap(p[id],p[1]); sort(p+2,p+n+1,cmp); q[++l]=p[1]; for(int i=2;i&lt;=n;i++)&#123; while(l&gt;=2 &amp;&amp; multiX(getmag(q[l-1],p[i]),getmag(q[l-1],q[l]))&gt;=0) l--; q[++l]=p[i]; &#125;&#125; 线段树线段树单点更新+查询区间最大值HDU1754 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1000000;int dat[maxn],n;int m,a,b;char op;void init(int x)&#123; n=1; while(n&lt;x) n*=2; for(int i=0;i&lt;n*2-1;i++)&#123; dat[i]=0; &#125;&#125;void update(int k,int a)&#123; k+=n-1; dat[k]=a; while(k&gt;0)&#123; k=(k-1)/2; dat[k]=max(dat[k*2+1],dat[k*2+2]); &#125;&#125;int query(int a,int b,int k,int l,int r)&#123; if(r&lt;a || b&lt;l) return 0; if(a&lt;=l &amp;&amp; r&lt;=b) return dat[k]; else&#123; int vl=query(a,b,k*2+1,l,(l+r)/2); int vr=query(a,b,k*2+2,(l+r)/2+1,r); return max(vl,vr); &#125;&#125;int main()&#123; int n_; while(~scanf("%d %d",&amp;n,&amp;m))&#123; n_=n; init(n); for(int i=0;i&lt;n_;i++)&#123; scanf("%d",&amp;dat[i+n-1]); update(i,dat[i+n-1]); &#125; getchar(); while(m--)&#123; scanf("%c %d %d",&amp;op,&amp;a,&amp;b); getchar(); if(op=='Q') printf("%d\n",query(a-1,b-1,0,0,n-1)); else if(op=='U') update(a-1,b); &#125; &#125; return 0;&#125; 线段树区间更新FZU1608 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1000000;int n,m,dat[maxn];void init(int x)&#123; n=1; while(n&lt;x) n*=2; for(int i=0;i&lt;n*2-1;i++)&#123; dat[i]=0; &#125;&#125;void update(int a,int b,int x,int k,int l,int r)&#123; if(b&lt;l || r&lt;a) return ; if(a&lt;=l &amp;&amp; r&lt;=b) dat[k]=max(x,dat[k]); else&#123; update(a,b,x,k*2+1,l,(l+r)/2); update(a,b,x,k*2+2,(l+r)/2+1,r); &#125;&#125;int query(int l,int r,int k,int mmax)&#123; if(l==r) return max(mmax,dat[k]); dat[k]=max(mmax,dat[k]); int vl=query(l,(l+r)/2,k*2+1,dat[k]); int vr=query((l+r)/2+1,r,k*2+2,dat[k]); return vl+vr;&#125;int main()&#123; int a,b,x; while(~scanf("%d %d",&amp;n,&amp;m))&#123; init(n); for(int i=0;i&lt;m;i++)&#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;x); update(a,b-1,x,0,0,n-1); &#125; printf("%d\n",query(0,n-1,0,0)); &#125; return 0;&#125; 线段树区间更新+区间求和POJ3468 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define ll long longconst ll maxn=1000000;ll dat[maxn],sum[maxn],n,m;void update(ll a,ll b,ll x,ll k,ll l,ll r)&#123; if(a&lt;=l &amp;&amp; r&lt;=b)&#123; dat[k]+=x; &#125; else if(l&lt;=b &amp;&amp; a&lt;=r)&#123; sum[k]+=(min(b,r)-max(a,l)+1)*x; update(a,b,x,k*2+1,l,(l+r)/2); update(a,b,x,k*2+2,(l+r)/2+1,r); &#125;&#125;ll query(ll a,ll b,ll k,ll l,ll r)&#123; if(b&lt;l || r&lt;a) return 0; else if(a&lt;=l &amp;&amp; r&lt;=b) return dat[k]*(r-l+1)+sum[k]; else&#123; ll res=(min(b,r)-max(a,l)+1)*dat[k]; res+=query(a,b,k*2+1,l,(l+r)/2); res+=query(a,b,k*2+2,(l+r)/2+1,r); return res; &#125;&#125;int main()&#123; ll a,b,x; char op; scanf("%lld %lld",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;x); update(i,i,x,0,0,n-1); &#125; getchar(); while(m--)&#123; scanf("%c",&amp;op); if(op=='Q')&#123; scanf("%lld %lld",&amp;a,&amp;b); printf("%lld\n",query(a-1,b-1,0,0,n-1)); &#125; else&#123; scanf("%lld %lld %lld",&amp;a,&amp;b,&amp;x); update(a-1,b-1,x,0,0,n-1); &#125; getchar(); &#125; return 0;&#125; 线性基求交123456789101112131415161718void LinearBase(int v1,int v2,int res)&#123; int a[35],b[35]; for(int i=0;i&lt;32;i++) a[i]=b[i]=tree[v1][i]; for(int i=0;i&lt;32;i++)&#123; int q=tree[v2][i],t=0; if(!q) continue; int j=i; for(;j&gt;=0;j--)&#123; if(q&gt;&gt;j)&#123; if(!a[j]) break; q^=a[j]; t^=b[j]; &#125; &#125; if(!q) tree[res][i]=t; else a[j]=q,b[j]=t; &#125;&#125; 主席树静态主席树//查询区间第k小 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000+10;int rt[maxn],ls[maxn*2],rs[maxn*2],sum[maxn*2];int a[maxn],b[maxn];int tot,N,n,q;void build(int&amp; o,int l,int r)&#123; o=++tot; sum[o]=0; if(l==r) return ; int m=(l+r)/2; build(ls[o],l,m); build(rs[o],m+1,r);&#125;void update(int&amp; o,int l,int r,int last,int k)&#123; o=++tot; ls[o]=ls[last]; rs[o]=rs[last]; sum[o]=sum[last]+1; if(l==r) return ; int m=(l+r)/2; if(k&lt;=m) update(ls[o],l,m,ls[last],k); else update(rs[o],m+1,r,rs[last],k);&#125;int query(int s,int e,int l,int r,int k)&#123; if(l==r) return l; int cnt=sum[ls[e]]-sum[ls[s]]; int m=(l+r)/2; if(k&lt;=cnt) return query(ls[s],ls[e],l,m,k); else return query(rs[s],rs[e],m+1,r,k-cnt);&#125;int main()&#123; int t; int l,r,k; scanf("%d",&amp;t); while(t--)&#123; scanf("%d %d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; tot=0; sort(b+1,b+n+1); N=unique(b+1,b+n+1)-(b+1); build(rt[0],1,N); for(int i=1;i&lt;=n;i++) update(rt[i],1,N,rt[i-1],lower_bound(b+1,b+N+1,a[i])-b); while(q--)&#123; scanf("%d %d %d",&amp;l,&amp;r,&amp;k); int ans=query(rt[l-1],rt[r],1,N,k); printf("%d\n",b[ans]); &#125; &#125; return 0;&#125; 动态主席树//修改单点+查询区间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=60000+10;int a[maxn],hash[maxn];int rt[maxn],RT[maxn],ls[maxn*32],rs[maxn*32],sum[maxn*32];int ul[maxn],ur[maxn]; int tot,n,q,N;struct node&#123; int l,r,k; bool flag;&#125;op[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void build(int&amp; o,int l,int r)&#123; o=++tot; sum[o]=0; if(l==r) return; int m=(l+r)/2; build(ls[o],l,m); build(rs[o],m+1,r);&#125;void update(int&amp; o,int l,int r,int last,int p,int val)&#123; o=++tot; ls[o]=ls[last]; rs[o]=rs[last]; sum[o]=sum[last]+val; if(l==r) return ; int m=(l+r)/2; if(p&lt;=m) update(ls[o],l,m,ls[last],p,val); else update(rs[o],m+1,r,rs[last],p,val);&#125;void add(int x,int val)&#123; int res=lower_bound(hash+1,hash+N+1,a[x])-hash; while(x&lt;=n)&#123; update(RT[x],1,N,RT[x],res,val); x+=lowbit(x); &#125;&#125;int Sum(int x,bool flag)&#123; int res=0; while(x)&#123; if(flag) res+=sum[ls[ur[x]]]; else res+=sum[ls[ul[x]]]; x-=lowbit(x); &#125; return res;&#125;int query(int s,int e,int ts,int te,int l,int r,int k)&#123; if(l==r) return l; int m=(l+r)/2; int cnt=Sum(e,true)-Sum(s,false)+sum[ls[te]]-sum[ls[ts]]; if(k&lt;=cnt)&#123; for(int i=e;i;i-=lowbit(i)) ur[i]=ls[ur[i]]; for(int i=s;i;i-=lowbit(i)) ul[i]=ls[ul[i]]; return query(s,e,ls[ts],ls[te],l,m,k); &#125; else&#123; for(int i=e;i;i-=lowbit(i)) ur[i]=rs[ur[i]]; for(int i=s;i;i-=lowbit(i)) ul[i]=rs[ul[i]]; return query(s,e,rs[ts],rs[te],m+1,r,k-cnt); &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d %d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); hash[i]=a[i]; &#125; char str[2]; N=n; for(int i=1;i&lt;=q;i++)&#123; scanf("%s",str); if(str[0]=='Q')&#123; scanf("%d %d %d",&amp;op[i].l,&amp;op[i].r,&amp;op[i].k); op[i].flag=true; &#125; else&#123; scanf("%d %d",&amp;op[i].r,&amp;op[i].k); op[i].flag=false; hash[++N]=op[i].k; &#125; &#125; sort(hash+1,hash+N+1); N=unique(hash+1,hash+N+1)-(hash+1); tot=0; build(rt[0],1,N); for(int i=1;i&lt;=n;i++) update(rt[i],1,N,rt[i-1],lower_bound(hash+1,hash+N+1,a[i])-hash,1); for(int i=1;i&lt;=n;i++) RT[i]=rt[0]; for(int i=1;i&lt;=q;i++)&#123; int l=op[i].l,r=op[i].r,k=op[i].k; if(op[i].flag)&#123; for(int j=r;j;j-=lowbit(j)) ur[j]=RT[j]; for(int j=l-1;j;j-=lowbit(j)) ul[j]=RT[j]; int res=query(l-1,r,rt[l-1],rt[r],1,N,k); printf("%d\n",hash[res]); &#125; else&#123; add(r,-1); a[r]=k; add(r,1); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[凸包]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[凸包 凸包（Convex Hull）是一个计算几何（图形学）中的概念。在一个实数向量空间V中，对于给定集合X，所有包含X的凸集的交集S被称为X的凸包。X的凸包可以用X内所有点(X1，…Xn)的凸组合来构造.在二维欧几里得空间中，凸包可想象为一条刚好包著所有点的橡皮圈。用不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边形，它能包含点集中所有的点。（来源于百度百科） 凸包是计算几何题目中经常出现的概念，一般形式为给你 $ n $ 个点，求这些点所构成的凸包的面积。 这张动图是求凸包的过程。 求凸包的基本顺序为： 找到凸包上的一个点，一般为x坐标最小的点。 将找到的点设为原点，根据极角排序方式将剩余的点进行排序 循环找凸包上的点 如果当前点比上一个点更可能是凸包上的点，那么就覆盖上一个点，更新为当前点。 如果当前点没有上一个点适合当凸包上的点，那么就先放进凸包集合中，继续寻找下一个点。 循环结束。 关于当前点是否更有可能是凸包上的点，用下面的几张图来讲解： 当前凸包内有三个点v0,v1,v2，接下来判断v3的时候，我们需要对它进行判断： $v1$ 与 $v2,v3$ 相连，判断两条线的夹角的方向，如果是逆时针方向，那么就可以放入凸包集合中: 接下来同样的办法判断v4: 如果是顺时针方向，那么 $v4$ 就优于 $v3$ ，我们删去 $v3$ ，接下来继续判断： 逆时针，所以可以放入图包集合： 之后一直重复这个过程即可。 代码如下： 1234567891011121314151617181920212223242526272829303132struct node&#123; int x,y; int pos;&#125;p[maxn],q[maxn];int n,l;node getmag(node a,node b)&#123;//计算边 表示从a-&gt;b的向量 node s; s.x=b.x-a.x; s.y=b.y-a.y; return s;&#125;int multiX(node a,node b)&#123;//叉乘的正负代表两条直线夹角的顺逆 return a.x*b.y-a.y*b.x;&#125;bool cmp(node a,node b)&#123;//根据极角排序 return multiX(getmag(p[1],a),getmag(p[1],b))&gt;0;&#125;void graham()&#123; int id=1; for(int i=2;i&lt;=n;i++)&#123;//找出最开始的一个点 if(p[i].x&lt;p[id].x || (p[i].x==p[id].x &amp;&amp; p[i].y&lt;p[id].y)) id=i; &#125; if(id!=1) swap(p[id],p[1]); sort(p+2,p+n+1,cmp);//极角排序 q[++l]=p[1];//p: 所有点集合 q: 凸包点集合 for(int i=2;i&lt;=n;i++)&#123; //如果夹角是顺时针方向，那么就可以取代 while(l&gt;=2 &amp;&amp; multiX(getmag(q[l-1],p[i]),getmag(q[l-1],q[l]))&gt;=0) l--; q[++l]=p[i]; &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2019%2F04%2F16%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[树状数组在数据结构上和线段树类似，功能上均用来求解区间的修改，查询，计数等问题。 树状数组树状数组的突出优点为代码简洁，相比于线段树，其修改、查询函数均非常简短。 线段树的数据结构为： 将线段树数组的位置进行改变就得到了树状数组：]]></content>
      <categories>
        <category>树状数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nim博弈--简单证明]]></title>
    <url>%2F2019%2F04%2F15%2FNim%E5%8D%9A%E5%BC%88-%E7%AE%80%E5%8D%95%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Nim博弈是ACM入门的博弈之一，其基本描述为： 有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。 这游戏看上去有点复杂，先从简单情况开始研究吧。如果轮到你的时候，只剩下一堆石子，那么此时的必胜策略肯定是把这堆石子全部拿完一颗也不给对手剩，然后对手就输了。如果剩下两堆不相等的石子，必胜策略是通过取多的一堆的石子将两堆石子变得相等，以后如果对手在某一堆里拿若干颗，你就可以在另一堆中拿同样多的颗数，直至胜利。如果你面对的是两堆相等的石子，那么此时你是没有任何必胜策略的，反而对手可以遵循上面的策略保证必胜。如果是三堆石子……好像已经很难分析了，看来我们必须要借助一些其它好用的（最好是程式化的）分析方法了，或者说，我们最好能够设计出一种在有必胜策略时就能找到必胜策略的算法。（源自百度百科） 如果有点基础的同学就会知道Nim博弈的判断胜负的办法： 将每堆石子个数异或，如果异或结果非零，则先手必胜，否则先手必败。 我们先对必败局面，即最终异或结果为 $0​$ （假设异或结果为 $A​$）进行分析： 如果现在第一个人拿任意一堆石子中的 $B​$ 个，那么现在剩余石子的异或结果 $A’​$必定不为 $0​$ ，而且可以看出$A’=B​$。 接下来是第二个人的操作。在二进制的情况下，$A’$ 的位数和 $B$ 的位数相同（假定为 $n+1$位），即剩余的所有石子中必定有一堆石子的数量（假定为 $C$ ）不少于 $2^n$ 个，且二进制下第 $n$ 位必定为 1 。假如我们拿出这一堆石子中的 $2 ^ n$ 个，现在剩下的所有石子异或结果 $A’’$ 一定小于 $2 ^ n$ ($A’’$ 第 $n$ 位此时变成了 $0$ ) ，所以我们可以从这 $C$ 个石子中拿走 $2^n-A’’$ 个，剩余 $A’’$ 个，这样，剩余的石子异或的结果一定为 $A’’$ ^ $A’’ $ $=0$ 。这样，第二个人就能在一次操作后将异或的结果变为 $0$ 。 第二个人持续上述操作，就能够使第一个人当前的异或结果永远为 $0​$ ，第二个人当前的异或结果永远不为 $0​$ ，而最终当取完所有石子时，结果也为 $0​$ 。 假如初始 $A​$ 不为零，那么第一个人也可通过上述操作使得异或结果为 $0​$ 。 这样就证明了异或结果可以判断最终胜负的正确性。 （持续更新……）]]></content>
      <categories>
        <category>博弈</category>
      </categories>
      <tags>
        <tag>Nim博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的CCPC河南省赛一日游]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%8F%9C%E9%B8%A1%E7%9A%84CCPC%E6%B2%B3%E5%8D%97%E7%9C%81%E8%B5%9B%E4%B8%80%E6%97%A5%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[希望下回有个好成绩。 公元2019年4月13日。 清晨一如既往地冷，校园内三三两两的学生在路上悠闲地走着。餐厅内工作人员已经在这个放假的日子早早的起床做饭。 餐厅中央侧边的两张餐桌旁，坐着我们学校早起的参赛选手们。在体育节放假的这两天，两回训练赛早就冲淡了我们比赛的紧张感。我们坐在这里，吃着饭，聊着即将到来的CCPC省赛。 餐厅外，象征着青春活力的太阳已经爬上了天空。 吃完饭后，我们出了餐厅，就朝着东门的方向走去，7:50我们将准时出发去郑州轻工业大学。 这次比赛学校多了不少新的队员，都是在之前的三次积分赛上选拔出来的优秀选手。其中还包括两只大一的队伍，他们很努力；他们也很幸运，能够在大一就有机会去参加省赛。还有一只留学生的队伍，他们是教练的学生，对算法有着和我们一样的兴趣，但是我们一行人只有会长能够和他们谈笑风生，我这个连四级都没有过的人只能在旁边看着他们聊天。 这次比赛由于教练有事，所以我们教练又找了一个带队老师。这位老师在我们的校赛方面也提供很大的帮助。很年轻的一位老师，性格也很好，和我们的教练一样好。 清点完人数，我们就踏上了去打比赛的征途。又是熟悉的大巴，和蓝桥杯、天梯赛的大巴一样，坐满了我们心情忐忑的一行人。去年我们的学长在ICPC省赛中拿到了非常优异的成绩，作为学校大二的顶尖力量（其实也不过如此），我们队的压力–主要是我的压力–也是非常的大，想拿个更好的成绩去向学长们报汇报。学长为了培养我们，牺牲了自己的课余时间，给我们开公开课，开集训，我也不想在这样一个比赛中拿到并不是非常优异的成绩去报答学长们的付出。 今天的阳光很好。前几天天阴着，刮着冷风，像是又一季的冬天。 由于学校行程的安排，我们在到达轻大的时候开幕式已经开始了。报完到后，我们又在外面逛了许久，轻大看起来还是那么广阔，在清晨阳光的照射下，图书馆前的广场看起来有了别样的感觉。不久，我们就前往了考场。 到达机房门口，我们看到了比赛的环境，win10系统，电脑也和上回来的时候不一样了，看来是主办方为了省赛确实花了很大力气。 由于没有参加开幕式，到达机房时间有点早，我们几个队伍也在机房外面闲谈了起来，免不了的一波毒奶。 进入机房后，惊奇的发现键盘也换了，上次打天梯赛的键盘是老式的键盘，按起来也非常的费力。这一次的换了一种薄膜键盘，虽然用起来并没有机械键盘那么舒服，但是相比之前的还是好了很多。 在距比赛开始前几分钟，我和我队友就发现现场好像并没有纸质题面。询问了一下考场的老师，老师也说去问一下。果然没多久，就传来了比赛推迟的消息。十分钟后，又传来了比赛推迟的消息。10:20，比赛正式开始了。 由于刚开始我们以为会发三个纸质题面，但是发下来之后发现只有一个，有点大乱了我们的阵脚，dicer提议把题面撕成两份，我和codancer一人看半份，dicer看电脑。当我看了第一题我的脑子里只剩下了“？？？？？？？？”，这…应该不是签到题吧。于是我又看了B，这…应该也不是签到题吧。当我在看B的时候，dicer看了一下榜，说 D E 好像是签到题，我看了一下，确实是签到题，然后dicer就迅速的敲起了键盘，两个签到题花了8分钟写完了。 之后过了好久，没人再开出来其他题了。由于我拿的是前半部分，所以一直在看ABC，差点看自闭了，图论是我的弱项，然而BC全是树形结构，然后我就GG了。签到题写完后，dicer看了 A ，感觉可写，就给codancer说了一下，于是他们就开始全心攻A题，我觉得BC我不可写，就让codancer把另一半题面给了我，我看了 F，发现是个数学题，这就很不错了嘛。刚开始看懂题意，那不就是直接模拟吗，dicer看了题，提醒我说数据范围1e18,然后我又陷入了自闭之中，之后我就开始了漫长的化简之旅。 在纸上算了一会后，我发现符合条件的区间可以被分为不连续和连续两部分，然后我就开始继续慢慢计算每个小区间怎么处理，然后想了一个极其复杂的处理方法。我正在疯狂想办法化简的时候，dicer 和 codancer 经过激烈的讨论以及盲猜了一发结论WA了之后，看出来 A 是dp，于是把代码全盘来写。我在化简的时候发现可以先计算出小区间的范围，然后根据l r 值进行判断，激动了一下，但是看他们还在写 A ，我就决定先把代码写在纸上，看看能不能行的通，不一会，他们俩就又交了一发 A ，WA了，然后我问 A 题怎么样了，他们说害还得再找找思路有没有问题，我就说让我先敲 F 题吧，然后他们就在旁边讨论找反例来了。 我根据我的思路，很快写好了 F 题，但是测样例的时候四个就过了一个，我思考起是不是哪里写错了，就看着代码一步步的进行计算，他们在讨论了一阵之后，发现了问题在哪，然后又开始修改他们的代码，我就在旁边看我的思路是不是哪错了，之后没一会，他们又交了一发 A ，过了！然后看榜单，发现排名前几，但是罚时有点多，三题垫底。 我又开始了我的改bug之旅，他们又在旁边讨论起了 C 题，我对着样例又计算了一遍，才发现区间是左闭右开的，赶紧改bug，测样例，过了！提交，过了！ 我问他们 C 题怎么样了，他们说稍微有点思路，但是复杂度太大，我看了看题，发现复杂度确实有点高。看了一眼榜单，发现开出来的这几个都差不多了，于是想着再开一个新题，我看了 H 还是图论，但是看着好像没那么难（还是太年轻了）于是就开始看起了 H 题，他们俩觉得 C 题有点不可写之后，就决定开一道新的题出来。发现 I 是一个暴力的题目，我看了看题，感觉不可写，复杂度太大了。但是他们说省赛的复杂度不用管，全是玄学复杂度。争执了一会后，我就说让他们试试吧。反正现在也开不出来其他的题目了。于是我又看起了我的 H 题。 我在纸上算了一会后，发现还是有点复杂，情况太多了。想着既然没开出来，说不定就是因为太复杂了呢。然后就继续疯狂的枚举那么多的情况，最多的时候直接开了 7 8 个数组存变量，正在我怀疑人生的时候，他们开始了调试 I 题，我想着放松会大脑，就看着他们调试，也看看是不是有设么bug，过了一会，他们调试完了，随便测试了一下样例，输入样例，过了快一秒，答案才出来，我们直接被吓了一下，但是想着省赛都是玄学复杂度，就叫一下试试吧。提交，看着他那个圈圈一直在转，我觉得肯定要凉了，又过了好久，评测机返回了 AC ，欢呼了一下。看了一下榜单，排名第5，还是有点靠后，想着必须再做一题才能保证前三名吧。 此时还剩了两个小时。榜单上 C 和 H 都有人做了出来，我继续算我的 H ,他们看起了 C。我刚才看了一会 H 了，想着思路应该差不多了，就直接上机开始敲代码，但是敲到一半，发现越敲越难敲，思路好像越来越不对了， 手放在键盘上，但是就是不知道应该写些什么。他们为我写的咋样了，我说应该差不多了，然后他们继续看 C ，我继续写代码，最后是在写不下去了，我说你们来写写试试吧。 dicer开始敲代码，我把我的思路给他们说了一下。由于他们没怎么看这个题，这个题并没有看得太明白，所以对我的思路也没办法找反例。我就在旁边说我的思路，dicer在敲代码，实现我的每一步功能，敲了好久，他们问我是不是写完了，我想了一下，应该是没啥问题了，于是测样例，果然没过。看代码，发现少了两步功能，加上后，再继续测，样例过了。然后就直接交，不出所料，果然是 WA 了。由于现在只剩这一个可写题了，我们就集中精力做这个题，他们让我把思路再发给他们说一下，我说了之后，codancer问我如果第一个是父节点怎么办，我想了一下……悲伤！果然是个假算法！然后陷入了疯狂的自闭……算法是错的，只能推倒重来。 他们因为时间复杂度一直没写 C 题，但是现在已经没办法了，他们就决定试一下，我就在旁边一会看他们敲代码，一会想着如何解决 H 题，最后二十分钟左右，我又想出了一个算法，实现简单，而且还没啥大问题。他们看起来也打算放弃 C 题了，我就说让我在挣扎一下，他们同意了，于是他们在旁边看我敲起了代码，一直敲了十几分钟，最后几分钟，代码算是敲完了，测样例，没过…检查了一下，发现我手残把两个输出设置的一样。被嘲讽了一波后过了样例，此时还有三分钟，提交，焦急的的等待着评判结果，WA……，还有两分钟，再看了一下代码，有一个地方忘记写了，加上后，测样例，提交，又WA……此时剩下了最后一分钟，机房里面有人已经开始收拾起了行李，我还在看我的代码，但是最后还是没检查出来，不得不失落地走了。 赛后看群消息，发现金奖和一A有500奖金，然后又小激动了一下，继而又后悔起了差四分钟 1A 的 H 题，太亏了。 之前教练和我们说的是比赛完直接走，但是我们想参加颁奖典礼，于是和带队老师说了一下，老师也同意了。颁奖典礼现场，赞助方现场发现金！！！简直不要太阔气。拿了500，也算是有点收获。最后第九名，没达到预期的排名，心有不甘，接下来还有一场ICPC省赛，希望接下来一场比赛能好好打，争取不丢学长的脸。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017浙江省赛E题--Seven Segment Display（数位dp）]]></title>
    <url>%2F2019%2F04%2F12%2FSeven-Segment-Display%2F</url>
    <content type="text"><![CDATA[题目链接: Seven Segment Display 题意大致为: t 组数据 每组数据一个时间 n 和计数器当前显示时间 m（8位16进制数） ，求在n秒内（包括当前秒）每秒所出现的数字的权值和。 特别的是，当 m = FFFFFFFF 时，下一秒会变成 00000000。 每个数字的权值为： For example, in order to display the hexadecimal number “5A8BEF67” on the component for one second, 5 + 6 + 7 + 5 + 5 + 4 + 6 + 3 = 41 units of energy will be consumed. Sample Input 35 89ABCDEF3 FFFFFFFF7 00000000 Sample Output 208124327 一个比较复杂的数位dp，我们在数位dp的时候还需要记录一下每个数字被使用的个数。 dp[ i ][ j ]表示第 i 位为 j 时所需要加的权值。 由于还需要记录每个数被使用的次数，所以返回值需要有两个（权值和，使用次数）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll INF=0xffffffff;struct node&#123; ll value,times;&#125;;ll dp[10][20];ll bit[10];ll mp[20]=&#123;6,2,5,5,4,5,6,3,7,6,6,5,4,5,5,4,0&#125;;node dfs(ll pos,ll pre,bool limit)&#123; if(pos==0) return (node)&#123; mp[pre] , 1 &#125;; if(!limit &amp;&amp; dp[pos][pre]) return (node)&#123; dp[pos][pre] , 1&lt;&lt;(4*pos) &#125;;//使用次数 16^pos 次 ll cnt=0; ll times=0; node x; ll maxn=limit?bit[pos]:15; for(ll i=0;i&lt;=maxn;i++)&#123; x=dfs(pos-1,i,limit &amp;&amp; i==maxn); cnt+=x.value; times+=x.times; &#125; cnt+=mp[pre]*times;//权值*使用的次数 if(!limit) dp[pos][pre]=cnt; return (node)&#123; cnt , times &#125;;&#125;ll solve(ll x)&#123; if(x&lt;0) return 0; for(int i=1;i&lt;=8;i++)&#123;//由于0也有权值，所以必须计算八位 bit[i]=x%16; x/=16; &#125; node res=dfs(8,16,true); return res.value; &#125; int main()&#123; int t; ll n,m; ll res; scanf("%d",&amp;t); while(t--)&#123; scanf("%lld %X",&amp;n,&amp;m); if(n+m-1&gt;INF)&#123;//溢出 res=solve(INF)-solve(m-1); res+=solve(m+n-2-INF); &#125; else&#123; res=solve(n+m-1)-solve(m-1); &#125; printf("%lld\n",res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“高教社杯”第三届福建省大学生程序设计竞赛F题--华容道]]></title>
    <url>%2F2019%2F04%2F07%2F%E5%8D%8E%E5%AE%B9%E9%81%93%2F</url>
    <content type="text"><![CDATA[模拟界的泥石流。 差点就想要手算了。 题目描述： Cao Cao was hunted down by thousands of enemy soldiers when he escaped from Hua Rong Dao. Assuming Hua Rong Dao is a narrow aisle (one N*4 rectangle), while Cao Cao can be regarded as one 2*2 grid. Cross general can be regarded as one 1*2 grid.Vertical general can be regarded as one 2*1 grid. Soldiers can be regarded as one 1*1 grid. Now Hua Rong Dao is full of people, no grid is empty. There is only one Cao Cao. The number of Cross general, vertical general, and soldier is not fixed. How many ways can all the people stand? Input There is a single integer T (T≤4) in the first line of the test data indicating that there are T test cases. Then for each case, only one integer N (1≤N≤4) in a single line indicates the length of Hua Rong Dao. Output For each test case, print the number of ways all the people can stand in a single line. Sample Input 1234&gt; 2&gt; 1&gt; 2&gt; Sample Output 123&gt; 0&gt; 18&gt; 题目的大致意思就是：给你一个 n*4 的网格，你要找到所有的方案，使得在这个网格中有且仅有一个 2*2 大小的曹操，其他的网格任意放。 看到数据范围我就惊了，从没看过这么小的数据范围，然而当我写的时候才发现这是有多么的艰难…… 大致思路就是： 先固定曹操的位置。 枚举 1*2 和 2*1 的方块的个数。 固定 1*2 方块 固定 2*1 方块 全部完成后判断是否是已经出现过的排列方式，如果没出现过，那么累加；否则不累加。 代码写的我都有点不敢相信这是正确的… 由于写的着急，没有进行剪枝和其他优化操作，时间可能会耗费太多。但由于数据范围很小，所以在本地跑出来直接输出就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;map&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define ll long longll mp[10][10];int n,m;map&lt;ll,ll&gt;p;//标记出现过的放置情况 int sum=0;void output()&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; printf("%lld ",mp[i][j]); &#125; printf("\n"); &#125; printf("\n");&#125;int judge()&#123;//判断当前情况是否出现过 ll res=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; res=res*4+mp[i][j]; &#125; &#125; if(!p[res])&#123; p[res]++; sum++;// output(); return 1; &#125; else return 0;&#125;int val(int num,int maxv)&#123;//放完 1*2 的方块以后放 2*1 的方块 if(num==maxv) return judge(); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(!mp[i][j] &amp;&amp; !mp[i+1][j] &amp;&amp;i+1&lt;n)&#123; mp[i][j]=mp[i+1][j]=3; val(num+1,maxv); mp[i][j]=mp[i+1][j]=0; &#125; &#125; &#125;&#125;int cal(int num,int maxc,int maxv)&#123;//放 1*2 的方块 if(num==maxc)&#123; return val(0,maxv); &#125; int res=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(!mp[i][j] &amp;&amp; !mp[i][j+1] &amp;&amp; j+1&lt;m)&#123; mp[i][j]=mp[i][j+1]=2; int x=cal(num+1,maxc,maxv); if(x&lt;0) return x; res+=x; mp[i][j]=mp[i][j+1]=0; &#125; &#125; &#125; return res;&#125;int caocao(int x,int y)&#123;//枚举曹操的位置 if(x&gt;=n-1 || y&gt;=m-1) return 0; mp[x][y]=mp[x+1][y+1]=mp[x][y+1]=mp[x+1][y]=1; int res=0; for(int i=0;i&lt;=8;i++)&#123; for(int j=0;j&lt;=8;j++)&#123;//枚举 1*2 2*1 方块的个数。 int x=cal(0,i,j); if(x&lt;0) continue; res+=cal(0,i,j); &#125; &#125; mp[x][y]=mp[x+1][y+1]=mp[x][y+1]=mp[x+1][y]=0; return res;&#125;int main()&#123; m=4; int t; scanf("%d",&amp;t); while(t--)&#123; p.clear(); sum=0; scanf("%d",&amp;n); int res=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; caocao(i,j); &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“高教社杯”第三届福建省大学生程序设计竞赛H题--Mountain Number（数位dp）]]></title>
    <url>%2F2019%2F04%2F07%2FMountain-Number-%E6%95%B0%E4%BD%8Ddp%2F</url>
    <content type="text"><![CDATA[前一阵学到的数位dp终于派上了用场。 题目描述 One integer number x is called “Mountain Number” if: (1) x&gt;0 and x is an integer; (2) Assume $ x=a[0]a[1]…a[len-2]a[len-1] $ ($ 0≤a[i]≤9$ , a[0] is positive). Any a[2i+1] is larger or equal to a[2i] and a[2i+2](if exists). For example, 111, 132, 893, 7 are “Mountain Number” while 123, 10, 76889 are not “Mountain Number”. Now you are given L and R, how many “Mountain Number” can be found between L and R (inclusive) ? Input The first line of the input contains an integer T (T≤100), indicating the number of test cases. Then T cases, for any case, only two integers L and R (1≤L≤R≤1,000,000,000). Output For each test case, output the number of “Mountain Number” between L and R in a single line. Sample Input 12345&gt; 3&gt; 1 10&gt; 1 100&gt; 1 1000&gt; Sample Output 1234&gt; 9&gt; 54&gt; 384&gt; 题目大概意思就是定义一个 “ 山型数 ” ，它里面的奇数位不小于偶数位（最高位为第 0 位），求区间 [ l , r ] 里面山型数的个数。 算是数位dp的裸题吧。 这是下午提交的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int dp[100][100];int wei[100];int swdp(int pos,int p,int pre,bool limit)&#123; if(pos==0) return 1; if(!limit &amp;&amp; dp[pos][pre]&gt;=0) return dp[pos][pre]; int cnt=0; int maxx=limit?wei[pos]:9; for(int i=0;i&lt;=maxx;i++)&#123; if(p%2==1 &amp;&amp; pre&gt;i) continue; if(p%2==0 &amp;&amp; pre&lt;i) continue; cnt+=swdp(pos-1,p+1,i,limit &amp;&amp; i==maxx); &#125; if(!limit) dp[pos][pre]=cnt; return cnt;&#125;int solve(int x)&#123; if(x==0) return 1; memset(dp,-1,sizeof(dp)); int sum=1; while(x)&#123; wei[sum++]=x%10; x/=10; &#125; return swdp(sum-1,0,10,true);&#125;int main()&#123; int t,l,r; scanf("%d",&amp;t); while(t--)&#123; scanf("%d %d",&amp;l,&amp;r);// printf("%d %d\n",solve(r),solve(l-1)); printf("%d\n",solve(r)-solve(l-1)); &#125; return 0;&#125; 提交的时候就感觉这个代码和正常的数位dp有一点不同。一般情况下 memset 应该在主函数里面，只需要初始化一次就可以了，但是下午在调试的时候发现只有每次都更新才能计算出正确结果。 经过长时间的调试，发现了我在数位dp上的漏洞。数位dp保存下来的值应该具有后效性，但是我的代码忽略的位的区别，当前位可能是奇数位，也可能是偶数位，奇偶性不同，结果也不同。因此不能使用二维的数组来储存，应该再多加一维，用来区分位的奇偶性。 修改后的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int dp[100][100][2];//当前位置，前一位数，当前位置奇偶性 int wei[100];int DP(int pos,int pre,int bit,bool limit)&#123; if(pos==0) return 1; if(!limit &amp;&amp; dp[pos][pre][bit&amp;1]&gt;=0) return dp[pos][pre][bit&amp;1]; int cnt=0; int maxx=limit?wei[pos]:9; for(int i=0;i&lt;=maxx;i++)&#123; if(bit%2==0 &amp;&amp; pre&lt;i) continue; if(bit%2==1 &amp;&amp; pre&gt;i) continue; cnt+=DP(pos-1,i,bit+1,limit &amp;&amp; i==maxx); &#125; if(!limit) dp[pos][pre][bit&amp;1]=cnt; return cnt;&#125;int solve(int x)&#123; if(x==0) return 1; int sum=1; while(x)&#123; wei[sum++]=x%10; x/=10; &#125; return DP(sum-1,10,0,true);&#125;int main()&#123; int t,l,r; scanf("%d",&amp;t); memset(dp,-1,sizeof(dp)); while(t--)&#123; scanf("%d %d",&amp;l,&amp;r); printf("%d\n",solve(r)-solve(l-1)); &#125; return 0;&#125; 温故而知新。 这也给了我一次重新认识数位dp的机会，对数位dp有了更深刻的了解。 以此共勉。]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九届河南理工大学算法程序设计竞赛]]></title>
    <url>%2F2019%2F03%2F31%2F%E7%AC%AC%E4%B9%9D%E5%B1%8A%E6%B2%B3%E5%8D%97%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[人外有人，外校的强者还是多。 A.Asia区域赛感谢组委会给我们学校举办区域赛的机会！ 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;const int maxn=1000000+10;int main()&#123; printf("%d",29+58+87+11+1+1); return 0;&#125; B.Asia区域制二进制转16进制，四位二进制相当于一位16进制，直接按照定义模拟就可以了。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;const int maxn=1000000+10;char str[1000000+100];char num[100]="0123456789abcdef";void cal(int pos)&#123; int res=0; if(pos&lt;=0)&#123; for(int i=0;i&lt;pos+4;i++)&#123; res=res*2+(str[i]-'0'); &#125; printf("%c",num[res]); return; &#125; cal(pos-4); res=0; for(int i=pos;i&lt;pos+4;i++)&#123; res=res*2+(str[i]-'0'); &#125; printf("%c",num[res]);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",str); int len=strlen(str); cal(len-4); printf("\n"); &#125; return 0;&#125; C.Asia区域宫题目有句话很重要：障碍物在迷宫中不能同行且不能同列，因此只要不是从左下角连到右上角（不一定非得是角落）把地图分成两份，那么就可以走到，并且不用走多余的步数。 所以我们只要统计每一斜线上的格子是否被填满，当 x1+y1=x2+y2时，这两个格子在同一斜线。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;const int maxn=1000000+10;#define pi pair&lt;int,int&gt;int a[maxn];int main()&#123; int t,x,y,n,m; scanf("%d",&amp;t); while(t--)&#123; memset(a,0,sizeof(a)); scanf("%d %d",&amp;n,&amp;m); int flag=0; while(m--)&#123; scanf("%d %d",&amp;x,&amp;y); x--,y--; a[n+x+y]++; if(x+y&lt;n)&#123; if( a[n+x+y] == x+y+1 ) flag=1; &#125; else&#123; if(a[n+x+y]==n*2-1-x-y) flag=1; &#125; &#125; if(flag==0) printf("Yes %d\n",n*2-2); else printf("No\n"); &#125; return 0;&#125; D.Asia区域阵确认过眼神，不是我的题。 这个题数据范围不大，但是复杂度较高。 我们枚举所有的起点（异矩阵的左上角），然后枚举异矩阵的行列大小。然后就可以慢慢求解。 我们在枚举异矩阵的列的时候，如果遇到了重复的字符，那么就直接结束，并且此时我们知道了列的最大值，因此我们可以更新列的范围。（当时应该就是因为这个超时了） 对于 6 * 6 的矩阵 如果（红色为选中的异矩阵，黑色为重复字符）： 那么我们接下来最多就只能进行到： 列数是越来越小，不可能比之前的还大了。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;const int maxn=1000000+10;char str[1000][1000];int main()&#123; int t,n,m; scanf("%d",&amp;t); while(t--)&#123; scanf("%d %d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%s",str[i]); &#125; int res=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; map&lt;char,int&gt;mpl[30],mpr[30]; int length=26; for(int k=0;k&lt;26,k+i&lt;n;k++)&#123; for(int l=0;l&lt;length;l++)&#123; if( mpl[k][ str[i+k][j+l] ] &gt; 0 || mpr[l][ str[i+k][j+l] ] &gt; 0)&#123; length=min(length,l);//减小length的范围 break; &#125; mpl[k][ str[i+k][j+l] ]++; mpr[l][ str[i+k][j+l] ]++; res=max(res,(k+1)*(l+1)); &#125; &#125; &#125; &#125; printf("%d\n",res); &#125; return 0;&#125; E.Mo的游戏也是模拟，注意一下每个字符第一次出现的情况就行了。 保存这个字符上一次出现的位置，然后根据现在这个位置和保存的上个位置的差值来进行求解。如果之前没有出现过这个字符，那么就跳过，不用计算。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;const int maxn=1000000+10;char str[1000000];int pos[100000];int res[100000];int main()&#123; memset(pos,-1,sizeof(pos)); memset(res,INF,sizeof(res)); scanf("%s",str); int len=strlen(str); map&lt;char,int&gt;mp; for(int i=0;i&lt;len;i++)&#123; mp[str[i]]++; if(pos[str[i]]&gt;=0)&#123; res[str[i]]=min(i-pos[str[i]],res[str[i]]); &#125; pos[str[i]]=i; &#125; for(char i='a';i&lt;='z';i++)&#123; if(mp[i])&#123; printf("%c:",i); if(res[i]!=INF) printf("%d",len-res[i]); else printf("0"); printf("\n"); &#125; &#125; for(char i='A';i&lt;='Z';i++)&#123; if(mp[i])&#123; printf("%c:",i); if(res[i]!=INF) printf("%d",len-res[i]); else printf("0"); printf("\n"); &#125; &#125; return 0;&#125; F.Mo的极限炒鸡大模拟，简直了。。。 因为多项式的格式为 kx^y ,所以我们找 k 和 y 时可以直接根据它们的相对位置来求解。 首先当然是确认k的正负，根据 k 前面的 + - 字符判断，然后再运算符之后就是 k 的值。 计算出 k 的值之后，k 和 y 之间相差了一个 x^ 因此把位置向后挪两位，就可以直接开始求 y 的值。 坑1：每个项可能会抵消，所以要用数组存每个项的系数。 坑2：最后输出不能有1/-2这种情况，必须是-1/2。（我因为这个多wa了两次QAQ） 坑3：应该是没其他太大的坑了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;const int maxn=1000000+10;char str1[maxn],str2[maxn];int xishu1[maxn],xishu2[maxn];int gcd(int x,int y)&#123; return y?gcd(y,x%y):x;&#125;int main()&#123; int sum,x,y,flag; int max_xishu1=-1,max_xishu2=-1; int max_mi1=-1,max_mi2=-1; scanf("%s %s",str1,str2); int len1=strlen(str1); sum=0; x=y=0; flag=1; for(int i=0;i&lt;len1;i++)&#123; if(str1[i]=='-') flag=-1,i++; else if(str1[i]=='+') flag=1,i++; if(str1[i]&gt;='0' &amp;&amp; str1[i]&lt;='9')&#123; while(str1[i]&gt;='0' &amp;&amp; str1[i]&lt;='9')&#123; x=x*10+str1[i]-'0'; i++; &#125; x*=flag; i+=2; &#125; if(str1[i-1]=='^' &amp;&amp; str1[i]&gt;='0' &amp;&amp; str1[i]&lt;='9')&#123; while(str1[i]&gt;='0' &amp;&amp; str1[i]&lt;='9')&#123; y=y*10+str1[i]-'0'; i++; &#125; xishu1[y]+=x; &#125; x=0,y=0; if(i&gt;=len1-1) break; i--; &#125; for(int i=10000;i&gt;=0;i--)&#123; if(xishu1[i])&#123; max_mi1=i; max_xishu1=xishu1[i]; break; &#125; &#125; int len2=strlen(str2); sum=0; x=y=0; flag=1; for(int i=0;i&lt;len2;i++)&#123; if(str2[i]=='-') flag=-1,i++; else if(str2[i]=='+') flag=1,i++; if(str2[i]&gt;='0' &amp;&amp; str2[i]&lt;='9')&#123; while(str2[i]&gt;='0' &amp;&amp; str2[i]&lt;='9')&#123; x=x*10+str2[i]-'0'; i++; &#125; x*=flag; i+=2; &#125; if(str2[i-1]=='^' &amp;&amp; str2[i]&gt;='0' &amp;&amp; str2[i]&lt;='9')&#123; while(str2[i]&gt;='0' &amp;&amp; str2[i]&lt;='9')&#123; y=y*10+str2[i]-'0'; i++; &#125; xishu2[y]+=x; &#125; x=0,y=0; if(i&gt;=len2-1) break; i--; &#125; for(int i=10000;i&gt;=0;i--)&#123; if(xishu2[i])&#123; max_mi2=i; max_xishu2=xishu2[i]; break; &#125; &#125; if(max_mi1==-1) printf("0"); else if(max_mi1&gt;max_mi2) printf("oo\n"); else if(max_mi1&lt;max_mi2) printf("0\n"); else&#123; if(max_xishu1%max_xishu2==0)&#123; printf("%d\n",max_xishu1/max_xishu2); &#125; else&#123; int g=gcd(max_xishu1,max_xishu2); if(max_xishu2/g&lt;0)&#123; max_xishu1*=-1; max_xishu2*=-1; &#125; printf("%d/%d",max_xishu1/g,max_xishu2/g); &#125; &#125; return 0;&#125; G.Mo的数学容斥定理+逆元。 这个如果直接用循环就会超时。 我们先预处理 1 ~ n 的阶乘，可以省下不少时间。 思路是：找出 n ! （n的阶乘）,然后除以不符合条件的数（不互质的数）。 然后我们对 m 的因子进行处理，可以知道的是，如果m的质因子 a ，那么 a * x（x&gt;=0） 必然与 m 不互质，而且在 [ 1 , n ] 的范围内 a 的倍数相乘结果为$ f(a)=a^{n/a}*(n/a)! $ ，因为区间内 a 的倍数只有 n / a 个，然后就是容斥定理（容斥定理详见我之前的博客（算数基本定理+容斥定理））。 但是在除以 f(a) 时，可能会出现除不尽的情况，因此需要用逆元来处理一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;const int maxn=1000000+10;const ll mod=1000000000+7;ll mul[maxn];ll yinzi[maxn];void init()&#123; mul[1]=1; for(ll i=2;i&lt;maxn;i++)&#123; mul[i]=mul[i-1]*i%mod; &#125;&#125;ll mulpow(ll x,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1) res=res*x%mod; x=x*x%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; init(); ll n,m,i,j; ll res,sum,s,x; while(~scanf("%lld %lld",&amp;n,&amp;m))&#123; res=mul[n]; sum=0; for(i=2;i*i&lt;=m;i++)&#123; if(m%i==0)&#123; yinzi[sum++]=i; while(m%i==0) m/=i; &#125; &#125; if(m!=1) yinzi[sum++]=m; for(i=1;i&lt;=(1&lt;&lt;sum)-1;i++)&#123; x=1; s=0; for(j=0;j&lt;sum;j++)&#123; if((i&gt;&gt;j)&amp;1)&#123; s++; x*=yinzi[j]; &#125; &#125; if(x&gt;n) continue; if(s&amp;1)&#123; res=res*mulpow(mulpow(x,n/x),mod-2)%mod; res=res*mulpow(mul[n/x],mod-2)%mod; &#125; else&#123; res=res*mulpow(x,n/x)%mod; res=res*mul[n/x]%mod; &#125; &#125; printf("%lld\n",res%mod); &#125; return 0;&#125; H.Mo的面积做了第三遍了…详见之前的博客矩阵面积并。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;const ll mod=1e9+7;const int maxn=1000000+10;int main()&#123; int a[100]; for(int i=1;i&lt;=8;i++)&#123; scanf("%d",&amp;a[i]); &#125; int r=min(max(a[1],a[3]),max(a[5],a[7])); int l=max(min(a[1],a[3]),min(a[5],a[7])); int u=min(max(a[2],a[4]),max(a[6],a[8])); int d=max(min(a[2],a[4]),min(a[6],a[8])); int bing; if(r-l&lt;0 || u-d&lt;0) bing=0; else bing=(r-l)*(u-d); printf("%d\n",(a[3]-a[1])*(a[4]-a[2])+(a[7]-a[5])*(a[8]-a[6])-bing); return 0;&#125; I.安全距离防AK题果然毒瘤。 二分适用于单调性的区间，由于这个题目球面是个弧线，并不是直线，因此需要用三分来求解。 然后我们就用三分的思想来求解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;struct P &#123; double x, y, z; P() &#123;&#125; P(double _x, double _y, double _z) &#123; x = _x; y = _y; z = _z; &#125; double operator*(const P &amp;b) const &#123; return x * b.x + y * b.y + z * b.z; &#125; P operator*(const double &amp;b) const &#123; return P(x * b, y * b, z * b); &#125; P operator-(const P &amp;b) const &#123; return P(x - b.x, y - b.y, z - b.z); &#125; P operator+(const P &amp;b) const &#123; return P(x + b.x, y + b.y, z + b.z); &#125; double dis(const P &amp;b) const &#123; return sqrt((*this - b) * (*this - b)); &#125;&#125;;inline double f(const P &amp;a, const P &amp;b, const P &amp;o, const double &amp;t) &#123; P p = a + ((b - a) * t); return p.dis(o);&#125;inline double g(const P &amp;s, const P &amp;t, const P &amp;o) &#123; double low = 0.0, top = 1.0; for (int i = 0; i &lt; 80; ++i) &#123; double m = (top - low) / 3.0; double l = low + m; double r = top - m; if (f(s, t, o, l) &gt;= f(s, t, o, r)) low = l; else top = r; &#125; return f(s, t, o, low);&#125;double DIS(P s, P b, P c, P o) &#123; double low = 0.0, top = 1.0; for (int i = 0; i &lt; 80; ++i) &#123; double m = (top - low) / 3; double l = low + m; double r = top - m; if (g(s, b + (c - b) * l, o) &gt;= g(s, b + (c - b) * r, o)) low = l; else top = r; &#125; return g(s, b + ((c - b) * low), o);&#125;int main() &#123; std::ios::sync_with_stdio(false); P s, b, c, o; double r; int n; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; s.x &gt;&gt; s.y &gt;&gt; s.z &gt;&gt; b.x &gt;&gt; b.y &gt;&gt; b.z &gt;&gt; c.x &gt;&gt; c.y &gt;&gt; c.z &gt;&gt; o.x &gt;&gt; o.y &gt;&gt; o.z &gt;&gt; r; double dis = min(min(DIS(b, s, c, o), DIS(s, b, c, o)), DIS(c, s, b, o)); printf("%.6lf\n", max(0.0, dis - r)); &#125; return 0;&#125; J.简单递归直接抄就完事了。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;const ll mod=1e9+7;const int maxn=1000000+10;ll res[maxn];void init()&#123; res[0]=res[1]=res[2]=1; for(int i=3;i&lt;maxn;i++)&#123; res[i]=((res[i-1]&lt;&lt;1)%mod+(res[i-2]&gt;&gt;1)%mod)%mod; &#125;&#125;int main()&#123; init(); int t,n; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); printf("%lld\n",res[n]); &#125; return 0;&#125; K.高度期望贪心一发，能多加尽量多加。 选取尽量低的树，这样加的高度就更多。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;const int maxn=1000000+10;int a[maxn];int main()&#123; int n,m; scanf("%d %d",&amp;n,&amp;m); int sum=0; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); sum+=a[i]; &#125; sort(a,a+n); int res=0; for(int i;i&lt;n;i++)&#123; if(sum&gt;=m*n) break; else&#123; res++; sum+=(1000-a[i]); &#125; &#125; printf("%d\n",res); return 0;&#125; L.最优规划最小生成树裸题。 前m个路径长度不用管，直接把城镇相连。 之后s个用结构体保存，排序之后选择，然后并查集莽一发就过了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int father[100010];struct node&#123; int x,y; int val;&#125;qwe[100010];bool cmp(node c,node d)&#123; return c.val&lt;d.val;&#125;int find(int c)&#123; return father[c]==c?c:father[c]=find(father[c]);&#125;int join(int c,int d)&#123; int x1=find(c); int x2=find(d); if(x1!=x2) &#123; father[x2]=x1; return 1; &#125; return 0;&#125;int main()&#123; int n,m,s; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=n;i++) father[i]=i; for(int i=0;i&lt;m;i++) &#123; int a,b,val; scanf("%d%d%d",&amp;a,&amp;b,&amp;val); join(a,b); &#125; for(int i=0;i&lt;s;i++) &#123; scanf("%d%d%d",&amp;qwe[i].x,&amp;qwe[i].y,&amp;qwe[i].val); &#125; sort(qwe,qwe+s,cmp); long long sum=0; for(int i=0;i&lt;s;i++) &#123; if(join(qwe[i].x,qwe[i].y)) &#123; sum+=qwe[i].val; &#125; &#125; int t=0; for(int i=1;i&lt;=n;i++) &#123; if(father[i]!=i) t++; &#125; if(t==n-1) &#123; printf("%lld\n",sum); &#125; else printf("Concubines can't do it.\n"); return 0;&#125; 还是把代码贴上吧。 代码太丑，仅供参考。]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的天梯赛一日游]]></title>
    <url>%2F2019%2F03%2F30%2F%E8%8F%9C%E9%B8%A1%E7%9A%84%E5%A4%A9%E6%A2%AF%E8%B5%9B%E4%B8%80%E6%97%A5%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[省二，就这样吧。 毕竟不可控因素太多了，还是自己实力不够。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大dp系列--区间dp]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E5%8C%BA%E9%97%B4dp%2F</url>
    <content type="text"><![CDATA[区间dp区间dp有点道家的思想：一生二，二生三，三生万物。 区间dp的思想就是化繁为简，将大的区间化成两个小的区间，然后递推求解。 石子合并石子归并 N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。 例如： 1 2 3 4，有不少合并方法 1 2 3 4 =&gt; 3 3 4(3) =&gt; 6 4(9) =&gt; 10(19) 1 2 3 4 =&gt; 1 5 4(5) =&gt; 1 9(14) =&gt; 10(24) 1 2 3 4 =&gt; 1 2 7(7) =&gt; 3 7(10) =&gt; 10(20) 括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。 输入 第1行：N（2 &lt;= N &lt;= 100)第2 - N + 1：N堆石子的数量（1 &lt;= A[i] &lt;= 10000) 输出 输出最小合并代价 输入样例 4 1 2 3 4 输出样例 19 这个是最经典的区间dp问题。 对于区间 [ i , j ] ，我们可以把它分成两个区间 [ i , k ] 和 [ k+1 , j ]，那么我们就可以通过这两个小区间的值来计算出大区间的值。 这是归并的过程（1,2,3,4为编号）： 可以发现的是，每次合并都是两个小区间合并成一个大区间，因此，我们只要计算出每个小区间所需要的最小花费，就能计算出合并后的大区间的最小花费。 代码如下： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+10;const int INF=0x3f3f3f3f;int n;int dp[maxn][maxn];//表示合并区间[i,j]的最小花费int sum[maxn];//从 1 ~ i 的和 int main()&#123; int x; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); sum[i]=sum[i-1]+x; &#125; memset(dp,INF,sizeof(dp)); for(int i=1;i&lt;=n;i++)&#123; dp[i][i]=0; &#125; for(int len=2;len&lt;=n;len++)&#123;//计算长为len的区间的值 for(int i=1;i&lt;=n;i++)&#123; //区间长为len,起点为i，终点为i+len-1 int j=i+len-1; if(j&gt;n) break; for(int k=i;k&lt;j;k++)&#123;//枚举所有的小区间 dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);//sum[j]-sum[i-1]表示合并大区间[i,j]所需要添加的花费 &#125; &#125; &#125; printf("%d\n",dp[1][n]); return 0;&#125; 这个代码的时间复杂度为O($n^3$)，当n比较大时就没办法在规定时间内求解。 这是我们就可以用四边形不等式（别问，问就是百度）来优化。当我们求解dp[ i , j - 1 ]时，我们可以记录最小花费的 k 的位置，即s[ i ][ j-1 ]=$k_1$。同样的，求解dp[ i + 1 ][ j ]时，我们也可以求出s[ i + 1 s][ j ] =$k_2$。 四边形不等式 如果对于任意的a1≤a2&lt;b1≤b2，有m[ a1 , b1 ]+m[ a2 , b2 ]≤m[ a1 , b2 ]+m[ a2 , b1 ]，那么m[ i , j ]满足四边形不等式。 写成符合这篇博客的形式为： 如果对于任意的 i ≤ i + 1 &lt; j - 1 ≤ j ，有dp[ i , j-1 ]+dp[ i+1 , j ]≤dp[ i , j ]+dp[ i + 1 , j - 1 ]，那么m[ i , j ]满足四边形不等式。 某聚的四边形不等式详细讲解 从这个定理，我们可以推出区间 [ i ][ j ]所对应的 k 值在s[ i ][ j - 1 ] 和s[ i + 1 ][ j ] 之间，然后，我们又可以计算出s[ i ][ j ]，依次递推。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+10;const int INF=0x3f3f3f3f;int n;int dp[maxn][maxn];int s[maxn][maxn];int sum[maxn];int main()&#123; int x; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); sum[i]=sum[i-1]+x; &#125; memset(dp,INF,sizeof(dp)); for(int i=1;i&lt;=n;i++)&#123; dp[i][i]=0; s[i][i]=i;//初始化 &#125; for(int len=2;len&lt;=n;len++)&#123; for(int i=1;i&lt;=n;i++)&#123; int j=i+len-1; if(j&gt;n) break; for(int k=s[i][j-1];k&lt;=s[i+1][j];k++)&#123; if( dp[i][j] &gt; dp[i][k] + dp[k+1][j] + sum[j] - sum[i-1])&#123; dp[i][j] = dp[i][k] + dp[k+1][j] + sum[j] - sum[i-1]; s[i][j]=k;//记录最小花费对应的k值 &#125; &#125; &#125; &#125; printf("%d\n",dp[1][n]); return 0;&#125; 这样我们就能把复杂度从O($ n^3 $)减少到O($ n^2 $)。 Monkey PartyHDU3506 这道题和石子归并相似，只是把线变成了环。我们只要把输入复制一遍放在第一次输入的后面就可以把环变成线来求解。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int INF=0x3f3f3f3f;const int maxn=2000+10;int n;int s[maxn][maxn];int dp[maxn][maxn];int sum[maxn];int a[maxn];int main()&#123; int x; while(~scanf("%d",&amp;n))&#123; sum[0] = 0; memset(s,0,sizeof(s)); memset(dp,INF,sizeof(dp)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); sum[i] = sum[i-1] + a[i]; &#125; for(int i=n+1;i&lt;=n*2;i++) sum[i] = sum[i-1] + a[i-n]; for(int i=1;i&lt;=n*2;i++)&#123; dp[i][i] = 0; s[i][i] = i; &#125; for(int len=2;len&lt;=n;len++)&#123; for(int i=1;i&lt;=n*2;i++)&#123; int j = i + len - 1; if(j&gt;n*2) break; for(int k=s[i][j-1];k&lt;=s[i+1][j];k++)&#123; if( dp[i][j] &gt; dp[i][k] + dp[k+1][j] + sum[j] - sum[i-1])&#123; dp[i][j] = dp[i][k] + dp[k+1][j] + sum[j] - sum[i-1]; s[i][j] = k; &#125; &#125; &#125; &#125; int ans=INF; for(int i=1;i&lt;=n;i++) ans = min( ans , dp[i][i+n-1] ); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十届蓝桥杯--C++-B组]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF-C-B%E7%BB%84%2F</url>
    <content type="text"><![CDATA[能力一般，水平有限。请多见谅。 喜提河南省一等奖一枚！ A:组队 本题总分：5 分 ​ 作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员， 组成球队的首发阵容。 每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1 号位至 5 号位的评分之和最大可能是多少？ 暴力解决一切！ 答案：490。 B:年号字串 本题总分：5 分 小明用字母 A 对应数字 1，B 对应 2，以此类推，用 Z 对应 26。对于 27 以上的数字，小明用两位或更长位的字符串来对应，例如 AA 对应 27，AB 对 应 28，AZ 对应 52，LQ 对应 329。 请问 2019 对应的字符串是什么？ 不得不说，这个题遇见26居然还不进位！比赛最后我不得不手算…… 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longvoid out(int n)&#123; if(n&lt;=0) return ; if(n%26!=0)&#123;//所有位不能为0 out(n/26); printf("%c",n%26+'A'-1); &#125; else&#123;//如果为零，必须从高位借一位 out((n-26)/26); printf("Z"); &#125;&#125;int main()&#123; int n=2019; out(n); return 0;&#125; 答案：BYQ。（算出BY的时候还激动了一下） C: 数列求值 本题总分：10 分 给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求 第 20190324 项的最后 4 位数字。 一个 for 循环解决一切！ 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int a=1,b=1,c=1; int d; for(int i=4;i&lt;=20190324;i++)&#123; d=(a+b+c)%10000; a=b; b=c; c=d; &#125; printf("%d\n",d); return 0;&#125; 答案：4659 D: 数的分解 本题总分：10 分 把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包 含数字 2 和 4，一共有多少种不同的分解方法？ 注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。 暴力杯名不虚传。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;bool cal(int x)&#123; while(x)&#123; if(x%10==2 || x%10==4) return false; x/=10; &#125; return true;&#125;int main()&#123; int sum=0; for(int i=1;i&lt;=2019;i++)&#123; for(int j=i+1;j&lt;=2019;j++)&#123; if(2019-i-j&lt;=j) break; if(cal(i) &amp;&amp; cal(j) &amp;&amp; cal(2019-i-j))&#123; sum++; &#125; &#125; &#125; printf("%d\n",sum); return 0;&#125; 答案： 40785。 E: 迷宫 本题总分：15 分 下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。 010000000100001001110000 ​ 迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。 对于上面的迷宫，从入口开始，可以按 DRRURRDDDR 的顺序通过迷宫， 一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式， 其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。 请注意在字典序中D&lt;L&lt;R&lt;U。 01010101001011001001010110010110100100001000101010 00001000100000101010010000100000001001100110100101 01111011010010001000001101001011100011000000010000 01000000001010100011010000101000001010101011001011 00011111000000101000010010100010100000101100000000 11001000110101000010101100011010011010101011110111 0001101101010100100100101000000100010100111000000010100000101000100110101010111110011000010000111010 00111000001010100001100010000001000101001100001001 11000110100001110010001001010101010101010001101000 00010000100100000101001010101110100010101010000101 11100100101001001000010000010101010100100100010100 00000010000000101011001111010001100000101010100011 10101010011100001000011000010110011110110100001000 10101010100001101010100101000010100000111011101001 10000000101100010000101100101101001011100000000100 10101001000000010100100001000100000100011110101001 00101001010101101001010100011010101101110000110101 11001010000100001100000010100101000001000111000010 00001000110000110101101000000100101001001000011101 10100101000101000000001110110010110101101010100001 00101000010000110101010000100010001001000100010101 10100001000110010001000010101001010101011111010010 00000100101000000110010100101001000001000000000010 11010000001001110111001001000011101001011011101000 00000110100010001000100000001000011101000000110011 10101000101000100010001111100010101001010000001000 10000010100101001010110000000100101010001011101000 00111100001000010000000110111000000001000000001011 10000001100111010111010001000110111010101101111000 BFS+路径记忆，算是前面几道题唯一涉及算法的题目了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;#define pi pair&lt;int,int&gt;int n=30,m=50;char mp[100][100];int vis[100][100];int step[100][100];//1：D 2:L 3: R 4: U int d[4][2]=&#123;1,0,0,-1,0,1,-1,0&#125;;void bfs(int x,int y)&#123; vis[x][y]=1; queue&lt;pi&gt;que; que.push(pi(x,y)); while(!que.empty())&#123; x=que.front().first; y=que.front().second; que.pop(); for(int i=0;i&lt;4;i++)&#123; int xx=x+d[i][0]; int yy=y+d[i][1]; if(mp[xx][yy]=='0' &amp;&amp; !vis[xx][yy] &amp;&amp; xx&gt;=0 &amp;&amp; xx&lt;n &amp;&amp; yy&gt;=0 &amp;&amp; yy&lt;m)&#123; vis[xx][yy]=1; step[xx][yy]=i+1; que.push(pi(xx,yy)); &#125; &#125; &#125;&#125;void out(int x,int y)&#123; if(x==0 &amp;&amp; y==0) return ; if(step[x][y]==1)&#123; out(x-1,y); printf("D"); &#125; else if(step[x][y]==2)&#123; out(x,y+1); printf("L"); &#125; else if(step[x][y]==3)&#123; out(x,y-1); printf("R"); &#125; else&#123; out(x+1,y); printf("U"); &#125;&#125;int main()&#123; for(int i=0;i&lt;n;i++)&#123; scanf("%s",mp[i]); &#125; bfs(0,0); out(n-1,m-1); return 0;&#125; 答案： 1DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR F: 特别数的和 时间限制: 1.0s 内存限制: 256.0MB 本题总分：15 分 ​ 小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。 请问，在 1 到 n 中，所有这样的数的和是多少？【输入格式】​ 输入一行包含一个整数 n。【输出格式】​ 输出一行，包含一个整数，表示满足条件的数的和。【样例输入】 ​ 40【样例输出】 ​ 574【评测用例规模与约定】 ​ 对于 20% 的评测用例，1≤n≤10。 ​ 对于 50% 的评测用例，1≤n≤100。 ​ 对于 80% 的评测用例，1≤n≤1000。 ​ 对于所有评测用例，1≤n≤10000。 直接模拟就可以了。 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;bool cal(int x)&#123; while(x)&#123; if(x%10==2 || x%10==0 || x%10==1 || x%10==9) return true; x/=10; &#125; return false;&#125;int main()&#123; int n; scanf("%d",&amp;n); int sum=0; for(int i=1;i&lt;=n;i++)&#123; if(cal(i)) sum+=i; &#125; printf("%d\n",sum); return 0;&#125; G: 完全二叉树的权值 时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分 给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从 上到下、从左到右的顺序依次是 A1, A2, ··· AN，如下图所示： ​ 现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点 权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。 注：根的深度是 1。 【输入格式】 第一行包含一个整数 N。 第二行包含 N 个整数 A1, A2, ··· AN 。【输出格式】 输出一个整数代表答案。 【样例输入】 ​ 7 ​ 1 6 5 4 3 2 1【样例输出】 ​ 2【评测用例规模与约定】 ​ 对于所有评测用例，1≤ N ≤100000，−100000≤ Ai ≤100000。 完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。（来自百度百科）。 完全二叉树不是满二叉树，最后一层不一定全有节点，所以判断层数的时候要注意一下。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll INF=0x3f3f3f3f3f3f3f3f;ll a[1000000];int main()&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; int pos=0; int i=1; int dep=1; ll maxx=-INF; int res; while(true)&#123; if(pos&gt;=n) break;//上一次把所有数计算完毕 ll sum=0; for(int j=0;j&lt;i;j++)&#123;//每次加i个数,如果最后一层不满，+-0对结果不产生影响。 sum+=a[pos++]; &#125; if(maxx&lt;sum)&#123; maxx=sum; res=dep; &#125; i*=2; dep++; &#125; printf("%d\n",res); return 0;&#125; H: 等差数列 时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分 ​ 数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一 部分的数列，只记得其中 N 个整数。 现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有 几项？ 【输入格式】 ​ 输入的第一行包含一个整数 N。 第二行包含 N 个整数 A1,A2,··· ,AN。(注意 A1 ∼ AN 并不一定是按等差数 列中的顺序给出) 【输出格式】 ​ 输出一个整数表示答案。 【样例输入】 ​ 5 ​ 2 6 4 10 20 【样例输出】 ​ 10 【样例说明】 ​ 包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、 18、20。 【评测用例规模与约定】 ​ 对于所有评测用例，2≤ N ≤100000，0≤ Ai ≤109。 如果是等差数列，那么任意两个数的差值一定是公差的整数倍，因此我们只要找到最大的公差（GCD）就可以了。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint a[1000000];int gcd(int x,int y)&#123; return y?gcd(y,x%y):x;&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a,a+n); int g=0; for(int i=1;i&lt;n;i++)&#123; g=gcd(g,a[i]-a[i-1]); &#125; if(g==0) printf("%d\n",n); else printf("%d\n",(a[n-1]-a[0])/g+1); return 0;&#125; I: 后缀表达式 时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分 给定 N 个加号、M 个减号以及 N + M + 1 个整数 A1,A2,··· ,AN+M+1，小 明想知道在所有由这 N 个加号、M 个减号以及 N + M +1 个整数凑出的合法的 后缀表达式中，结果最大的是哪一个？ 请你输出这个最大的结果。 例如使用1 2 3 + -，则 “2 3 + 1 -” 这个后缀表达式结果是 4，是最大的。【输入格式】 第一行包含两个整数 N 和 M。 第二行包含 N + M + 1 个整数 A1,A2,··· ,AN+M+1。【输出格式】 输出一个整数，代表答案。【样例输入】 ​ 1 1 ​ 1 2 3【样例输出】 ​ 4【评测用例规模与约定】 ​ 对于所有评测用例，0≤ N,M ≤100000，−109 ≤ Ai ≤109。 待补充 …… J: 灵能传输 时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分【题目背景】 ​ 在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在 游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对 一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的 刺蛇飞龙等低血量单位。【问题描述】 ​ 你控制着 n 名高阶圣堂武士，方便起见标为 1,2,··· ,n。每名高阶圣堂武士 需要一定的灵能来战斗，每个人有一个灵能值 ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai 点灵能，ai 为负则表示这 名高阶圣堂武士还需要 −ai 点灵能才能到达最佳战斗状态）。现在系统赋予了 你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i ∈ [2,n−1]，若 ai ≥ 0 则其两旁的高阶圣堂武士，也就是 i−1、i + 1 这两名高阶圣堂武士会从 i 这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai &lt; 0 则其两旁的高阶圣堂武士， 也就是 i−1,i+1 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能。形 式化来讲就是 ai−1+ = ai,ai+1+ = ai,ai−= 2ai。 灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂 武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 maxn i=1|ai|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武 士的不稳定度最小。【输入格式】​ 本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。 接下来依次输入每一组询问。 每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。 接下来一行包含 n 个数 a1,a2,··· ,an。【输出格式】​ 输出 T 行。每行一个整数依次表示每组询问的答案。【样例输入】 335 -2 340 0 0 031 2 3 【样例输出】 303 【样例说明】 对于第一组询问： 对 2 号高阶圣堂武士进行传输操作后 a1 = 3，a2 = 2，a3 = 1。答案为 3。 ​ 对于第二组询问： 这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。【样例输入】 34-1 -2 -3 742 3 4 -85-1 -1 6 -1 -1 【样例输出】 574 【数据规模与约定】 ​ 对于所有评测用例，T ≤3，3≤n≤300000，|ai|≤1e9。 评测时将使用 25 个评测用例测试你的程序，每个评测用例的限制如下： 注意：本题输入量较大请使用快速的读入方式。 待补充 ……]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩形面积并]]></title>
    <url>%2F2019%2F03%2F22%2F%E7%9F%A9%E9%98%B5%E9%9D%A2%E7%A7%AF%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[问题描述： 题目描述 平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。 输入 输入仅包含两行，每行描述一个矩形。 在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。 输出 输出仅包含一个实数，为交的面积，保留到小数后两位。 样例输入 1234&gt; 1 1 3 3 &gt; &gt; 2 2 4 4 &gt; 样例输出 12&gt; 1.00&gt; 两个矩形相交的情况总共有以下几种（可能有部分遗漏）： 如果我们对所有的情况都进行分类讨论，那么代码写上百行是没问题的。 通过观察发现，每个相交的小矩形的四条边一定为两个大矩形的八条边中的四条。 再仔细观察的话，小矩形的每个方向的边都是两个大矩形同一个方向的两条边中的一条。 继续观察，小矩形每条边都是两个大矩形更靠近中心的两条边中的一条。 至此，我们就能够计算出小矩形的面积了。 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;double a[10];int main()&#123; double l,r,u,d; for(int i=1;i&lt;=8;i++)&#123; scanf("%lf",&amp;a[i]); &#125; l=max( min(a[1],a[3]) , min(a[5],a[7]) ); r=min( max(a[1],a[3]) , max(a[5],a[7]) ); d=max( min(a[2],a[4]) , min(a[6],a[8]) ); u=min( max(a[2],a[4]) , max(a[6],a[8]) ); if( r - l &lt;= 0 || u - d &lt;= 0 ) printf("0.00\n"); else printf("%.2lf\n",(r-l)*(u-d)); return 0;&#125;]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[四大dp系列--数位dp]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E6%95%B0%E4%BD%8Ddp%2F</url>
    <content type="text"><![CDATA[数位dp(本文参考于 大佬博客) 数位dp是一种高速求解给定区间内符合一定条件的数的个数的算法。其基本思想为记忆化搜索。 数位dp一般应用于： 求出在给定区间[A,B]内，符合条件P(i)的数i的个数. 条件P(i)一般与数的大小无关，而与 数的组成 有关 求解的基本步骤如下： 当我们求 [ 0 , 100000 ] 和 [ 100001 , 200000 ]中符合条件的数的个数时，我们只需要求出前一个区间符合条件的数的个数，后面的区间只需要使用前面计算出来的值就可以了。 以下面的 不含49 为例，当我们在求[ 49001 , 50000 ]符合条件的数的个数时，会有不符合条件的情况存在，因此我们需要对其值进行判断，即将这一部分的值省略掉，当把这部分去掉之后，我们再求出来[ 0 , 100000 ]中符合条件的数的个数。 如果 b 为 123456 ，如果我们仍然求解[100001,200000]的话就会出错，我们只能先求解[100000,120000]，然后再求解[120001,123000]，因此，我们还需要判断当前是否是数的上限。 不含49 求[ a , b ]中不包含49的数的个数。 1&lt;=a&lt;=b&lt;=1e9 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint a,b;int num[20];//储存每一位的值 int dp[20][2];//储存长度为length时符合条件的数的数量，两个数组分别表示 是4时 和 不是4时 的数量int dfs(int length,bool is_4,bool is_max)&#123; //如果计算到最后一位，那么直接返回 if(length==-1) return 1; //如果不是数的上限并且之前计算过，这步就是记忆化最关键的一步 if(!is_max &amp;&amp; dp[length][is_4]) return dp[length][is_4]; int cnt=0,maxx=(is_max ? num[length]:9);//判断是否是上限，即判断当前位所能取到的值的范围 for(int i=0;i&lt;=maxx;i++)&#123; if(is_4 &amp;&amp; i==9) continue;//上一位是4，这一位是9，那么就直接跳过 cnt+=dfs(length-1,i==4,is_max &amp;&amp; i==maxx); &#125; //如果是上限，那么不能保存，因为dp保存的是[100000,200000]这样的值，并不能储存[100000,120000]的值 return is_max?cnt:dp[length][is_4]=cnt;&#125;int solve(int x)&#123; memset(num,0,sizeof(num)); int length=0; while(x)&#123; num[length++]=x%10; x/=10; &#125; return dfs(length-1,false,true);&#125;int main()&#123; scanf("%d %d",&amp;a,&amp;b); printf("%d\n",solve(b)-solve(a-1)); return 0;&#125; 这是数位dp最基本的模板。 不要62不要62 题意很简单，求区间内不含 4 和 62 的数的个数。 这个代码和上面的代码几乎一样，只是中间加了一步判断 4 的步骤 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int a[20];int dp[20][2];int dfs(int length,int is_6,bool is_max)&#123; if(length==-1) return 1; if(!is_max &amp;&amp; dp[length][is_6]) return dp[length][is_6]; int cnt=0; int maxx=is_max?a[length]:9; for(int i=0;i&lt;=maxx;i++)&#123; if(is_6 &amp;&amp; i==2) continue;//不要62 if(i==4) continue; //不要4 cnt+=dfs(length-1,i==6,is_max &amp;&amp; i==maxx); &#125; if(!is_max) dp[length][is_6]=cnt; return cnt; &#125;int solve(int x)&#123; int length=0; while(x)&#123; a[length++]=x%10; x/=10; &#125; return dfs(length-1,0,true);&#125;int main()&#123; int a,b; while(~scanf("%d %d",&amp;a,&amp;b) &amp;&amp; a+b)&#123; printf("%d\n",solve(b)-solve(a-1)); &#125; return 0;&#125; 只要13 找出1~n范围内含有13并且能被13整除的数字的个数. 这个题目条件比前两个复杂一点，我们需要计算出这个数字是否是13的倍数，并且是否包含13，所以，我们需要用两个变量来判断。 一个变量用来判断是否是13的倍数；另一个变量用来判断是否包含13。而判断13时有三种情况： 上一位不是 1 上一位是 1 但这一位不是 3 上一位是 1 且这一位是 3 因此不能用 bool 类型数据判断是否包含13。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int a[100];int dp[20][20][10];//三维表示：长度为 length ，模数为 mod , 是否包含 13int dfs(int length,int mod,int have_13,bool limit)&#123; if(length==-1) return mod==0 &amp;&amp; have_13==2;// 是 13 的倍数并且包含 13 if(!limit &amp;&amp; dp[length][mod][have_13]) return dp[length][mod][have_13]; int cnt=0; int maxx=limit?a[length]:9; for(int i=0;i&lt;=maxx;i++)&#123; int next=have_13; //这是为了寻找数是否包含13，当have_13==2,即找到13后，就不会进行下列判断 if(have_13!=2 &amp;&amp; i!=1) next=0;//没有特殊情况（尾数不是 1 或 13 ） if(have_13!=2 &amp;&amp; i==1) next=1;//尾数为1 if(have_13==1 &amp;&amp; i==3) next=2;//后两位尾数为13 cnt+=dfs(length-1,(mod*10+i)%13,next,limit&amp;i==maxx); &#125; if(!limit) dp[length][mod][have_13]=cnt; return cnt;&#125;void solve(int n)&#123; int length=0; while(n)&#123; a[length++]=n%10; n/=10; &#125; printf("%d\n",dfs(length-1,0,0,true));&#125;int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; solve(n); &#125; return 0;&#125; 从上面几个例题我们就可以看出，求解基本的数位dp的核心就是处理所需要判断的条件，上面三个代码大体框架都一样，只是在判断是否继续向下求解时有所不同，因此我们只要处理好需要判断的条件就能够做简单的数位dp问题。 部分数位dp题目以及题解： Mountain Number Seven Segment Display]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大dp系列--状压dp]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E7%8A%B6%E5%8E%8Bdp%2F</url>
    <content type="text"><![CDATA[状压dp状态压缩dp，是一种将复杂的状态压缩成二进制数字的算法。 旅行商问题我们来看一个经典的旅行商问题： 给定一个n个顶点组成的带权有向图的距离矩阵d(i,j)(INF表示没有边)。要求从顶点0出发，经过每个顶点恰好一次后再回到顶点0。问所经过的边的总权重的最小值是多少？（来源于《挑战程序设计竞赛》）。 限制条件： 2&lt;=n&lt;=15 0&lt;=d(i,j)&lt;=1000 所有可能的路线会有 (n-1)! 种结果，因此我们不能够使用暴力的方法求解，那么我们需要用高效的方法来求解。 假如我们对每个顶点编号。我们可以用一个数的二进制来表示走过的集合 S ： 当n=5时，00000表示所有顶点均未走过，00001表示经过编号为0的顶点，10001表示经过第0和第4个顶点。11111表示经过所有的顶点。 这样，我们就能使用2^n次方个数来表示出所有的状态。 定义dp[S][v]：从v出发，访问剩余未访问过的节点所需要的最小花费。特别的，当S=2^n-1，v=0时,dp[S][v]=0。 从dp[S][v]的定义，我们也可以看出如下递推式：$$dp[S][v]=min(dp[S∪{u}][u]+d[v][u] | u∉S)$$其中u表示从v出发到达的下一个顶点。 S ∪ { u } 表示现在经过的所有顶点，由于是从 v 到 u ，所以当前的出发点也为u。d[v][u]表示从顶点 v 到顶点 u 的花费。 找出了递推式，我们就可以使用记忆化搜索的方式找出最小花费： 12345678910111213141516171819202122int n;int d[maxn][maxn];//储存地图信息，初始化为 INF int dp[1&lt;&lt;maxn][maxn];//记忆化搜索使用的数组int rec(int S,int v)&#123;//当前走过的节点集合 S，出发顶点v if(dp[S][v]&gt;=0)&#123; return dp[S][v];//由于我们使用的是递归的方法，所以如果有解，储存的一定是最优的解 &#125; if(S==(1&lt;&lt;n)-1 &amp;&amp; v==0)&#123;//访问过所有定点，并且回到最初起点0，那么在这个状态之后的花费一定是0，即不需要再有其他的花费 return dp[S][v]=0; &#125; int res=INF; for(int u=0;u&lt;n;u++)&#123; if(!(S&gt;&gt;u&amp;1))&#123;//第u个节点未被访问 res=min(res,rec(S|1&lt;&lt;u,u)+d[v][u]);//递归 S|1&lt;&lt;u表示走过u之后的节点集合，因为是走到u，所以新的出发点也是u &#125; &#125; return dp[S][v]=res;&#125;int solve()&#123; memset(dp,-1,sizeof(dp));//-1表示未被访问过 printf("%d\n",rec(0,0));&#125; 由于状压dp的特性，我们只能求解n比较小的情况，否则内存就会超限。 思考上述代码后，我们可以发现，每一个比较小的节点集合都是由比较大的节点集合计算出来的。即对于两个集合S( i ) ∈ S( j ) ，有 i &lt;= j 。我们在求S( i )时，需要先求出来S( j )的值。因此，我们也可以用循环的方法求解： 12345678910111213141516171819int n;int d[maxn][maxn];int dp[1&lt;&lt;maxn][maxn];void solve()&#123; for(int S=0;S&lt;1&lt;&lt;n;S++)&#123; fill(dp[S],dp[S]+n,INF); &#125; dp[(1&lt;&lt;n)-1][0]=0; for(int S=(1&lt;&lt;n)-2;S&gt;=0;S--)&#123; for(int v=0;v&lt;n;v++)&#123; for(int u=0;u&lt;n;u++)&#123; if(!(S&gt;&gt;u&amp;1))&#123; dp[S][v]=min(dp[S][v],dp[S|1&lt;&lt;u][u]+d[v][u]); &#125; &#125; &#125; &#125; printf("%d\n",dp[0][0]);&#125; 这就是最基础的状压dp问题。 （内容持续更新……）]]></content>
      <categories>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树基础模板]]></title>
    <url>%2F2019%2F03%2F15%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[三个基本的线段树操作模板。 线段树单点更新+查询区间最大值HDU1754 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1000000;int dat[maxn],n;int m,a,b;char op;void init(int x)&#123; n=1; while(n&lt;x) n*=2; for(int i=0;i&lt;n*2-1;i++)&#123; dat[i]=0; &#125;&#125;void update(int k,int a)&#123; k+=n-1; dat[k]=a; while(k&gt;0)&#123; k=(k-1)/2; dat[k]=max(dat[k*2+1],dat[k*2+2]); &#125;&#125;int query(int a,int b,int k,int l,int r)&#123; if(r&lt;a || b&lt;l) return 0; if(a&lt;=l &amp;&amp; r&lt;=b) return dat[k]; else&#123; int vl=query(a,b,k*2+1,l,(l+r)/2); int vr=query(a,b,k*2+2,(l+r)/2+1,r); return max(vl,vr); &#125;&#125;int main()&#123; int n_; while(~scanf("%d %d",&amp;n,&amp;m))&#123; n_=n; init(n); for(int i=0;i&lt;n_;i++)&#123; scanf("%d",&amp;dat[i+n-1]); update(i,dat[i+n-1]); &#125; getchar(); while(m--)&#123; scanf("%c %d %d",&amp;op,&amp;a,&amp;b); getchar(); if(op=='Q') printf("%d\n",query(a-1,b-1,0,0,n-1)); else if(op=='U') update(a-1,b); &#125; &#125; return 0;&#125; 线段树区间更新FZU1608 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1000000;int n,m,dat[maxn];void init(int x)&#123; n=1; while(n&lt;x) n*=2; for(int i=0;i&lt;n*2-1;i++)&#123; dat[i]=0; &#125;&#125;void update(int a,int b,int x,int k,int l,int r)&#123; if(b&lt;l || r&lt;a) return ; if(a&lt;=l &amp;&amp; r&lt;=b) dat[k]=max(x,dat[k]); else&#123; update(a,b,x,k*2+1,l,(l+r)/2); update(a,b,x,k*2+2,(l+r)/2+1,r); &#125;&#125;int query(int l,int r,int k,int mmax)&#123; if(l==r) return max(mmax,dat[k]); dat[k]=max(mmax,dat[k]); int vl=query(l,(l+r)/2,k*2+1,dat[k]); int vr=query((l+r)/2+1,r,k*2+2,dat[k]); return vl+vr;&#125;int main()&#123; int a,b,x; while(~scanf("%d %d",&amp;n,&amp;m))&#123; init(n); for(int i=0;i&lt;m;i++)&#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;x); update(a,b-1,x,0,0,n-1); &#125; printf("%d\n",query(0,n-1,0,0)); &#125; return 0;&#125; 线段树区间更新+区间求和POJ3468 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define ll long longconst ll maxn=1000000;ll dat[maxn],sum[maxn],n,m;void update(ll a,ll b,ll x,ll k,ll l,ll r)&#123; if(a&lt;=l &amp;&amp; r&lt;=b)&#123; dat[k]+=x; &#125; else if(l&lt;=b &amp;&amp; a&lt;=r)&#123; sum[k]+=(min(b,r)-max(a,l)+1)*x; update(a,b,x,k*2+1,l,(l+r)/2); update(a,b,x,k*2+2,(l+r)/2+1,r); &#125;&#125;ll query(ll a,ll b,ll k,ll l,ll r)&#123; if(b&lt;l || r&lt;a) return 0; else if(a&lt;=l &amp;&amp; r&lt;=b) return dat[k]*(r-l+1)+sum[k]; else&#123; ll res=(min(b,r)-max(a,l)+1)*dat[k]; res+=query(a,b,k*2+1,l,(l+r)/2); res+=query(a,b,k*2+2,(l+r)/2+1,r); return res; &#125;&#125;int main()&#123; ll a,b,x; char op; scanf("%lld %lld",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;x); update(i,i,x,0,0,n-1); &#125; getchar(); while(m--)&#123; scanf("%c",&amp;op); if(op=='Q')&#123; scanf("%lld %lld",&amp;a,&amp;b); printf("%lld\n",query(a-1,b-1,0,0,n-1)); &#125; else&#123; scanf("%lld %lld %lld",&amp;a,&amp;b,&amp;x); update(a-1,b-1,x,0,0,n-1); &#125; getchar(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六届Code+程序设计网络挑战赛-COORDINATE]]></title>
    <url>%2F2019%2F03%2F12%2F%E7%AC%AC%E5%85%AD%E5%B1%8ACode-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BD%91%E7%BB%9C%E6%8C%91%E6%88%98%E8%B5%9B-COORDINATE%2F</url>
    <content type="text"><![CDATA[题目描述题目描述 在视频编码中，往往需要将一帧画面分块。 为了简化问题，我们考虑将一幅图片看作 $2^n $ * $ 2^n $的网格。为了对图片进行处理，编码器往往会遍历每个格子，但遍历格子的方式在不同的应用中是不同的。 其中一种方式叫做光栅遍历，就是按照从左到右，从上到下的顺序依次进行标号。下图是一个 8×8 的例子： 另一种方式叫做 Z 字型遍历。先看一个 8×8 的例子： 可以构造性的给出描述： 1.对于$2^0 $ * $ 2^0 $的网格，直接遍历 2.对于$2^k $ * $ 2^k $ (k&gt;0)的网格，将其横着从中间、竖着从中间各分成两半，形成4个$2^{k-1} $ * $ 2^{k-1} $的方格，这四个方格按照左上、右上、左下、右下的顺序依次遍历。 输入格式 输入的第一行为两个整数 n,m ,$2^n$ 为矩形的边长，m 为询问次数。 接下来 m 行，每行是一个询问，询每个询问给出一个方格，方式有两种，如下： Z x 给出 Z 字形遍历中标号是 x 的方格。 R x 给出光栅遍历中标号是 x 的方格。 保证存在标号为x的方格。 输出格式 对于每种询问，请输出一行一个正整数，表示在另一种遍历方式中，给出格子的标号。 样例输入 1233 2Z 37R 37 样例输出 123549 解题思路从题意可知，我们需要找到与输入的排列方格序号位置对应的另一张排列方格位置序号。 我们先从输入R出发进行计算 输入 R x比如样例R 37，我们可以从题面的图片看出，它所对应的位置为第 4 行第 5 列（初始为第0行第0列，，以下缩写为（x,y））。 我们观察Z遍历可发现，如果我们把方格分成四个小方格，每个方格大小一样，每个位置所对应的值的差是一个值的整数倍。比如对于 49 和 33 ，33 和 17 ，17 和 1 ，他们在小方格中位置相同，差值均为小方格的大小（$ 2^n $ * $ 2^n $ / 4），因此，我们可以根据每个数字所在的方格位置，判断它所在的方格，从而算出它对应的值。 比如，对于（ 4 , 5 ），我们可以看出他所在的方块为第四块（小方块按遍历顺序编号1234），因此我们可以知道在Z中它的值 n &gt;=（$ 2^n $ * $ 2^n $ / 4）* 3 ,所以我们先保存这一部分值，然后将其对应到第一个方格所对应的位置（即行和列均减去边长的一半），因为我们已经将它放在了第一个方格，其他三个方格已经没有作用了，因此我们可以将边长减小为现在的一半。然后重复此步操作。 一次操作后，大方格的已经变成了 而( 4 , 5 )现在所对应的位置为（ 0 ，1），再分成四个小方格后在第一个方格，因此对行和列不操作，边长再减小一半。 现在，他的所对应的位置依然为（ 0 , 1 ）现在的大方格为 所在小方格编号为2，因此列数减去当前边长的一半，保存当前面积（$ 2^1 $ * $ 2^1 $ / 4 * 1）。此时，它的坐标已经变成了（0 ，0），计算结束。 上面进行了三次操作，其大致顺序为： 1.找到坐标对应的小方格编号。 2.把当前坐标移动到第一个小方格，记录移动所改变的值。 3.重复步骤1,2，直到坐标变为（0 , 0）。 4.输出总的改变的值。 比如上面的（ 4 , 5 ），我们三次操作保存的值为$ 2^3 $ * $ 2^3 $ / 4 * 3 = 48 ；0 ； $2^1 $ * $ 2^1 $ / 4 * 1 = 1。加起来的值为49，即最终答案。 这就是输入为R时的计算方法。 代码如下： 1234567891011121314151617181920212223ll i=x/line; //当前所在行ll j=x%line; //当前所在列ll res=0;ll l=line*line/4; //line为边长，l为一个小方格的面积ll fen=line/2; //fen为每个小方格的边长while(i&gt;0 || j&gt;0)&#123; if(j&gt;=fen &amp;&amp; i&lt;fen)&#123; //表示在第二个小方格 j-=fen; // res+=l; //储存当前操作所改变的值 &#125; else if(i&gt;=fen &amp;&amp; j&lt;fen)&#123; //表示在第三个小方格 i-=fen; res+=l*2; &#125; else if(i&gt;=fen &amp;&amp; j&gt;=fen)&#123; //表示在第四个小方格 i-=fen; j-=fen; res+=l*3; &#125; fen/=2;//将方块边长缩为原来的1/2,面积缩为原来的1/4 l/=4;&#125;printf("%lld\n",res); 输入Z x输入R时是根据行和列判断最终值，而输入Z时正好相反，根据x的值判断所在行和列。 我们如果知道x的大小，就可以判断它所在的小方格编号，因此也可以层层求出行和列的值。 代码如下： 1234567891011121314151617181920ll sumx=0,sumy=0; //储存行和列l=line*line/4; //同上ll fen=line/2; //同上while(x&gt;0)&#123; if(x/l==1)&#123;//根据值可判断出所在的小方格，从而判断出行和列应该加的值 sumy+=fen; x-=l;//减去对应的值，即上面的将坐标移动到第一个小方格 &#125; else if(x/l==2)&#123; sumx+=fen; x-=l*2; &#125; else if(x/l==3)&#123; sumx+=fen; sumy+=fen; x-=l*3; &#125; fen/=2; //同上 l/=4;&#125; 这样，我们就可以求出所有的值了。 完整代码如下（做题时提交代码）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pi pair&lt;int,int&gt;int main()&#123; ll n,m; char op; ll x; ll i,j; scanf("%lld %lld",&amp;n,&amp;m); ll line=1; for(ll i=0;i&lt;n;i++) line*=2;// printf("%lld %lld",line,(ll)pow(2,n));// 当时使用pow()提交wa了一次，改后ac了，可能精度有问题 while(m--)&#123; ll l; getchar(); scanf("%c %lld",&amp;op,&amp;x); if(op=='Z')&#123; ll sumx=0,sumy=0; l=line*line/4; ll fen=line/2; while(x&gt;0)&#123; if(x/l==1)&#123; sumy+=fen; x-=l; &#125; else if(x/l==2)&#123; sumx+=fen; x-=l*2; &#125; else if(x/l==3)&#123; sumx+=fen; sumy+=fen; x-=l*3; &#125; fen/=2; l/=4; &#125; printf("%lld\n",sumx*line+sumy); &#125; else if(op=='R')&#123; i=x/line; j=x%line; ll res=0; l=line*line/4; ll fen=line/2; while(i&gt;0 || j&gt;0)&#123; if(j&gt;=fen &amp;&amp; i&lt;fen)&#123; j-=fen; res+=l; &#125; else if(i&gt;=fen &amp;&amp; j&lt;fen)&#123; i-=fen; res+=l*2; &#125; else if(i&gt;=fen &amp;&amp; j&gt;=fen)&#123; i-=fen; j-=fen; res+=l*3; &#125; fen/=2; l/=4; &#125; printf("%lld\n",res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++常见STL]]></title>
    <url>%2F2019%2F03%2F04%2FC-%E5%B8%B8%E8%A7%81STL%2F</url>
    <content type="text"><![CDATA[学识浅薄，下面写的只是一小部分STL比较浅显的使用方法，不对其内部运行规则进行讨论，只对平时做题可能用到的功能进行讲解。 using namespace stdnamespace是指标识符的各种可见范围。命名空间用关键字namespace 来定义。命名空间是C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。 1234#include&lt;......&gt;#include&lt;......&gt;#include&lt;......&gt;using namespace std;//一般写在标准函数库后面 std是一个命名空间，使用这句的主要原因是处理程序中的命名冲突。 命名空间是用来组织和重用代码的。如同名字一样的意思，NameSpace（名字空间），之所以出来这样一个东西，是因为人类可用的单词数太少，并且不同的人写的程序不可能所有的变量都没有重名现象，对于库来说，这个问题尤其严重，如果两个人写的库文件中出现同名的变量或函数(不可避免)，使用起来就有问题了。为了解决这个问题，引入了名字空间这个概念，通过使用 namespace xxx；你所使用的库函数或变量就是在该名字空间中定义的，这样一来就不会引起不必要的冲突了。 通俗来说，我们使用的scanf()，printf()是来自于&lt;stdio.h&gt;函数库,pow()是来自&lt;math.h&gt;函数库等等。函数库是开发人员写的，但是我们在调用函数时可能会遇到两个函数库里面有名字重复了，因此我们使用了命名空间开区分重复的变量名称的所在空间。 比如接下来要讲的vector,英文释义为“矢量”（显而易见一个非常容易用到的词）。这个词会有很多开发人员使用，我们现在使用vector是在std命名空间内的，因此如果不在前面写using namespace std的话，那我们就得这样使用： 123456789101112131415161718192021222324252627282930//这个会报错:[Error] 'vector' does not name a type#include&lt;stdio.h&gt;#include&lt;vector&gt;vector&lt;int&gt; vec;//这个形式前半部分为数据类型，后半部分为定义的变量。相当于平时用的 int n;int main()&#123; return 0; &#125;//然而下面这个就不会报错#include&lt;stdio.h&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt;vec;int main()&#123; return 0; &#125;//或者#include&lt;stdio.h&gt;#include&lt;vector&gt;std::vector&lt;int&gt;vec;//这是不用写using namespace std;的写法。使用std的方式，但其长度明显变长，可读性明显下降。int main()&#123; return 0; &#125; 因此，在程序开头写上using namespace std;是最好的选择，接下来讲的STL(Standard Template Library, 标准模板库)也是基于其基础上。 vector头文件：#include\ vector 与数组相比最大的优点是可以根据需要动态的分配内存。对于图的储存（有向图，无向图）有非常大的作用。在一般题目中，图的顶点数大约为$$10^5$$左右，所有边总共有$$n*(n-1)/2$$个，因此如果用二维数组储存边，那么一定会内存超限。 而vector就没有这个缺点，vector根据输入的边的数量可以动态的分配内存（一般题目输入边的数量也在$$10^6$$以下），这样，就可以很容易的储存图。而且在查找时，还会节约许多时间。 vector的存储方式接下来看二维数组和vector的对比： 12345678910111213vector&lt;int&gt;vec[maxn];//定义一维vector数组int m[maxn][maxn];int u,v,m;for(int i=0;i&lt;m;i++)&#123;//二维数组直接分配maxn*maxn的内存，在输入时不需要再分配内存。 scanf("%d %d",&amp;u,&amp;v); a[u][v]=1;//表示两个顶点之间有一条边 &#125;for(int i=0;i&lt;m;i++)&#123;//一维vector数组输入时动态分配内存，内存大小最大只为m,要远远小于maxn*maxn scanf("%d %d",&amp;u,&amp;v); vec[u].push_back(v);//表示u连接向v vec[v].push_back(u);//根据有向图和无向图选择是否添加这一句&#125; 因此在一般情况下，使用vector存图是非常节省内存的方法。 vector的使用输入之后，边以数组的形式保存，使用时可以这样操作： 1234567for(int i=0;i&lt;vec[x].size();i++)&#123;//x为节点 printf("%d\n",vec[x][i]);//这段代码作用为输出与节点x相连的所有节点&#125;//相同作用下二维数组的操作for(int i=1;i&lt;=n;i++)&#123; if(a[x][i]==1) printf("%d\n",i);//对所有节点进行判断，如果相连则输出&#125; 上面的vec[x].size()表示输入时保存的与x相连的节点的数量。这个相比二维数组优点在于可以不用遍历那些没有边连接的节点，节省了大量的时间。 因此不管是在时间还是空间上，vector都优于二维数组。 map头文件：#include\ map 是一种容器，用来存储若干元素，这些元素都是由关键值和映射值 配对组成的。 简而言之，map里面的元素都有一定的映射关系。 map的基本应用形式为： 12map&lt;int,int&gt; mp;//一个整数对应一个整数map&lt;char,int&gt; mp;//一个字符对应一个整数 map的存储方式接下来看它们的存储方式： 1234567891011121314int n,x;scanf("%d",&amp;n);map&lt;int,int&gt;mp;for(int i=0;i&lt;n;i++)&#123;//输入n个数，每个数出现的次数进行统计 scanf("%d",&amp;x); mp[x]++;//mp[x]中， x代表上面的第一个int;mp[x]的值即为第二个int，初始值为0 &#125;char s;map&lt;char,int&gt;mp2;for(int i=0;i&lt;n;i++)&#123;//输入n个字符，每个字符出现的次数进行统计 scanf("%c",&amp;s); mp2[s]++;//mp2[s]中， s代表上面的第一个char;mp2[x]的值即为第二个int，初始值为0&#125; map的使用使用就是直接使用： 123int a;scanf("%d",&amp;a);printf("%d",mp[a]);//输出数字a出现的次数 因此，map主要作用就是计数（数字的个数、字符的个数、字符串的个数都可以计算），map&lt;…,…&gt;中，前面是记的元素，就像是数学函数f(x)中的x，后面一个数据类型，就是函数f(x)中的f(x)。 接下来看一个示例： 12345678910111213141516171819202122/*输入n,m。表示输入n个数接下来m次询问，每次输入一个数，输出这个数出现的次数 */#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;int,int&gt;mp; int n,m,x,a; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); mp[x]++; &#125; while(m--)&#123; scanf("%d",&amp;a); printf("%d\n",mp[a]); &#125; return 0;&#125; 关于map中其他元素的计数方式可以下去自行进行探索。 setset的内部结构和map类似，set的主要作用是对输入的元素进行去重和排序。 123456789101112131415int n,x;set&lt;int&gt;se;scanf("%d",&amp;n);for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); se.insert(x);//向se中插入x&#125;for(set&lt;int&gt;::iterator it=se.begin();it!=se.end();it++)&#123; printf("%d\n",*z);&#125;/*iterator是STL中的迭代器，其主要功能为遍历形如vector ,map,set等数据结构的所有元素 迭代器是一种检查容器内元素并遍历元素的数据类型。C++更趋向于使用迭代器而不是下标操作，因为标准库为每一种标准容器（如vector）定义了一种迭代器类型，而只用少数容器（如vector）支持下标操作访问容器元素。*/ 这个输出就是输入的元素去重过后的升序序列。 接下来说几个set中常用操作 1234567891011121314//下面几个使用比较多，需要掌握se.insert()//插入操作se.begin()//返回指向第一个元素的迭代器se.end()//返回指向最后一个元素的迭代器se.empty()//检查se是否为空，空的话返回true，非空的话返回falsese.clear()//清空所有元素//下面这些用的不多，可以了解了解se.count() 返回某个值元素的个数se.erase() 删除集合中的元素se.find() 返回一个指向被查找到元素的迭代器se.max_size() 返回集合能容纳的元素的最大限值se.size() 集合中元素的数目se.swap() 交换两个集合变]]></content>
      <categories>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度的计算及其他补充知识]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%8F%8A%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[时间复杂度时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。（来自百度百科） 时间复杂度最重要的一句话也就是上面加粗的这一句。 我们学习算法的目的就是使用算法使解决问题的时间复杂度尽量的小，就对于排序算法来说，排序有许多种方法，对于初学者来说，最简单的就是冒泡排序 123456789101112int a[maxn];int temp,n;for (j = 0; j &lt; n - 1; j++) for (i = 0; i &lt; n - 1 - j; i++) &#123; if(a[i] &gt; a[i + 1]) &#123; temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; &#125; &#125; 可以看出，两层循环的情况下，里面的 if()语句总共运行了n*(n-1)/2次。展开最高项次数为2,因此时间复杂度为O(n^2)。 再看一个判断质数的代码： 12345678910111213141516171819int n,i;scanf("%d",&amp;n);//时间复杂度O(n) 从定义出发：因子只有1和其本身，因此循环判断是否有其他因子for(i=2;i&lt;n;i++)&#123; if(n%i==0)&#123; break; &#125;&#125;if(i==n) printf("is prime\n");else printf("isn't prime\n");//时间复杂度O(√n) 从因子的角度出发，如果在√n之前没有其他因子，那么之后也不会再有了for(i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; break; &#125;&#125;if(i==n) printf("is prime\n");else printf("isn't prime\n"); 上面就是两个判断质数的时间复杂度的区别。 注意：上述循环中的结束条件( i &lt; n , i * i &lt;=n ) 均与 n 的值有关，在计算复杂度时，我们一般只考虑输入的值对代码时间的影响，比如如下面几个代码： 123456789101112131415int n;scanf("%d",&amp;n);for(int i=0;i&lt;100000;i++)&#123; printf("Hello world\n");&#125;for(int i=0;i&lt;10000;i++)&#123; for(int j=0;j&lt;i;j++)&#123; printf("Hello world\n"); &#125;&#125; while(1)&#123; printf("Hello world\n");&#125; 这几个代码的时间复杂度均为O(1)，因为不管输入为任何值，对这一部分代码的运算不会有任何影响。 所以当我们考虑时间复杂度时，只考虑与输入相关的部分，但在做题时，要考虑这一部分代码对整体时间使用的影响。 然后看接下来的代码： 123456789//计算n的二进制位数int n;scanf("%d",&amp;n);int sum=0;while(n&gt;0)&#123; n/=2; sum++;&#125;printf("%d\n",n); 这个代码的复杂度为O( log(n) )，其中log的底数一般不写，这是在做题时可能遇到的比较低时间复杂度。 接下来看这个代码： 123while(~scanf("%d",&amp;n))&#123; printf("%d",n*n);&#125; 这个代码的时间复杂度为O(1)，因为我们前面说过忽略常数的影响，在OJ系统中，如果说多组输入，那么我们在计算复杂度时只需要考虑单组的时间复杂度。 但是这个代码： 123456int t,n;scanf("%d",&amp;t);while(t--)&#123; scanf("%d",&amp;n); printf("%d\n",n*n);&#125; 这个代码的时间复杂度为O( t )，因为 t 是一个输入的变量，是可以改变的变量，所以我们在计算时间复杂度是需要计算上 t 对代码的影响。 虽然有些代码时间复杂度并不高，但在做题时，如果常数比较大，那么在写代码时仍要注意常数给代码带来的影响。 一般情况下，OJ评测机的每秒运算次数大概为 1e8~1e9 次。 空间复杂度空间复杂度和时间复杂度是相对应的，空间复杂度为输入的变量对空间的要求，一维数组为O( n ) ，二维数组为O(n^2)或O(n*m)等多种形式，一般情况下，代码的数组大小最好在1e8之下，否则，内存就会超限，导致虽然代码正确，但是并不通过的情况发生。 OJ常见评测结果Accepted答案正确！多么完美的返回结果！ #### Wrong Answer答案错误！一定是评测机坏了！本地对了就是对了，OJ上错误说明OJ肯定有问题！ Compile Error编译错误。语言不小心选错了？哦，少复制了一点代码。 此处顺便@某过气OJ。 Time Limit Exceed时间超限。一定是评测机太慢了！ Memory Limit Exceed内存超限。扣死了，内存都不会弄多点，这点内存都不舍得给我！ Presentation Error格式错误。不就多个空格，多个换行吗，又看不见那些字符，真是小心眼！ System Error系统错误。辣鸡评测机，辣鸡OJ！ Output Limit Exceed输出超限。我不是怕你看不懂吗，多输出点给你解释一下我的答案嘛！ Runtime Error运行错误。不就不小心除以零了嘛，就当我又创造了一门数学嘛！啊？数组下标越界了？我就是放这个变量出去数组外面玩了一会嘛。 在刷题的足够多之后，一些超限问题或者运行错误等就会减少，剩下的就只有（听取）WA（声一片）了。哈哈哈哈哈。 常见刷题OJ杭州电子科技大学 ( 杭电 ) OJ : acm.hdu.edu.cn ( 第11页之后有大量中文题目 ) codeforces : codeforces.com (一起来肝cf啊！) 洛谷：luogu.org vj : vjudge.net (Virtual Judge，可以在这里创建比赛)]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[尺取+二分]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%B0%BA%E5%8F%96%2F</url>
    <content type="text"><![CDATA[尺取-问题引入尺取，顾名思义，就是像尺子一样取一段区间，来快速高效地找到你想要的区间。 接下来看一个题目： 给定一个长度为n的数列a1,a2,…,an及整数S,求不小于S的连续子序列的和的最小值 通俗一点来讲，求 min ( 区间和 ) 且 区间和 &gt;= S。 暴力的情况下，总共有n*(n+1)/2个非零区间，如果我们对每一个区间都进行计算，那么时间复杂度为O（n^2）。对于n比较大的情况，暴力肯定会超时。（事实上，几乎所有的此类题目n都在 1e5~1e6左右） 因此我们就需要更高效的算法来进行求解。 接下来我们进行一下思考： 假如区间 [ l , r ]（l &lt;= r） 的和小于S，那么对于区间[ l + i , r ] ( l + i &lt;= r )肯定也小于S，也就是说，假如一个区间不符合题意，那么它的子区间肯定也不符合题意。因此，我们就可以在这个基础上减少许多的多余的计算。 看懂了上面的思考部分，我们就可以开始尺取的讲解了。 尺取 我们设置两个变量 l , r ，表示当前我们所计算的区间 [ l , r )，初始 l = r = 0（我的数列第一个存储下标为0）。 然后我们开始移动 r , 使 r 逐渐变大，直到区间 [ l , r )的和不小于S（这里就用到了上面思考部分的知识，如果区间 [ l , r )的和小于S，那么其子区间就完全没有了计算的必要）。 当 [ l , r )不小于S时，我们开始移动 l ，使区间慢慢变小，然后继续计算当前区间的值。直到区间和又一次小于S 这里又用到了之前思考部分的知识，在运行第三步时，我们已知 [ l , r - 1 )不符合要求，那么所有的 [ l+i , r-j )（l &lt;= l + i &lt;= r - j &lt; r）均不符合要求，也就是说，如果我们这个时候缩了一下 r 的值，那么肯定是不符合要求的，但是， [ l + i , r )却是可能符合要求的，因为[ l + i , r )并不在我们的否定区间内，所以我们要继续对它进行计算判断。 当 r = n 时，结束运算。 代码如下： 1234567891011121314151617181920int n,s;int a[maxn];void solve()&#123; int l=0,r=0,sum=0;//sum为当前区间和 int res=INF; while(r&lt;n)&#123; sum+=a[r];//扩大区间 r++; /*这个while是代码的核心，题目上给的约束条件就是用while进行判断， 因此只要确定了while里面的内容，就可以轻易地求解尺取的相关问题 */ while(sum&gt;=s)&#123;//这一步原本应为先判断sum是否&gt;=s,但由于while的特性，可以直接省略 res=min(res,sum);//求出当前区间和是否更接近s sum-=a[l];//缩小区间 l++; &#125; &#125; printf("%d\n",res);&#125; 这样，我们就可以把时间复杂度缩小到O(n)了。 这是尺取最基本的一类解决问题，其他形式的尺取问题也基本依靠于这个主要思想。 二分-问题引入二分，顾名思义，就是用二分的方法找出答案。 接下来看一个题目： 农夫 John 建造了一座很长的畜栏，它包括N (2 &lt;= N &lt;= 100,000)个隔间，这些小隔间依次编号为x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000). 但是，John的C (2 &lt;= C &lt;= N)头牛们并不喜欢这种布局，而且几头牛放在一个隔间里，他们就要发生争斗。为了不让牛互相伤害。John决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是什么呢？ Input 有多组测试数据，以EOF结束。 第一行：空格分隔的两个整数N和C 第二行——第N+1行：分别指出了xi的位置 Output 每组测试数据输出一个整数，满足题意的最大的最小值，注意换行。 这个题就是经典的二分题目，暴力的做法就是直接 for 循环找到满足条件的最小的值。但是肯定是要超时的。 那么我们怎么就需要更高效的方法了。 二分 我们可以看出来，假设一个值 x（x是牛的距离） 不能使c头牛完全分配（即在距离为x的情况下隔间内放不下c头牛），那么比 x 大的值更不可以了；相反的，如果 x 能使c头牛完全分配（可行解，非最优解），那么比 x 大的值也可能使c头牛完全分配，从而最小距离也会变得更大。 理解了上面的方法，就可以像尺取一样找到可能的答案了。 这里说一句，对于二分题而言假设答案可能的取值区间为 [ 1 , x ] ,那么对于区间里面的每一个值是否是可行解一定是{可行，可行，…..，可行，不可行，……，不可行，不可行}这样的值规律（不排除全部可行或全部不可行的情况）。如果题目不是这样的规律，那么就无法使用二分的方法求解。 代码如下： 12345678910111213141516171819202122232425262728int n,c;int x[maxn];bool check(int s)&#123;//这个用到了贪心的思想 int sum=1;//初始一个隔间为a[0]，不进行计算 int pos=x[0];//pos是用来记录当前可行的最近的隔间的位置 for(int i=1;i&lt;n;i++)&#123; if(x[i]-pos&gt;=s)&#123;//这里判断当前隔间距离上一个隔间的距离是否不小于s pos=x[i];//当前位置可以放置牛，因此就把pos的值更新为当前隔间的位置 sum++; &#125; &#125; if(sum&gt;=c) return true; else return false;&#125;void solve()&#123; sort(x,x+n); int l=1,r=(x[n-1]-x[0])/(c-1);//由于需要放c头牛,最大距离为(x[n-1]-x[0),因此每头牛之间的距离最大就为(x[n-1]-x[0])/(c-1) 向下取整。 while(l&lt;=r)&#123; int mid=(l+r)/2; if(check(mid))&#123;//当前为可行解 l=mid+1;//由于为可行解，因此即使mid+1不为可行解，l的值也不会再改变，因此最后l的值为第一个不可行解 &#125; else&#123; r=mid-1; &#125; &#125; printf("%d\n",l-1);&#125;]]></content>
      <categories>
        <category>尺取</category>
      </categories>
      <tags>
        <tag>尺取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂+矩阵快速幂]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%BF%AB%E9%80%9F%E5%B9%82-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[快速幂顾名思义，快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)， 与朴素的O(N)相比效率有了极大的提高。 以a^b为例，假设b=11，则$$a^{11}=a^{2^{0}+2^{1}+2^{3}}$$因为11的二进制为1011，11=2^0 +2^1+2^3,所以可得上式。 所以我们只要判断幂的二进制的值，就可以计算在log()级别的时间求解出答案。 12345678910int mod;int mulpow(int a,int n)&#123;//求a^n int res=1; while(n&gt;0)&#123; if(n&amp;1) res=res*a%mod;//如果当前位为1，则进行计算 a=a*a%mod;//a^(2^i),i为循环次数 n/=2; &#125; return res;&#125; 函数中间的运算数可能超过int的范围，所以当我们使用时要注意数据范围而选取适当的数据类型(int,long long)。 矩阵快速幂矩阵快速幂思想和快速幂一样，只不过由单纯的数字运算变成了矩阵运算（这里需要了解矩阵的运算方法）。 使用矩阵快速幂的场合一般为知道递推式，求解相应的第n项的值。 下面以这个式子为样例，来进行矩阵快速幂的讲解。$$a_{n}=2*a_{n-1}+1$$我们用这个式子构造一个矩阵：$$\left[ \begin{matrix} a_n \\ 1 \end{matrix}\right]=\left[ \begin{matrix} 2 &amp; 1 \\ 0 &amp; 1 \end{matrix} \right] *\left[ \begin{matrix} a_{n-1}\\ 1 \end{matrix}\right]$$如果没学过矩阵运算的相关知识，可以去百度进行学习。 然后我们继续递推：$$\left[ \begin{matrix} a_{n-1} \\ 1 \end{matrix}\right]=\left[ \begin{matrix} 2 &amp; 1 \\ 0 &amp; 1 \end{matrix} \right] *\left[ \begin{matrix} a_{n-2}\\ 1 \end{matrix}\right]$$ $$…$$ $$\left[ \begin{matrix} a_2 \\ 1 \end{matrix}\right]=\left[ \begin{matrix} 2 &amp; 1 \\ 0 &amp; 1 \end{matrix} \right] *\left[ \begin{matrix} a_{1} \\ 1 \end{matrix}\right]$$ 所以$$\left[ \begin{matrix} a_n \\ 1 \end{matrix}\right]={\left[ \begin{matrix} 2 &amp; 1 \\ 0 &amp; 1 \end{matrix} \right]}^{n-1} *\left[ \begin{matrix} a_{1}\\ 1 \end{matrix}\right]$$所以我们只需要求出中间的矩阵的结果就可以求出答案。 其大致步骤和快速幂一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct node&#123; int x[5][5];//一般构造的矩阵大小不会超过5，大小根据情况而定 &#125;;int mod,n,a1;node ope(node a,node b)&#123;//注意函数返回类型为 node,下面的 mulpow()函数返回类型同样是 node; node r; for(int i=0;i&lt;2;i++)&#123; for(int j=0;j&lt;2;j++)&#123; r.x[i][j]=0; for(int k=0;k&lt;2;k++)&#123;//这里是矩阵乘法的运算方法 r.x[i][j]+=a.x[i][k]*b.x[k][j]; &#125; &#125; &#125; return r;&#125;node mulpow(node a,int n)&#123; //这里用到了一个知识，一个矩阵乘以单位矩阵结果仍为原矩阵，所以这一步相当于快速幂里面的 res=1，具体详见百度百科 单位矩阵 node res; for(int i=0;i&lt;2;i++)&#123; for(int j=0;j&lt;2;j++) if(i==j) res.x[i][j]=1; else res.x[i][j]=0; &#125; while(n&gt;0)&#123; if(n&amp;1) res=ope(res,a); a=ope(a,a); n/=2; &#125; return res;&#125;void solve()&#123; //构造需要求幂的初始矩阵 node a; a.x[0][0]=2; a.x[0][1]=a.x[1][1]=1; a.x[1][0]=0; node s=mulpow(a,n-1); //最后一步矩阵乘法,参考前面最后展示的一个的矩阵 int res = s.x[0][0] * a1 + s.x[0][1]; printf("%d\n",res);&#125; 矩阵乘法也几乎是模板，其难点在于矩阵的构造，给你一个递推式，你必须推出相应的矩阵才可以进行运算，因此需要多学习一些矩阵的知识。 接下来展示一个Fibonacci的递推矩阵： Fibonacci的定义式：$$F(1)=f(2)=1\F(n)=F(n-1)+F(n-2) (n&gt;2)$$ 递推矩阵：$$\left[\begin{matrix} F(n)\\ F(n-1)\end{matrix}\right]=\left[\begin{matrix} 1 &amp; 1\\ 1 &amp; 0\end{matrix}\right]*\left[\begin{matrix}F(n-1)\\F(n-2)\end{matrix}\right]$$虽然这这个矩阵的第二个运算式子 F( n - 1 )=F( n - 1 ) 看起来是废话，但我们构造矩阵的目的是合理性，只要矩阵符合条件，就可以进行计算。 计算这个式子时需要注意矩阵快速幂的指数。 相关题目可以百度进行搜索。]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[简介并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 简而言之，并查集就是将一些具有一定关系的元素进行合并，以此来减少查询的时间。 并查集是基于树形结构的数据而使用的。 问题提出接下来看一个题目： 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input 测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最少还需要建设的道路数目。 这个题就是经典的并查集。可以看出，当两个城镇互相联通（直接或间接）时，这两个城镇之间就不需要再进行任何道路建设。所以我们需要找出有多少个城镇集合是互不联通的。 如何说明和标记两个城镇是否互相联通？解决这个问题，就是我们的最终目的。 并查集给出一个上面题目的一个样例： 5 2 1 2 3 5 它所对应的图形为： 如果仅仅从图片上看，我们很明显的可以看出来答案是2。 由于所有元素各不相同，对于每个集合，总会有一个最小值，而我们一般把这个最小值作为每个集合的根节点。 以上图为例，1,2,3,4,5对应的根节点分别为 1,1,3,3,4。总共有3种根节点，因此答案为3-1=2； 也可以说，总共有3个元素对应的根节点是其本身。 并查集的作用就是是每个集合里面的元素都找到其对应的根节点。 当我们合并两个元素时，这两个元素可能并不是自己所在集合的根节点，因此我们需要找到其对应的根节点，然后将两个根节点进行合并。 网上有一个很形象的比喻： 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？ 我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。 但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1000+10;const int INF=0x3f3f3f3f;int n,m,u,v;int dep[maxn];void init()&#123;//刚开始每个节点的根节点都是其本身 for(int i=1;i&lt;=n;i++)&#123; dep[i]=i; &#125;&#125;int find(int x)&#123; if(x!=dep[x]) dep[x]=find(dep[x]);//这个的作用就是递归找到最后的根节点 return dep[x];&#125;void Union(int x,int y)&#123;//将两个元素进行合并，两个根节点不一样，就将两个根节点进行合并，大的合并到小的根节点上 int dx=find(x); int dy=find(y); if(dx&lt;dy) dep[dy]=dx;//将大的合并到小的上面 else dep[dx]=dy;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); init(); for(int i=0;i&lt;m;i++)&#123; scanf("%d %d",&amp;u,&amp;v); if(find(u)!=find(v)) Union(u,v);//如果两个元素根节点不一样，就进行合并 &#125; int res=0; for(int i=1;i&lt;=n;i++)&#123;//统计总共有多少个根节点，即集合 if(dep[i]==i) res++; &#125; printf("%d\n",res-1); return 0;&#125; 按照上面的例子，函数init()就是创造一个最初的江湖，find()就是用来找到自己的队长，Union()就是来将两位大侠所在的队伍结盟。对于一个队伍来说，队伍的操作只能由队长来进行，所以我们最后只需要将两个队长串联起来就可以了。]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2019%2F03%2F02%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背包问题是很经典的dp问题，在许多基础的比赛中都会用到。可以这样说，背包问题就是学习dp的第一步，但是其难度对于初学者来说也并不小。 这篇文章主要介绍一下基础的01背包和完全背包。 01背包01背包是最简单的背包问题，其大致描述为： 有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。 二维dp这里我们用一个二维数组dp[maxn][maxn] 来求解背包问题。 其中第一维表示前 i 个物品，第二维表示前 i 个物品在容量为 j 时的最大价值总和。 这里有一个状态方程： 1dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); dp[ i ][ j ]上面说过，表示的是前 i 件物品在容量为 j 时的最大价值，那么得到dp[ i ][ j ]，其中就涉及到了关于第 i 件物品选和不选的问题。 当我们选择第 i 件物品时，总容量为 j ，我们需要腾出来 w[ i ] 的空间来装第 i 件物品，因此得出当选择第 i 件物品时的最大价值 dp[ i - 1 ][ j - w[ i ] ] + v[ i ]。 当我们不选择第 i 件物品时，那么之前的容量也必然为 j ，因为没有东西放进去，所以我们可以得到当不选择第 i 件物品时的最大价值 dp[ i - 1 ][ j ]。 理解了方程的意义，我们就可以写出来解决背包问题的代码了。 123456for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=V;j++)&#123; if(j&lt;v[i]) dp[i][j]=dp[i-1][j];//容量太小，装不下第 i 个物品 else dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]); &#125;&#125; 最终求出来的dp[N][V]即为答案。 这是用二维数组来求解最大价值。我们如果在纸上模拟这个过程，会发现在两层 for 循环的情况下，每个位置的值只会变化一次，当第 i 行求解完之后，我们就再也不会改变第 i 行的值了。 那么这对空间的要求是巨大的，我们是否可以把二维数组压缩成一位数组？答案是可以！ 一维dp我们如果在纸上模拟这个过程，会发现在两层 for 循环的情况下，每个位置的值只会变化一次，当第 i 行求解完之后，我们就再也不会改变第 i 行的值了。 上面的代码过程用图像可以表示为： 从上面代码和图片中可以看出，影响dp[ i ][ j ]的值为 dp[ i - 1][ j ] 和dp[ i - 1 ][ j - w[ i ] ]，两个数的一维二维坐标均小于等于 i , j ，所以我们第一步先改变一下循环的顺序： 123456for(int i=1;i&lt;=N;i++)&#123; for(int j=V;j&gt;=1;j--)&#123;//这里的循环顺序改变了 if(j&lt;v[i]) dp[i][j]=dp[i-1][j]; else dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]); &#125;&#125; 如果表示成一维的话，那么过程就变成了： 可以发现，此时代码中 if(j&lt;v[i]) dp[i][j]=dp[i-1][j] 已经失去了原本的作用。 然后将二维数组压缩成一位数组： 12345for(int i=1;i&lt;=n;i++)&#123; for(int j=V;j&gt;=w[i];j--)&#123;//根据上面的代码，这里假如j&lt;w[i]时，dp[j]=dp[j],可以直接省略 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125;&#125; 在这里可能有人疑问，为什么循环顺序要变化？ 当我们从前往后改变一维数组的值时，我们可能会改变了后面的数的正确的值，因为后面的数还会用到前面的是，从而导致最终结果偏离正确结果。 所以我们选用从后往前的方式进行遍历，前面已经说过，影响这个元素的值一维二维坐标均小于当前坐标，所以即使我们改变了后面的数值，也不会对前面的值有影响。 这样，我们就可以节省大量的空间（还在第二层循环时减少了时间）。 完全背包 有N种物品和一个容量为V的背包。第i种物品的重量是w[i]，价值是v[i]。每种物品都可以无限件使用。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。 完全背包和01背包最大的区别就是物品件数的改变。完全背包每种物品可以无限次使用，而01背包只是用一次。 我们再来看一下01背包一维dp时循环顺序的问题。 上面已经说过，假如第二层for循环的顺序是j++，那么最终结果会偏离正确结果。但是是怎么偏离的呢？我们继续深入探讨一下。 假如dp[ j ]&lt;dp[ j - w[ i ] ] + v[ i ] ，那么dp[ j ]=dp[ j - w[ i ] ] + v[ i ]， 然后对于 k ( j &lt; k &lt;= V)，如果dp[ j ]影响到了dp[ k ] ，那么影响的结果一定是dp[ k ] = dp[ k - w[ i ] ] + v[ i ],其中 k - w[ i ] = j ( 只考虑直接影响 )， 所以我们可以继续递推得出dp[ k ] = dp[ j - w[ i ] ] +v[ i ] +v[ i ]=dp[ j - w[ i ] ] + 2 * v[ i ]。 这里我们就发现，v[ i ]被使用了两次，这在01背包中肯定是错误的，但是在完全背包中却没有任何问题，因为每件物品可以无限次使用，因此我们就可以得出完全背包的求解方法： 12345for(int i=1;i&lt;=n;i++)&#123; for(int j=w[i];j&lt;=V;j++)&#123; dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125;&#125; 这和01背包的区别只在于第二层循环的顺序。]]></content>
      <categories>
        <category>背包</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长单调子序列]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[最长上升子序列（LIS） 问题描述： ​ 给你一个序列，让你求出其中的最长的上升子序列。 ​ 比如数组{1,5,3,2,4},其最长递增子序列为{1,3,4}或{1,2,4}。 dp求解（小范围数据）在长度 n 较小的情况下，我们可以用dp的方式来求解，复杂度为O(n^2) : 1234567891011121314int n;int dp[maxn];int a[maxn]; int LIS()&#123; int res=0; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(a[i]&lt;a[j]) dp[j]=max(dp[j],dp[i]+1); //如果是最长非递减的话，则if(a[i]&lt;=a[j]) &#125; res=max(res,dp[i]); &#125; return res+1;&#125; 这个理解起来还算容易：当我们求出前m（m&lt;=n）个数的LIS长度时，那么我们就可以求出当前状态下m后面的数的最长长度。 因为m和m+1之间没有其他的数字，所以我们可以认为我们求出了前m+1个数的LIS长度。 然后依次递推，就可以求出n个数的LIS。 dp求解（大范围数据）当n比较大时,O(N^2)的时间复杂度明显没办法满足需要，所以我们需要更高效的方法。 当我们循环遍历时，我们可以把当前的最长的LIS存储下来。 对于样例{1,5,3,2,4}，我们储存的顺序依次为： {1}， {1,5} {1,3} {1,2} {1,2,,4} 这个刚开始理解起来比较难理解。对于第二步{1,5}来说，当前的LIS长度为2，由LIS的特性可知，我们希望前面的元素尽量的小。 所以当遍历到第三个元素时，由于{1,5}，{1,3}长度均为2，但我们更希望值小一点，所以我们就用3来代替了5的值。 第四个元素也一样。 第五个元素{4}，由于当前我们保存的LIS{1,2}最大值小于4，因此我们就把4放进来，所以最终结果就为3。 注意：储存的元素并不是LIS的值，这个储存的值只是用来寻找LIS的。 再来看一个样例：{1,3,5,4,6,2}，存储的顺序依次为： {1} {1,3} {1,3,5} {1,3,4} {1,3,4,6} {1,2,4,6} 对于第6步，因为2&lt;6，所以我们一定能找到替换2的元素。而我们希望储存的序列尽可能的小，所以我们需要找到2能替换的最小的元素。因此我们的替换操作为3 -&gt; 2。 这一步可以理解为：找到储存的序列中比当前元素大（或者相等）的第一个元素，进行替换。 因为我们在储存时保证了储存的元素单调，因此我们在寻找替换位置时可以用高效的二分法，所以这种方法的复杂度为O( n*log(n) )。 12345678910111213141516171819202122232425int n;int dp[maxn];int a[maxn];int find(int x)&#123; int l=0,r=n-1,mid; while(l&lt;r)&#123; mid=(l+r)/2; if(dp[mid]&lt;x)&#123;//小于的话肯定不是被替换的元素，因此可以+1 l=mid+1; &#125; else&#123;//大于等于的情况下这个元素可能是被替换的元素，所以我们不能忽略这个元素 r=mid; &#125; &#125; return l;&#125;int LIS()&#123; fill(dp,dp+n,INF);//将dp里面的元素全部替换为INF for(int i=0;i&lt;n;i++)&#123; int pos=find(a[i]); dp[pos]=a[i]; &#125; int res=find(INF); return res;&#125; 输出LIS的元素在前面已经说过，储存的值并不是LIS的元素，那么我们如何来输出LIS呢？ 前面已经说过，我们的操作都是找到储存的序列中第一个比当前元素大（或者相等）的位置，那么这个元素的前面一个元素一定是它左边的那个元素，因此我们需要用一个数组来储存每个元素的前驱。 因此我们在上面的代码上做一些小修改： 1234567891011121314151617181920212223242526272829303132int n;int dp[maxn];int a[maxn];int pre[maxn];//用来记录每个元素的前驱void output(int x)&#123;//用来输出LIS的元素（可能有多个答案，这里只取其中一种） if(pre[x]!=0) output(pre[x]); printf("%d ",x);&#125;int find(int x)&#123; int l=0,r=n-1,mid; while(l&lt;r)&#123; mid=(l+r)/2; if(dp[mid]&lt;x)&#123;//小于的话肯定不是被替换的元素，因此可以+1 l=mid+1; &#125; else&#123;//大于等于的情况下这个元素可能是被替换的元素，所以我们不能忽略这个元素 r=mid; &#125; &#125; return l;&#125;int LIS()&#123; fill(dp,dp+n,INF);//将dp里面的元素全部替换为INF for(int i=0;i&lt;n;i++)&#123; int pos=find(a[i]); dp[pos]=a[i]; pre[ dp[pos] ]=dp[pos-1];//当前元素所对应的前一个元素的值。 &#125; int res=find(INF); output(dp[res-1]); return res;&#125; 这样，我们就可以输出LIS的元素了。 最长下降子序列（LDS)最长下降子序列求解方法和LIS相似，只需要把元素的位置翻一下即可求解。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD与LCM及其部分性质]]></title>
    <url>%2F2019%2F02%2F01%2FGCD%E4%B8%8ELCM%E5%8F%8A%E5%85%B6%E9%83%A8%E5%88%86%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[GCDGCD，即最大公约数，指两个或多个整数共有约数中最大的一个。 求最大公约数有多种方法，常见的有质因数分解法、短除法、辗转相除法、更相减损法。 在一般竞赛中，求GCD一般使用辗转相除法。其复杂度约为O(log(max(n,m)))，是一种很高效的算法。而且其代码量也非常少 1int gcd(int a,int b) &#123; return b ? gcd(b,a%b) : a; &#125; 拓展性质如果GCD( n , a ) = 1 , n&gt;a 则GCD( n , n - a ) = 1。 可以用反证法证明 假设GCD( n , n - a ) = i ( i &gt; 1 )，设 n = k1 * i，n - a = k2 * i（ k1 &gt; k2 &gt; 0 ）， 则 n -( n -a ) = a = (k1-k2) * i，与GCD( n , a ) = 1 矛盾，所以上述性质成立。 扩展欧几里得算法设a , b为常数，对于一个表达式 a * x + b * y =GCD( a , b ) ，一定存在解（ x , y）使之成立。 我们就可以通过扩展原来的辗转相除法来求解。 求解的过程如下（最好自己手推一下）： 初始表达式$$a * x + b * y =GCD( a , b )$$由之前的知识可得$$GCD( a , b ) =GCD( b , a \% b )$$因此$$a*x_1+b*y_1=GCD( a , b ) =GCD( b , a\%b ) =b*x_2+(a\%b)*y_2$$ $$a\%b=a-[a/b]*b$$ 其中[a/b]表示整除。带入化简可得：$$a*x_1+b*y_1=a*y_2+b*(x_2-[a/b]*y_2)$$由恒等关系可得$$x_1=y_2$$ $$y_1=x_2-[a/b]*y_2$$ 因此我们只要求出 x2 和 y2 的值就可以求解 x1 和 y1。而 x2 , y2 可通过同种方法求解。 特别的，当 b=0时，表达式为 a * x + b * y = GCD( a , b ) =GCD( a , 0 ) = 0 此时,可求得 x = 1 。y 的值对表达式的值没有影响。 上面就是求解初始表达式的方法。 代码如下： 12345678910111213int extGcd(int a,int b,int &amp;x,int &amp;y)//这里取 x , y的地址 &#123; if(b==0) &#123; x=1;y=0; return a;//函数的返回值一直是 gcd(a,b) &#125; int r=exGcd(b,a%b,x,y); int t=x; x=y; //x1=y2 y=t-a/b*y; //y1=x2-[a/b]*y2 return r;&#125; LCMLCM，即最小公倍数，指两个或多个整数共有倍数中最小的一个。 LCM的求法可以基于GCD的基础上：$$LCM(a,b)=a*b/GCD(a,b)$$证明略。 一般题目求解时使用GCD更多一些，所以LCM相关知识就不多写了。(我也没找到太多关于LCM的相关文献)]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>LCM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数及其部分性质]]></title>
    <url>%2F2019%2F02%2F01%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E9%83%A8%E5%88%86%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[欧拉函数欧拉函数在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。 从欧拉函数引伸出来在环论方面的事实和拉格朗日定理构成了欧拉定理的证明。 欧拉函数的适用范围非常大，许多题目中都会用到欧拉函数的性质。 欧拉函数表达式1：欧拉函数的表达为：$$\varphi (x)=x\prod_{i=1}^{n}{(1-\frac{1}{p_i})}$$ 其中p1,p2,…,pn 表示x的所有质因子，x是不为0的整数。 欧拉函数表达式2：假设$$x= {p_1}^{k_1} * {p_2}^{k_2} * … * {p_n}^{k_n}$$ p1,p2,…,pn同上，则其另一种表达为：$$\varphi(x)=\prod_{i=1}^{n}{(p_i-1)*p_i^{k_i-1}}$$ 特别的，$$\varphi(1)=1$$ 欧拉函数证明容斥定理来证明对于正整数 x 而言，假设其质因子为p1,p2,p3,…,pn，则小于等于 x 且与 x 不互质的数字的个数为：$$g(x)=\frac{x}{p_1}+\frac{x}{p_2}+…+\frac{x}{p_n}-\frac{x}{p_1*p_2}-\frac{x}{p_1*p_3}- …$$ 小于 x 且与 x 互质的数字的个数：$$f(x)=x-g(x)=n-\frac{x}{p_1}-\frac{x}{p_2}- … -\frac{x}{p_n}+\frac{x}{p_1*p_2}+\frac{x}{p_1*p_3}+ …$$ 化简即可得表达式1。（具体化简过程我也不会QAQ） 欧拉函数计算单值计算在编程时，习惯上，我们经常用表达式2计算欧拉函数的值： 12345678910111213141516171819int eular(int n)&#123; int ret=1,i; for(i=2;i*i&lt;=n;i++) &#123; /* n%i==0时，i为n的质因子，因为如果i不是质因子， 则一i定能分成更小的因子，对应的更小的因子一定在之前出现过了，与之矛盾， 所以i一定不能分割成更小的因子，即i为n的质因子。 */ if(n%i==0) &#123; n/=i,ret*=i-1; while(n%i==0) n/=i,ret*=i; &#125; &#125; if(n&gt;1) ret*=n-1; return ret;&#125; 打表计算欧拉函数性质互质数之和小于n的正整数中与n互质的数的数字之和为$$f(n)={n}*\frac{\varphi(n)}{2}$$ 证明如下： 对于每个小于 n 的数正整数 a ，如果gcd( n , a )=1,则gcd( n , n-a )=1（ 此处为gcd相关性质，不再证明。）。 所以对于每个与 n 互质的正整数 a ，一定有一个与之对应的与 n 互质数的 n - a ; 由此可知，欧拉函数的值总为偶数（1除外），并且总有一对之和为 n， 至此，小于n的正整数中与n互质的数的数字之和就可以计算出来了。 积性函数欧拉函数是一个积性函数，如果 n , m 互质，则：$$\varphi(nm)=\varphi(n)*\varphi(m)$$可以推出，如果n为质数，则：$$\varphi(2n)=\varphi(n)$$ 欧拉定理变式对于任何两个互质的正整数 a , n ，(n&gt;2)$${a}^{\varphi(n)}\equiv 1 mod n$$ 费马小定理当 n = p 且 a 与素数 p 互质时，上式可变为 $${a}^{p-1}\equiv 1 mod p$$ n的因数（包括1和它自己）的欧拉函数之和等于n写成数学表达式的形式即为$$n=\sum_{d|n}\varphi(d)$$其中 d|n 表示 n 能被 d 整除。 证明如下： 对于每个 x ( 0 &lt;= x &lt;= n ) 都存在一个gcd( x , n )，可以证得，其值必然为n的因子。 假设gcd( x , n ) = d ,（ d | n ） ，则gcd（ x / d , n / d ）= 1 ，即 x / d 与 n / d 互质。 因此，我们可以求出 gcd( x , n ) 的值为 d 时对应的的数字个数，个数就是 n / d 所对应的欧拉函数值。 由第一行可知，gcd( x , n )的值必然为n的因子，并且只有唯一对应值，因此就可推导出上述公式。]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2036（多边形面积）]]></title>
    <url>%2F2019%2F01%2F17%2FHDU-2036%2F</url>
    <content type="text"><![CDATA[题目大意： 给你一个多边形，求它的面积。 多边形面积可以用向量知识来求解。 对于一个凸多边形，如下： 其面积可以表示为 S = S△OAB+S△OBC+S△OCD+S△ODE 对于△OAB 其面积用向量表示为 0.5 * |OA| * |OB| * sin∠AOB=0.5 * | OA x OB| 其中OA x OB表示叉乘（非点乘，具体详见百度百科“向量积”） 但因为向量叉乘有正有负，所以我们取的是绝对值，保证题目答案的正负。（正负取决于两条边的位置状态） 这时候就可以简单的计算出多边形的面积。 对于一个 凹多边形，如下： 其面积依然就可以用向量的方法求解 假设点O为坐标原点，则 S = S△OAB+S△OBC+S△OCD+S△ODE+S△OEA S△OAB = 0.5 * OA x OB =0.5 * ( A.x * B.y - A.y * B.x ) 其中S均表示在叉乘意义下的值，由于其具有正负之分，所以可以用来计算凹多边形的面积（具体证明过程略）。 这时候就可以计算出多边形的面积。 代码如下： 12345678910111213141516171819202122232425# include&lt;bits/stdc++.h&gt;using namespace std;# define ll long longint main()&#123; int n,i; double a[1000]; double b[1000]; while(~scanf("%d",&amp;n) &amp;&amp; n)&#123; for(i=1;i&lt;=n;i++)&#123; scanf("%lf %lf",&amp;a[i],&amp;b[i]); &#125; a[0]=a[n]; b[0]=b[n]; double res=0; for(i=0;i&lt;n;i++)&#123; res=res+(a[i]*b[i+1]-b[i]*a[i+1])/2;//由于是逆时针方向，所以求出来结果为正。 &#125; printf("%.1lf\n",res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>多边形面积</category>
        <category>叉积</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广西大学第一届程序设计大赛-数论只会GCD]]></title>
    <url>%2F2019%2F01%2F16%2F%E5%B9%BF%E8%A5%BF%E5%A4%A7%E5%AD%A6%E7%AC%AC%E4%B8%80%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-D%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述 小西买了一堆肥宅快乐水和肥宅快乐茶，准备和室友比谁更肥宅。 快乐水有A瓶，快乐茶B瓶。 小西和室友的规则是这样的： 小西先手，轮流到每个人的回合，每个回合只能喝剩余数量较多的饮料 满足规则1的同时，每次只能喝另一种饮料剩余数量的正整数倍 满足1、2的同时，不能超额喝饮料，也就是说剩下2瓶的时候不能喝大于2瓶的数量。 每个人在自己的回合如果能喝完剩下的其中一种饮料，那么就获得胜利。 例如A=10，B=2。 小西只能喝快乐水，且只能喝2/4/6/8/10瓶快乐水。小西可以喝10瓶快乐水直接获得胜利。 小西和室友都是肥宅，所以他们都会才采取为了胜利最优的行动。 现在请你判断小西是否能赢得胜利。 输入描述: 第一行输入一个整数T，表示有T组数据 接下来T行，每行为一组数据，每行有两个正整数表示A和B的初始数量 1 ≤ T ≤ 500 , 1 ≤ A,B ≤ 10^12 输出描述: 对于每组数据，若小西可以获得胜利则输出一行“wula”，否则输出一行“mmp”，不需要输出引号 你真的会GCD吗 这道题其实就和求GCD的过程有关。 求GCD的过程就是GCD( a , b ) = GCD( b , a % b )，其过程就是把 a 减去 b 的正整数倍，然后依次递归求解。 那么对于这个题，最后的状态一定是一个数量为 0 ，一个数量为正整数。而逆推就可以得到题目给出的 A , B 值。 假设 A &lt; 2 * B,那么接下来的操作之后一定是（ A - B , B），接下来也一直持续这个过程，而且这个过程是可以一直递推求出来唯一解的。 假如 A &gt; 2 * B , 那么因为两人足够聪明，接下来的状态可以变为（ A , A%B）或者（ A , A % B + A ）。 可以看到，第二个状态只能有一种操作：（ A , A % B + A ）- &gt;（ A , A%B）,因此这个时候可操作的人就能够随意挑选这两种状态之一来掌握自己的胜负。 假设A % B=0 那就不多说了，直接就赢了。 代码如下： 12345678910111213141516171819202122232425262728293031# include&lt;bits/stdc++.h&gt;using namespace std;# define ll long longint main()&#123; ll t,a,b; scanf("%lld",&amp;t); while(t--)&#123; scanf("%lld %lld",&amp;a,&amp;b); ll flag=1;//用flag来记录当前的赢家，因为此时我们并不知道谁有主动权 while(true)&#123;//遇到可以判断赢家的条件时，循环就结束了 if(a&gt;b) swap(a,b); if(b%a==0) break; else if(a*2&lt;b) break; else&#123; flag*=-1; b=b-a; &#125; &#125; if(flag==1)&#123; printf("wula\n"); &#125; else&#123; printf("mmp\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>博弈</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数筛选法]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95%2F</url>
    <content type="text"><![CDATA[素数，是指因子只包含1和其本身的数，那么，我们怎么大批量的判断素数呢？ （以下代码均基于打表（1~1e6）的基础上完成） 1.按照定义计算素数的定义就是一个数的因子只包含1和其本身，那么我们直接就按照定义写： 12345678910111213141516171819202122# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int pri[maxn];int isprime(int n)&#123; for(int i=2;i&lt;n;i++) if(n%i==0) return 0; return 1;&#125;int main()&#123; pri[1]=0; for(int i=2;i&lt;=maxn;i++)&#123; pri[i]=isprime(i); &#125; return 0;&#125; 这是最基础的写法，也是最小白的写法。 这种算法的复杂度为O(n^2),复杂度非常的大，对于1e6的数据范围来说肯定要超时，那么还有没有更优化的算法？答案是肯定的 2.基于定义计算的优化算法我们对一个合数进行考虑，例如12： 它的因子有1 2 3 4 6 12 ，而且112=12 ， 26=12 ， 3*4=12 可见，每一个因子都会有另一个对应的因子，观察可得，它们的分布是平均的，左边的一半对应右边的一半，那么最中间的分界线应该是什么？ √n 。 因此，我们只需要对√n 前面的数字进行判断即可。 12345678910111213141516171819202122# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int pri[maxn];int isprime(int n)&#123; for(int i=2;i*i&lt;=n;i++)//只需要将i变成i*i即可 if(n%i==0) return 0; return 1;&#125;int main()&#123; pri[1]=0; for(int i=2;i&lt;maxn;i++)&#123; pri[i]=isprime(i); &#125; return 0;&#125; 这种算法的复杂度要比上一种好的多，复杂度为O(n√n),但是对于1e6的数据范围来说还是太大了。有没有再快一点的算法？ 3.素数筛选法素数筛选法的思想为： 从2开始，因为2的倍数一定不是素数，所以先把2的倍数全部删去； 接着找下一个素数3，把3的倍数全部删去； 因为4是2的倍数，已经被删去，所以直接找下一个素数5，把5的倍数全部删去； 接着7的倍数，11的倍数，……直到把1e6范围内的合数全部筛选出去，剩下的即为素数： //以下优化均基于打表的基础上 1234567891011121314151617181920212223242526# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int vis[maxn];void isprime()&#123; memset(vis,0,sizeof(vis));//此处vis[i]=1表示不是素数，vis[i]=0表示是素数 vis[1]=1; //由于i*i的数据范围可能会超过int，所以需要用long long表示 for(long long i=2;i*i&lt;=maxn;i++)&#123;//此处有优化，因为如果一个合数&gt;sqrt(maxn),那么他必定在前面已经被标记过。 if(!vis[i])&#123; for(long long j=i*i;j&lt;=maxn;j+=i)&#123;//此处也有优化，我们只需要判断从i*i开始判断即可。 vis[j]=1; &#125; &#125; &#125;&#125;int main()&#123; int n; isprime(); return 0;&#125; 这种算法的复杂度应该为O(n);，是一种非常快速的判断素数的算法。 上述代码有两处优化，第一处优化的证明如下： 假设 maxn &gt; i &gt; sqrt(maxn)并且为合数，那么，他肯定会有一个因子小于等于sqrt(maxn)，因此，i一定在之前已经被标记过了。 第二处优化证明为： 假设i&gt;2，那么对于 i * ( i - 1 )： 如果 i - 1是素数，那么 i * ( i - 1 ) 一定在之前已经被标记过； 否则，如果 i - 1 是合数，那么 i - 1能被分成更小的素数。设其中一个为a，那么 i ( i - 1 )= i ( i - 1 ) / a * a 也一定被标记过。 优化后的算法时间会节省非常多，在平常的算法竞赛中，用上述代码就已经可以解决大部分的涉及素数打表的问题。]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马小定理--轻松判断大质数]]></title>
    <url>%2F2019%2F01%2F09%2F%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86-%E8%BD%BB%E6%9D%BE%E5%88%A4%E6%96%AD%E5%A4%A7%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述在算法竞赛中你会遇到各种各样的有关素数的问题，今天你来解决一个最基础的问题：如何判定一个素数。对于给定的正整数p，若p非素数，输出-1若p是素数 输出 ：{sigma(a^(p-1) % p) ，其中a的下界为1，上界为p-1} 即： $$\sum_{a=1}^{p-1}({a^{p-1}\%p})$$输入 多实例测试，每组数据包含一个正整数p（p &lt; 10^16）。 输出 根据情况输出一个正整数，保证答案在int64之内，输出占一行。 样例输入 2 样例输出 1 这个题一般方法是就是暴力求解了，首先判断是不是素数，如果不是素数，那么输出-1，如果是素数，那么就实处上面那个式子的值。 但是题目要求的数据范围为1e16，如果我们用一般判断素数的方法（sqrt(n)）去求解的话，必定会超时，那么我们如何解决这个问题呢，费马小定理出现了。 费马小定理 假如p是质数，且gcd(a,p)=1，那么 a(p-1)≡1（mod p），例如：假如a是整数，p是质数，则a,p显然互质(即两者只有一个公约数1)，那么我们可以得到费马小定理的一个特例，即当p为质数时候， a^(p-1)≡1(mod p)。 因此，我们可以随机几个数字（与p互质），如果a^(p-1)≡1（mod p）对这些数字恒成立，那么p就是一个质数。 一般情况下，我们只需要列举十个左右的数字即可确定一个数字是否为质数。 代码如下： 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll n;ll gcd(ll a,ll b)&#123; return b?gcd(b,a%b):a;&#125;ll mulpow(ll a,ll x)&#123; ll res=1; while(x)&#123; if(x&amp;1) res=res*a%n; a=a*a%n; x&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll t,i; //以下是我自己列举的一些随机数，我们也可以用一些随机数函数来找一些随机数 ll a[20]=&#123;7,43,64,69,87,31,45,72,81,79,47,33,43,97,121,199,173,153,157,53&#125;; while(~scanf("%lld",&amp;n))&#123; for(i=0;i&lt;20;i++)&#123; if(gcd(a[i],n)==1 &amp;&amp; mulpow(a[i],n-1)!=1)&#123;//两个判断条件，两个数字互质且符合费马小定理 break; &#125; &#125; if(i==20)&#123; printf("%lld\n",n-1); &#125; else printf("-1\n"); &#125; return 0;&#125; 用以上方法即可迅速判断一个数是否是质数，对特别大的数字尤其适用。]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>费马小定理</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算数基本定理 + 容斥定理]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%AE%97%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86-%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[算数基本定理定义：任何一个大于1的自然数，如果N不为质数，那么N可以分解成有限个质数的乘积，并且在不计次序的情况下，这种分解方式是唯一的。 例如：60可以分解为 2^2 * 3 * 5 数学公式描述 N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn （P1&lt;P2&lt;P3&lt;…=0） 质因子分解计算方法 算法复杂度 ( O(√n) )123456789101112map&lt;int,int&gt; prime_factor(int n)&#123; map&lt;int,int&gt;ans; for(int i=2;i*i&lt;n;i++)&#123; while(n%i==0)&#123; ++ans[i]; n/=i; &#125; &#125; if(n!=1) ans[n]=1; return ans;&#125; 算数基本定理的应用如何求N有几个因子？ 根据算数基本定理：N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn 根据排列组合得到结果： ans=(1+r1) * (1+r2) * (1+r3) * … * (1+rn) 如何求N的所有因子之和？ 根据算数基本定理：N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn 求GCD(X,Y)和LCM(X,Y) 根据算数基本定理： X=P1^x1 * P2^x2 * P3^x3 * … * Pn^xn Y=P1^y1 * P2^y2 * P3^y3 *… * Pn^yn 根据GCD和LCM的定义 容斥定理要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分， 依此类推，一直计算到所有集合相交的部分。 用Venn图来表示 数学公式描述 如果要对n个物体进行选择，那么有多少种情况？ 代码复杂度为O(2^n) 123456for(int i=0;i&lt;(1 &lt;&lt; m);i++)&#123; for(int j=0;j&lt;n;j++)&#123; printf("%d",i&gt;&gt;j &amp; 1); &#125; puts("");&#125; 容斥定理的应用问题：魔镜给小明m个数字（a1、a2 …… am）和一个整数n，魔镜定义：如果有一个数，是这m个数字里面任意一 个数的倍数，那么这个数称为LuckyNumber。而小明会的题数为[1,n]闭区间内LuckyNumber的数量。 (0 &lt; m &lt; 15) 那么请你帮小明计算一下他会的题目数。 代码 复杂度为O(2^n) 123456789101112131415LL ans=0;for(int i=1; i&lt;(i&lt;&lt;m);i++)&#123; int cnt=0; LL LCM=1; for(int j=0;j&lt;m;j++)&#123; if(1&amp;(i&gt;&gt;j))&#123;//按位运算判断第m个数是否使用 cnt++; LCM=lcm(LCM,a[j]); &#125; &#125; if(cnt&amp;1) ans+=n/LCM;//判断n中元素使用的个数，奇加偶减 else ans-=n/LCM;&#125;printf("%lld\n",ans);]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算数基本定理</tag>
        <tag>容斥定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS与DFS]]></title>
    <url>%2F2019%2F01%2F08%2FBFS%E4%B8%8EDFS%2F</url>
    <content type="text"><![CDATA[BFS(宽度优先搜索)宽度优先搜索算法（又称广度优先搜索算法）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。 他并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。 举例： 由橙色位置出发，进行BFS： ​ 灰色位置表示已经走过，橙色标示当前位置 首先进行第一步： ​ 已经走过的位置，不需要再走了 进行第二步： ​ 同上，状态继承，进行第三步： ​ 进行第四步，到达终点，当前步数表示最小步数： ​ 对于一个迷宫而言，我们要进行的步骤是一样的。 ​ 蓝色是起点，红色是终点，黑色为障碍物。 第一步，我们可以走以下几步： ​ 接下来依次为： 当我们走到第十步时，走到了终点，因此，从起点到终点最少的步数即为10步。 接下来看一道基础的例题（HDU1242）Rescue： Problem Description Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison. Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards. You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.) Input First line contains two integers stand for N and M. Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend. Process to the end of the file. Output For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.” Sample Input 123456787 8#.#####.#.a#..r.#..#x.....#..#.##...##...#.............. Sample Output 113 这个题大概的意思就是求从字符a出发，到达字符r的最少时间，其中 . 代表空地，#代表墙，x代表守卫，每杀死一个守卫我们就需要消耗一秒的时间。 这个题可以用BFS直接求解，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;# include&lt;string.h&gt;# include&lt;algorithm&gt;# include&lt;queue&gt;using namespace std;# define MAXN 510char str[MAXN][MAXN];//用来储存地图 int vis[MAXN][MAXN];//用来标记已经走过的地点 int n,m;struct name&#123; int x; int y; int step;&#125;;bool operator &lt;(name i,name j)&#123;//对走过的地点顺序进行排序 return i.step&gt;j.step;&#125;int d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;//表示行走的四个方向，顺序为右，左，上，下 int BFS(int sx,int sy,int ex,int ey)&#123; memset(vis,0,sizeof(vis)); priority_queue&lt;name&gt;que;//使用队列用来储存上一步走过的地点 name e1,e2; e1.x=sx,e1.y=sy,e1.step=0; que.push(e1);//输入起点 vis[sx][sy]=1; int ans=-1; int i; while(!que.empty())&#123;//当队列为空时，即表示我们已经把所有的能走的地点都走了一遍 e1=que.top();//将队列第一个地点的信息赋给e1； 此时e1即表示上一步走过的地点的信息 que.pop(); if(e1.x==ex &amp;&amp; e1.y==ey)&#123;//对这个地点进行判断，看是否是是终点 ans=e1.step; break; &#125; for(i=0;i&lt;4;i++)&#123;//如果e1不是终点，那么对e1的上下左右进行判断，如果可以走，那么就将信息储存在队列中 e2.x=e1.x+d[i][0]; e2.y=e1.y+d[i][1]; if(e2.x&lt;0 || e2.x&gt;=n || e2.y&lt;0 || e2.y&gt;=m) continue;//对边界进行判断，如果超出边界，则不进行保存 if(vis[e2.x][e2.y]==1) continue;//如果当前位置已经走过，那么就不进行保存 if(str[e2.x][e2.y]=='#') continue;//如果是墙壁,不进行保存 if(str[e2.x][e2.y]=='x') e2.step=e1.step+2;//如果是守卫的话，需要消耗两个单位时间 else e2.step=e1.step+1;//如果是空地,一个单位时间 que.push(e2);//将地点存入队列 vis[e2.x][e2.y]=1;//降低点进行标记 &#125; &#125; if(ans==-1)&#123; printf("Poor ANGEL has to stay in the prison all his life.\n"); &#125; else&#123; printf("%d\n",ans); &#125; &#125;int main()&#123; int i,j; while(~scanf("%d %d",&amp;n,&amp;m))&#123; for(i=0;i&lt;n;i++)&#123; scanf("%s",str[i]); &#125; int sx,sy,ex,ey; for(i=0;i&lt;n;i++)&#123;//找寻起点和终点 for(j=0;j&lt;m;j++)&#123; if(str[i][j]=='a') sx=i,sy=j; if(str[i][j]=='r') ex=i,ey=j; &#125; &#125; BFS(sx,sy,ex,ey);//开始BFS &#125; return 0;&#125; 从代码中可以看出，我们使用BFS的步骤为： 1.对地图信息进行保存 2.找到起点和终点信息 3.从起点开始，对所走过的每一步进行判断 4.如果走的这一步可行，那么储存这一步的信息，并标记这个位置，表示不会再走到这个位置 5.如果不可行，那么就不进行操作 6.找到终点 以上，即为BFS的功能。 DFS(深度优先搜索)DFS的目的是要达到被搜索结构的叶结点。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。 DFS的使用基础为递归，当我们顺着一个节点向下走时，如果走不下去了，就回溯，如果上一个节点还有其他的节点，那么我们就会对这个节点再进行搜索。 对于下面这个图 首先我们将从第一个节点开始出发，然后搜索第二个节点， 因为第二个节点下面还有第四个节点，因此我们继续向下搜索， 第四个节点下面已经没有其他节点，因此我们回溯到第二个节点 第二个节点下面还有第五个节点，因此我们搜索第五个节点 然后继续回溯，到第一个节点， 接下来就搜索第三个节点，第五个节点 当再次回溯到第一个节点时，已经没有其他的节点可进行搜索，因此搜索的过程到此结束，DFS也到此结束。 上面就是DFS的功能，DFS是对所有可能的结果进行一次彻底的搜索，这样会保证不会有任何情况会被遗漏。 接下来看一道例题（HDU1312）Red and Black： There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. Write a program to count the number of black tiles which he can reach by repeating the moves described above. Input The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. ‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set) Output For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input 1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output 12344559613 这个题的大概意思就是给你一个起点，你能够走到多少个地点。 其中 ‘ . ‘是空地，#是墙壁，@是起点。 接下来看一下代码，思想和BFS类似： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define clr(a) memset(a,0,sizeof(a))const int MAXN = 1e5+10;const int INF = 0x3f3f3f3f;const int N = 30;int n,m,sum;char mapp[N][N];//储存地图 int vis[N][N];//标记位置 int dx[4] = &#123;1,-1,0,0&#125;;//四个行走方向 int dy[4] = &#123;0,0,1,-1&#125;;bool check(int x,int y)&#123;//检测不能走通的条件 if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||mapp[x][y]=='#')&#123; return false; &#125; else return true;&#125;void DFS(int x,int y)&#123; if(!check(x,y)||vis[x][y])&#123;//如果不能走通，那么直接返回 return ; &#125; else&#123; sum++; int fx,fy; for(int i=0;i&lt;4;i++)&#123;//在此节点的基础上，再对周围四个节点进行判断 vis[x][y] = true; fx = x + dx[i]; fy = y + dy[i]; DFS(fx,fy);//此处使用递归求解 &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n)!=EOF&amp;&amp;(n||m))&#123; clr(mapp);clr(vis); sum = 0; for(int i=0;i&lt;n;i++)&#123; scanf("%s",mapp[i]); &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(mapp[i][j] == '@')&#123; DFS(i,j); break; &#125; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125; 从代码中我们可以看出，DFS的使用方法为： 1.找出起点 2.对起点四个方向的状态进行判断，如果是空地，就进行递归，继续对这四个方向的位置的四周进行判断，如果不是空地，就结束递归 3.输出结果 DFS与BFS有很多相似的地方，不过BFS求的是最短路，DFS求的是方案数，我们可以根据题目要求选择这两种方法。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[现在已经是2019年。我加入HPU-ACM（现为算法协会）是在18年3月份左右，虽然时间不长，但是已经成为这个大家庭的一份子了。 经过了近一年的学习与比赛，我觉得收获了很多。但是回头一想，却又想不起来学过的知识到底有什么，学的扎实不扎实，是否能清晰地描述自己学过的知识。 看着协会里的成员一个个的在努力，在进步，我也希望能够继续深入学习，在ACM的路上走的更远。 同时，我也希望我的学弟学妹们能够比我们走得更远。HPU在这方面很弱，非常弱。因此我们更需要一种行之有效的方法去帮助学弟学妹们入门算法，学习算法。 我在这里写下了我所学过得部分算法和知识，可能并不是十分完善，毕竟我也只是个ACM的小学生。但正因为是这样，我在这些算法里面遇到过的坑还没有忘记，所以在写这些文章时，我会注意那些容易出错的地方，进行提醒，不希望我的学弟学妹们或者其他算法的初学者走弯路。 希望我的这些文章对学习算法能有所启发。 文章持续补充中……]]></content>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2019%2F01%2F07%2FFirst%20blog%2F</url>
    <content type="text"><![CDATA[纪念我的第一篇博客 ^_^]]></content>
  </entry>
</search>

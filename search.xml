<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第十届蓝桥杯--C++-B组]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF-C-B%E7%BB%84%2F</url>
    <content type="text"><![CDATA[能力一般，水平有限。请多见谅。 A:组队 本题总分：5 分 ​ 作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员， 组成球队的首发阵容。 每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1 号位至 5 号位的评分之和最大可能是多少？ 暴力解决一切！ 答案：490。 B:年号字串 本题总分：5 分 小明用字母 A 对应数字 1，B 对应 2，以此类推，用 Z 对应 26。对于 27 以上的数字，小明用两位或更长位的字符串来对应，例如 AA 对应 27，AB 对 应 28，AZ 对应 52，LQ 对应 329。 请问 2019 对应的字符串是什么？ 不得不说，这个题遇见26居然还不进位！最后不得不手算…… 答案：BYQ。（算出BY的时候还激动了一下） C: 数列求值 本题总分：10 分 给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求 第 20190324 项的最后 4 位数字。 一个 for 循环解决一切！ 答案：4659 D: 数的分解 本题总分：10 分 把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包 含数字 2 和 4，一共有多少种不同的分解方法？ 注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。 暴力杯名不虚传。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;bool cal(int x)&#123; while(x)&#123; if(x%10==2 || x%10==4) return false; x/=10; &#125; return true;&#125;int main()&#123; int sum=0; for(int i=1;i&lt;=2019;i++)&#123; for(int j=i+1;j&lt;=2019;j++)&#123; if(2019-i-j&lt;=j) break; if(cal(i) &amp;&amp; cal(j) &amp;&amp; cal(2019-i-j))&#123; sum++; &#125; &#125; &#125; printf("%d\n",sum); return 0;&#125; 答案： 40785。 E: 迷宫 本题总分：15 分 下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。 010000000100001001110000 ​ 迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。 对于上面的迷宫，从入口开始，可以按 DRRURRDDDR 的顺序通过迷宫， 一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式， 其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。 请注意在字典序中D&lt;L&lt;R&lt;U。 01010101001011001001010110010110100100001000101010 00001000100000101010010000100000001001100110100101 01111011010010001000001101001011100011000000010000 01000000001010100011010000101000001010101011001011 00011111000000101000010010100010100000101100000000 11001000110101000010101100011010011010101011110111 0001101101010100100100101000000100010100111000000010100000101000100110101010111110011000010000111010 00111000001010100001100010000001000101001100001001 11000110100001110010001001010101010101010001101000 00010000100100000101001010101110100010101010000101 11100100101001001000010000010101010100100100010100 00000010000000101011001111010001100000101010100011 10101010011100001000011000010110011110110100001000 10101010100001101010100101000010100000111011101001 10000000101100010000101100101101001011100000000100 10101001000000010100100001000100000100011110101001 00101001010101101001010100011010101101110000110101 11001010000100001100000010100101000001000111000010 00001000110000110101101000000100101001001000011101 10100101000101000000001110110010110101101010100001 00101000010000110101010000100010001001000100010101 10100001000110010001000010101001010101011111010010 00000100101000000110010100101001000001000000000010 11010000001001110111001001000011101001011011101000 00000110100010001000100000001000011101000000110011 10101000101000100010001111100010101001010000001000 10000010100101001010110000000100101010001011101000 00111100001000010000000110111000000001000000001011 10000001100111010111010001000110111010101101111000 BFS+路径记忆，算是前面几道题唯一涉及算法的题目了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;#define pi pair&lt;int,int&gt;int n=30,m=50;char mp[100][100];int vis[100][100];int step[100][100];//1：D 2:L 3: R 4: U int d[4][2]=&#123;1,0,0,-1,0,1,-1,0&#125;;void bfs(int x,int y)&#123; vis[x][y]=1; queue&lt;pi&gt;que; que.push(pi(x,y)); while(!que.empty())&#123; x=que.front().first; y=que.front().second; que.pop(); for(int i=0;i&lt;4;i++)&#123; int xx=x+d[i][0]; int yy=y+d[i][1]; if(mp[xx][yy]=='0' &amp;&amp; !vis[xx][yy] &amp;&amp; xx&gt;=0 &amp;&amp; xx&lt;n &amp;&amp; yy&gt;=0 &amp;&amp; yy&lt;m)&#123; vis[xx][yy]=1; step[xx][yy]=i+1; que.push(pi(xx,yy)); &#125; &#125; &#125;&#125;void out(int x,int y)&#123; if(x==0 &amp;&amp; y==0) return ; if(step[x][y]==1)&#123; out(x-1,y); printf("D"); &#125; else if(step[x][y]==2)&#123; out(x,y+1); printf("L"); &#125; else if(step[x][y]==3)&#123; out(x,y-1); printf("R"); &#125; else&#123; out(x+1,y); printf("U"); &#125;&#125;int main()&#123; for(int i=0;i&lt;n;i++)&#123; scanf("%s",mp[i]); &#125; bfs(0,0); out(n-1,m-1); return 0;&#125; 答案： 1DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR F: 特别数的和 时间限制: 1.0s 内存限制: 256.0MB 本题总分：15 分 ​ 小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。 请问，在 1 到 n 中，所有这样的数的和是多少？【输入格式】​ 输入一行包含一个整数 n。【输出格式】​ 输出一行，包含一个整数，表示满足条件的数的和。【样例输入】 ​ 40【样例输出】 ​ 574【评测用例规模与约定】 ​ 对于 20% 的评测用例，1≤n≤10。 ​ 对于 50% 的评测用例，1≤n≤100。 ​ 对于 80% 的评测用例，1≤n≤1000。 ​ 对于所有评测用例，1≤n≤10000。 直接模拟就可以了。 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;bool cal(int x)&#123; while(x)&#123; if(x%10==2 || x%10==0 || x%10==1 || x%10==9) return true; x/=10; &#125; return false;&#125;int main()&#123; int n; scanf("%d",&amp;n); int sum=0; for(int i=1;i&lt;=n;i++)&#123; if(cal(i)) sum+=i; &#125; printf("%d\n",sum); return 0;&#125; G: 完全二叉树的权值 时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分 给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从 上到下、从左到右的顺序依次是 A1, A2, ··· AN，如下图所示： ​ 现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点 权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。 注：根的深度是 1。 【输入格式】 第一行包含一个整数 N。 第二行包含 N 个整数 A1, A2, ··· AN 。【输出格式】 输出一个整数代表答案。 【样例输入】 ​ 7 ​ 1 6 5 4 3 2 1【样例输出】 ​ 2【评测用例规模与约定】 ​ 对于所有评测用例，1≤ N ≤100000，−100000≤ Ai ≤100000。 完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。（来自百度百科）。 完全二叉树不是满二叉树，最后一层不一定全有节点，所以判断层数的时候要注意一下。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll INF=0x3f3f3f3f3f3f3f3f;ll a[1000000];int main()&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; int pos=0; int i=1; int dep=1; ll maxx=-INF; int res; while(true)&#123; if(pos&gt;=n) break;//上一次把所有数计算完毕 ll sum=0; for(int j=0;j&lt;i;j++)&#123;//每次加i个数,如果最后一层不满，+-0对结果不产生影响。 sum+=a[pos++]; &#125; if(maxx&lt;sum)&#123; maxx=sum; res=dep; &#125; i*=2; dep++; &#125; printf("%d\n",res); return 0;&#125; H: 等差数列 时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分 ​ 数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一 部分的数列，只记得其中 N 个整数。 现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有 几项？ 【输入格式】 ​ 输入的第一行包含一个整数 N。 第二行包含 N 个整数 A1,A2,··· ,AN。(注意 A1 ∼ AN 并不一定是按等差数 列中的顺序给出) 【输出格式】 ​ 输出一个整数表示答案。 【样例输入】 ​ 5 ​ 2 6 4 10 20 【样例输出】 ​ 10 【样例说明】 ​ 包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、 18、20。 【评测用例规模与约定】 ​ 对于所有评测用例，2≤ N ≤100000，0≤ Ai ≤109。 如果是等差数列，那么任意两个数的差值一定是公差的整数倍，因此我们只要找到最大的公差（GCD）就可以了。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint a[1000000];int gcd(int x,int y)&#123; return y?gcd(y,x%y):x;&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a,a+n); int g=0; for(int i=1;i&lt;n;i++)&#123; g=gcd(g,a[i]-a[i-1]); &#125; if(g==0) printf("%d\n",n); else printf("%d\n",(a[n-1]-a[0])/g+1); return 0;&#125; I: 后缀表达式 时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分 给定 N 个加号、M 个减号以及 N + M + 1 个整数 A1,A2,··· ,AN+M+1，小 明想知道在所有由这 N 个加号、M 个减号以及 N + M +1 个整数凑出的合法的 后缀表达式中，结果最大的是哪一个？ 请你输出这个最大的结果。 例如使用1 2 3 + -，则 “2 3 + 1 -” 这个后缀表达式结果是 4，是最大的。【输入格式】 第一行包含两个整数 N 和 M。 第二行包含 N + M + 1 个整数 A1,A2,··· ,AN+M+1。【输出格式】 输出一个整数，代表答案。【样例输入】 ​ 1 1 ​ 1 2 3【样例输出】 ​ 4【评测用例规模与约定】 ​ 对于所有评测用例，0≤ N,M ≤100000，−109 ≤ Ai ≤109。 待补充 …… J: 灵能传输 时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分【题目背景】 ​ 在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在 游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对 一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的 刺蛇飞龙等低血量单位。【问题描述】 ​ 你控制着 n 名高阶圣堂武士，方便起见标为 1,2,··· ,n。每名高阶圣堂武士 需要一定的灵能来战斗，每个人有一个灵能值 ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai 点灵能，ai 为负则表示这 名高阶圣堂武士还需要 −ai 点灵能才能到达最佳战斗状态）。现在系统赋予了 你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i ∈ [2,n−1]，若 ai ≥ 0 则其两旁的高阶圣堂武士，也就是 i−1、i + 1 这两名高阶圣堂武士会从 i 这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai &lt; 0 则其两旁的高阶圣堂武士， 也就是 i−1,i+1 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能。形 式化来讲就是 ai−1+ = ai,ai+1+ = ai,ai−= 2ai。 灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂 武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 maxn i=1|ai|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武 士的不稳定度最小。【输入格式】​ 本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。 接下来依次输入每一组询问。 每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。 接下来一行包含 n 个数 a1,a2,··· ,an。【输出格式】​ 输出 T 行。每行一个整数依次表示每组询问的答案。【样例输入】 335 -2 340 0 0 031 2 3 【样例输出】 303 【样例说明】 对于第一组询问： 对 2 号高阶圣堂武士进行传输操作后 a1 = 3，a2 = 2，a3 = 1。答案为 3。 ​ 对于第二组询问： 这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。【样例输入】 34-1 -2 -3 742 3 4 -85-1 -1 6 -1 -1 【样例输出】 574 【数据规模与约定】 ​ 对于所有评测用例，T ≤3，3≤n≤300000，|ai|≤1e9。 评测时将使用 25 个评测用例测试你的程序，每个评测用例的限制如下： 注意：本题输入量较大请使用快速的读入方式。 待补充 ……]]></content>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩形面积并]]></title>
    <url>%2F2019%2F03%2F22%2F%E7%9F%A9%E9%98%B5%E9%9D%A2%E7%A7%AF%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[问题描述： 题目描述 平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。 输入 输入仅包含两行，每行描述一个矩形。 在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。 输出 输出仅包含一个实数，为交的面积，保留到小数后两位。 样例输入 1234&gt; 1 1 3 3 &gt; &gt; 2 2 4 4 &gt; 样例输出 12&gt; 1.00&gt; 两个矩形相交的情况总共有以下几种（可能有部分遗漏）： 如果我们对所有的情况都进行分类讨论，那么代码写上百行是没问题的。 通过观察发现，每个相交的小矩形的四条边一定为两个大矩形的八条边中的四条。 再仔细观察的话，小矩形的每个方向的边都是两个大矩形同一个方向的两条边中的一条。 继续观察，小矩形每条边都是两个大矩形更靠近中心的两条边中的一条。 至此，我们就能够计算出小矩形的面积了。 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;double a[10];int main()&#123; double l,r,u,d; for(int i=1;i&lt;=8;i++)&#123; scanf("%lf",&amp;a[i]); &#125; l=max( min(a[1],a[3]) , min(a[5],a[7]) ); r=min( max(a[1],a[3]) , max(a[5],a[7]) ); d=max( min(a[2],a[4]) , min(a[6],a[8]) ); u=min( max(a[2],a[4]) , max(a[6],a[8]) ); if( r - l &lt;= 0 || u - d &lt;= 0 ) printf("0.00\n"); else printf("%.2lf\n",(r-l)*(u-d)); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[四大dp系列-数位dp]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E6%95%B0%E4%BD%8Ddp%2F</url>
    <content type="text"><![CDATA[数位dp(本文参考于 大佬博客) 数位dp是一种高速求解给定区间内符合一定条件的数的个数的算法。其基本思想为记忆化搜索。 数位dp一般应用于： 求出在给定区间[A,B]内，符合条件P(i)的数i的个数. 条件P(i)一般与数的大小无关，而与 数的组成 有关 求解的基本步骤如下： 当我们求 [ 0 , 100000 ] 和 [ 100001 , 200000 ]中符合条件的数的个数时，我们只需要求出前一个区间符合条件的数的个数，后面的区间只需要使用前面计算出来的值就可以了。 以下面的 不含49 为例，当我们在求[ 49001 , 50000 ]符合条件的数的个数时，会有不符合条件的情况存在，因此我们需要对其值进行判断，即将这一部分的值省略掉，当把这部分去掉之后，我们再求出来[ 0 , 100000 ]中符合条件的数的个数。 如果 b 为 123456 ，如果我们仍然求解[100001,200000]的话就会出错，我们只能先求解[100000,120000]，然后再求解[120001,123000]，因此，我们还需要判断当前是否是数的上限。 不含49 求[ a , b ]中不包含49的数的个数。 1&lt;=a&lt;=b&lt;=1e9 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint a,b;int num[20];//储存每一位的值 int dp[20][2];//储存长度为length时符合条件的数的数量，两个数组分别表示 是4时 和 不是4时 的数量int dfs(int length,bool is_4,bool is_max)&#123; //如果计算到最后一位，那么直接返回 if(length==-1) return 1; //如果不是数的上限并且之前计算过，这步就是记忆化最关键的一步 if(!is_max &amp;&amp; dp[length][is_4]) return dp[length][is_4]; int cnt=0,maxx=(is_max ? num[length]:9);//判断是否是上限，即判断当前位所能取到的值的范围 for(int i=0;i&lt;=maxx;i++)&#123; if(is_4 &amp;&amp; i==9) continue;//上一位是4，这一位是9，那么就直接跳过 cnt+=dfs(length-1,i==4,is_max &amp;&amp; i==maxx); &#125; //如果是上限，那么不能保存，因为dp保存的是[100000,200000]这样的值，并不能储存[100000,120000]的值 return is_max?cnt:dp[length][is_4]=cnt;&#125;int solve(int x)&#123; memset(num,0,sizeof(num)); int length=0; while(x)&#123; num[length++]=x%10; x/=10; &#125; return dfs(length-1,false,true);&#125;int main()&#123; scanf("%d %d",&amp;a,&amp;b); printf("%d\n",solve(b)-solve(a-1)); return 0;&#125; 这是数位dp最基本的模板。 不要62不要62 题意很简单，求区间内不含 4 和 62 的数的个数。 这个代码和上面的代码几乎一样，只是中间加了一步判断 4 的步骤 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int a[20];int dp[20][2];int dfs(int length,int is_6,bool is_max)&#123; if(length==-1) return 1; if(!is_max &amp;&amp; dp[length][is_6]) return dp[length][is_6]; int cnt=0; int maxx=is_max?a[length]:9; for(int i=0;i&lt;=maxx;i++)&#123; if(is_6 &amp;&amp; i==2) continue;//不要62 if(i==4) continue; //不要4 cnt+=dfs(length-1,i==6,is_max &amp;&amp; i==maxx); &#125; if(!is_max) dp[length][is_6]=cnt; return cnt; &#125;int solve(int x)&#123; int length=0; while(x)&#123; a[length++]=x%10; x/=10; &#125; return dfs(length-1,0,true);&#125;int main()&#123; int a,b; while(~scanf("%d %d",&amp;a,&amp;b) &amp;&amp; a+b)&#123; printf("%d\n",solve(b)-solve(a-1)); &#125; return 0;&#125; 只要13 找出1~n范围内含有13并且能被13整除的数字的个数. 这个题目条件比前两个复杂一点，我们需要计算出这个数字是否是13的倍数，并且是否包含13，所以，我们需要用两个变量来判断。 一个变量用来判断是否是13的倍数；另一个变量用来判断是否包含13。而判断13时有三种情况： 上一位不是 1 上一位是 1 但这一位不是 3 上一位是 1 且这一位是 3 因此不能用 bool 类型数据判断是否包含13。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int a[100];int dp[20][20][10];//三维表示：长度为 length ，模数为 mod , 是否包含 13int dfs(int length,int mod,int have_13,bool limit)&#123; if(length==-1) return mod==0 &amp;&amp; have_13==2;// 是 13 的倍数并且包含 13 if(!limit &amp;&amp; dp[length][mod][have_13]) return dp[length][mod][have_13]; int cnt=0; int maxx=limit?a[length]:9; for(int i=0;i&lt;=maxx;i++)&#123; int next=have_13; //这是为了寻找数是否包含13，当have_13==2,即找到13后，就不会进行下列判断 if(have_13!=2 &amp;&amp; i!=1) next=0;//没有特殊情况（尾数不是 1 或 13 ） if(have_13!=2 &amp;&amp; i==1) next=1;//尾数为1 if(have_13==1 &amp;&amp; i==3) next=2;//后两位尾数为13 cnt+=dfs(length-1,(mod*10+i)%13,next,limit&amp;i==maxx); &#125; if(!limit) dp[length][mod][have_13]=cnt; return cnt;&#125;void solve(int n)&#123; int length=0; while(n)&#123; a[length++]=n%10; n/=10; &#125; printf("%d\n",dfs(length-1,0,0,true));&#125;int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; solve(n); &#125; return 0;&#125; 从上面几个例题我们就可以看出，求解基本的数位dp的核心就是处理所需要判断的条件，上面三个代码大体框架都一样，只是在判断是否继续向下求解时有所不同，因此我们只要处理好需要判断的条件就能够做简单的数位dp问题。]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大dp系列--状压dp]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E7%8A%B6%E5%8E%8Bdp%2F</url>
    <content type="text"><![CDATA[状压dp状态压缩dp，是一种将复杂的状态压缩成二进制数字的算法。 旅行商问题我们来看一个经典的旅行商问题： 给定一个n个顶点组成的带权有向图的距离矩阵d(i,j)(INF表示没有边)。要求从顶点0出发，经过每个顶点恰好一次后再回到顶点0。问所经过的边的总权重的最小值是多少？（来源于《挑战程序设计竞赛》）。 限制条件： 2&lt;=n&lt;=15 0&lt;=d(i,j)&lt;=1000 所有可能的路线会有 (n-1)! 种结果，因此我们不能够使用暴力的方法求解，那么我们需要用高效的方法来求解。 假如我们对每个顶点编号。我们可以用一个数的二进制来表示走过的集合 S ： 当n=5时，00000表示所有顶点均未走过，00001表示经过编号为0的顶点，10001表示经过第0和第4个顶点。11111表示经过所有的顶点。 这样，我们就能使用2^n次方个数来表示出所有的状态。 定义dp[S][v]：从v出发，访问剩余未访问过的节点所需要的最小花费。特别的，当S=2^n-1，v=0时,dp[S][v]=0。 从dp[S][v]的定义，我们也可以看出如下递推式：$$dp[S][v]=min(dp[S∪{u}][u]+d[v][u] | u∉S)$$其中u表示从v出发到达的下一个顶点。 S ∪ { u } 表示现在经过的所有顶点，由于是从 v 到 u ，所以当前的出发点也为u。d[v][u]表示从顶点 v 到顶点 u 的花费。 找出了递推式，我们就可以使用记忆化搜索的方式找出最小花费： 12345678910111213141516171819202122int n;int d[maxn][maxn];//储存地图信息，初始化为 INF int dp[1&lt;&lt;maxn][maxn];//记忆化搜索使用的数组int rec(int S,int v)&#123;//当前走过的节点集合 S，出发顶点v if(dp[S][v]&gt;=0)&#123; return dp[S][v];//由于我们使用的是递归的方法，所以如果有解，储存的一定是最优的解 &#125; if(S==(1&lt;&lt;n)-1 &amp;&amp; v==0)&#123;//访问过所有定点，并且回到最初起点0，那么在这个状态之后的花费一定是0，即不需要再有其他的花费 return dp[S][v]=0; &#125; int res=INF; for(int u=0;u&lt;n;u++)&#123; if(!(S&gt;&gt;u&amp;1))&#123;//第u个节点未被访问 res=min(res,rec(S|1&lt;&lt;u,u)+d[v][u]);//递归 S|1&lt;&lt;u表示走过u之后的节点集合，因为是走到u，所以新的出发点也是u &#125; &#125; return dp[S][v]=res;&#125;int solve()&#123; memset(dp,-1,sizeof(dp));//-1表示未被访问过 printf("%d\n",rec(0,0));&#125; 由于状压dp的特性，我们只能求解n比较小的情况，否则内存就会超限。 思考上述代码后，我们可以发现，每一个比较小的节点集合都是由比较大的节点集合计算出来的。即对于两个集合S( i ) ∈ S( j ) ，有 i &lt;= j 。我们在求S( i )时，需要先求出来S( j )的值。因此，我们也可以用循环的方法求解： 12345678910111213141516171819int n;int d[maxn][maxn];int dp[1&lt;&lt;maxn][maxn];void solve()&#123; for(int S=0;S&lt;1&lt;&lt;n;S++)&#123; fill(dp[S],dp[S]+n,INF); &#125; dp[(1&lt;&lt;n)-1][0]=0; for(int S=(1&lt;&lt;n)-2;S&gt;=0;S--)&#123; for(int v=0;v&lt;n;v++)&#123; for(int u=0;u&lt;n;u++)&#123; if(!(S&gt;&gt;u&amp;1))&#123; dp[S][v]=min(dp[S][v],dp[S|1&lt;&lt;u][u]+d[v][u]); &#125; &#125; &#125; &#125; printf("%d\n",dp[0][0]);&#125; 这就是最基础的状压dp问题。 （内容持续更新……）]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树基础模板]]></title>
    <url>%2F2019%2F03%2F15%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[三个基本的线段树操作模板。 线段树单点更新+查询区间最大值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1000000;int dat[maxn],n;int m,a,b;char op;void init(int x)&#123; n=1; while(n&lt;x) n*=2; for(int i=0;i&lt;n*2-1;i++)&#123; dat[i]=0; &#125;&#125;void update(int k,int a)&#123; k+=n-1; dat[k]=a; while(k&gt;0)&#123; k=(k-1)/2; dat[k]=max(dat[k*2+1],dat[k*2+2]); &#125;&#125;int query(int a,int b,int k,int l,int r)&#123; if(r&lt;a || b&lt;l) return 0; if(a&lt;=l &amp;&amp; r&lt;=b) return dat[k]; else&#123; int vl=query(a,b,k*2+1,l,(l+r)/2); int vr=query(a,b,k*2+2,(l+r)/2+1,r); return max(vl,vr); &#125;&#125;int main()&#123; int n_; while(~scanf("%d %d",&amp;n,&amp;m))&#123; n_=n; init(n); for(int i=0;i&lt;n_;i++)&#123; scanf("%d",&amp;dat[i+n-1]); update(i,dat[i+n-1]); &#125; getchar(); while(m--)&#123; scanf("%c %d %d",&amp;op,&amp;a,&amp;b); getchar(); if(op=='Q') printf("%d\n",query(a-1,b-1,0,0,n-1)); else if(op=='U') update(a-1,b); &#125; &#125; return 0;&#125; 线段树区间更新1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1000000;int n,m,det[maxn];void init(int x)&#123; n=1; while(n&lt;x) n*=2; for(int i=0;i&lt;n*2-1;i++)&#123; det[i]=0; &#125;&#125;void update(int a,int b,int x,int k,int l,int r)&#123; if(b&lt;l || r&lt;a) return ; if(a&lt;=l &amp;&amp; r&lt;=b) det[k]=max(x,det[k]); else&#123; update(a,b,x,k*2+1,l,(l+r)/2); update(a,b,x,k*2+2,(l+r)/2+1,r); &#125;&#125;int query(int l,int r,int k,int mmax)&#123; if(l==r) return max(mmax,det[k]); det[k]=max(mmax,det[k]); int vl=query(l,(l+r)/2,k*2+1,det[k]); int vr=query((l+r)/2+1,r,k*2+2,det[k]); return vl+vr;&#125;int main()&#123; int l,r,k; while(~scanf("%d %d",&amp;n,&amp;m))&#123; int n_=n; init(n); for(int i=0;i&lt;m;i++)&#123; scanf("%d %d %d",&amp;l,&amp;r,&amp;k); update(l,r,k,0,0,n-1); &#125; printf("%d\n",query(0,n-1,0,0)); &#125; return 0;&#125; 线段树区间更新+区间求和1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define ll long longconst ll maxn=1000000;ll det[maxn],sum[maxn],n,m;void update(ll a,ll b,ll x,ll k,ll l,ll r)&#123; if(a&lt;=l &amp;&amp; r&lt;=b)&#123; det[k]+=x; &#125; else if(l&lt;=b &amp;&amp; a&lt;=r)&#123; sum[k]+=(min(b,r)-max(a,l)+1)*x; add(a,b,x,k*2+1,l,(l+r)/2); add(a,b,x,k*2+2,(l+r)/2+1,r); &#125;&#125;ll query(ll a,ll b,ll k,ll l,ll r)&#123; if(b&lt;l || r&lt;a) return 0; else if(a&lt;=l &amp;&amp; r&lt;=b) return det[k]*(r-l+1)+sum[k]; else&#123; ll res=(min(b,r)-max(a,l)+1)*det[k]; res+=query(a,b,k*2+1,l,(l+r)/2); res+=query(a,b,k*2+2,(l+r)/2+1,r); return res; &#125;&#125;int main()&#123; ll a,b,x; char op; scanf("%lld %lld",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;x); update(i,i,x,0,0,n-1); &#125; getchar(); while(m--)&#123; scanf("%c",&amp;op); if(op=='Q')&#123; scanf("%lld %lld",&amp;a,&amp;b); printf("%lld\n",query(a-1,b-1,0,0,n-1)); &#125; else&#123; scanf("%lld %lld %lld",&amp;a,&amp;b,&amp;x); update(a-1,b-1,x,0,0,n-1); &#125; getchar(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六届Code+程序设计网络挑战赛-COORDINATE]]></title>
    <url>%2F2019%2F03%2F12%2F%E7%AC%AC%E5%85%AD%E5%B1%8ACode-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BD%91%E7%BB%9C%E6%8C%91%E6%88%98%E8%B5%9B-COORDINATE%2F</url>
    <content type="text"><![CDATA[题目描述题目描述 在视频编码中，往往需要将一帧画面分块。 为了简化问题，我们考虑将一幅图片看作 $2^n ​$ * $ 2^n ​$的网格。为了对图片进行处理，编码器往往会遍历每个格子，但遍历格子的方式在不同的应用中是不同的。 其中一种方式叫做光栅遍历，就是按照从左到右，从上到下的顺序依次进行标号。下图是一个 8×8 的例子： 另一种方式叫做 Z 字型遍历。先看一个 8×8 的例子： 可以构造性的给出描述： 1.对于$2^0 $ * $ 2^0 ​$的网格，直接遍历 2.对于$2^k $ * $ 2^k $ (k&gt;0)的网格，将其横着从中间、竖着从中间各分成两半，形成4个$2^{k-1} $ * $ 2^{k-1} ​$的方格，这四个方格按照左上、右上、左下、右下的顺序依次遍历。 输入格式 输入的第一行为两个整数 n,m ,$2^n​$ 为矩形的边长，m 为询问次数。 接下来 m 行，每行是一个询问，询每个询问给出一个方格，方式有两种，如下： Z x 给出 Z 字形遍历中标号是 x 的方格。 R x 给出光栅遍历中标号是 x 的方格。 保证存在标号为x的方格。 输出格式 对于每种询问，请输出一行一个正整数，表示在另一种遍历方式中，给出格子的标号。 样例输入 1233 2Z 37R 37 样例输出 123549 解题思路从题意可知，我们需要找到与输入的排列方格序号位置对应的另一张排列方格位置序号。 我们先从输入R出发进行计算 输入 R x比如样例R 37，我们可以从题面的图片看出，它所对应的位置为第 4 行第 5 列（初始为第0行第0列，，以下缩写为（x,y））。 我们观察Z遍历可发现，如果我们把方格分成四个小方格，每个方格大小一样，每个位置所对应的值的差是一个值的整数倍。比如对于 49 和 33 ，33 和 17 ，17 和 1 ，他们在小方格中位置相同，差值均为小方格的大小（$ 2^n $ * $ 2^n $ / 4），因此，我们可以根据每个数字所在的方格位置，判断它所在的方格，从而算出它对应的值。 比如，对于（ 4 , 5 ），我们可以看出他所在的方块为第四块（小方块按遍历顺序编号1234），因此我们可以知道在Z中它的值 n &gt;=（$ 2^n $ * $ 2^n $ / 4）* 3 ,所以我们先保存这一部分值，然后将其对应到第一个方格所对应的位置（即行和列均减去边长的一半），因为我们已经将它放在了第一个方格，其他三个方格已经没有作用了，因此我们可以将边长减小为现在的一半。然后重复此步操作。 一次操作后，大方格的已经变成了 而( 4 , 5 )现在所对应的位置为（ 0 ，1），再分成四个小方格后在第一个方格，因此对行和列不操作，边长再减小一半。 现在，他的所对应的位置依然为（ 0 , 1 ）现在的大方格为 所在小方格编号为2，因此列数减去当前边长的一半，保存当前面积（$ 2^1 $ * $ 2^1 ​$ / 4 * 1）。此时，它的坐标已经变成了（0 ，0），计算结束。 上面进行了三次操作，其大致顺序为： 1.找到坐标对应的小方格编号。 2.把当前坐标移动到第一个小方格，记录移动所改变的值。 3.重复步骤1,2，直到坐标变为（0 , 0）。 4.输出总的改变的值。 比如上面的（ 4 , 5 ），我们三次操作保存的值为$ 2^3 $ * $ 2^3 $ / 4 * 3 = 48 ；0 ； $2^1 $ * $ 2^1 $ / 4 * 1 = 1。加起来的值为49，即最终答案。 这就是输入为R时的计算方法。 代码如下： 1234567891011121314151617181920212223ll i=x/line; //当前所在行ll j=x%line; //当前所在列ll res=0;ll l=line*line/4; //line为边长，l为一个小方格的面积ll fen=line/2; //fen为每个小方格的边长while(i&gt;0 || j&gt;0)&#123; if(j&gt;=fen &amp;&amp; i&lt;fen)&#123; //表示在第二个小方格 j-=fen; // res+=l; //储存当前操作所改变的值 &#125; else if(i&gt;=fen &amp;&amp; j&lt;fen)&#123; //表示在第三个小方格 i-=fen; res+=l*2; &#125; else if(i&gt;=fen &amp;&amp; j&gt;=fen)&#123; //表示在第四个小方格 i-=fen; j-=fen; res+=l*3; &#125; fen/=2;//将方块边长缩为原来的1/2,面积缩为原来的1/4 l/=4;&#125;printf("%lld\n",res); 输入Z x输入R时是根据行和列判断最终值，而输入Z时正好相反，根据x的值判断所在行和列。 我们如果知道x的大小，就可以判断它所在的小方格编号，因此也可以层层求出行和列的值。 代码如下： 1234567891011121314151617181920ll sumx=0,sumy=0; //储存行和列l=line*line/4; //同上ll fen=line/2; //同上while(x&gt;0)&#123; if(x/l==1)&#123;//根据值可判断出所在的小方格，从而判断出行和列应该加的值 sumy+=fen; x-=l;//减去对应的值，即上面的将坐标移动到第一个小方格 &#125; else if(x/l==2)&#123; sumx+=fen; x-=l*2; &#125; else if(x/l==3)&#123; sumx+=fen; sumy+=fen; x-=l*3; &#125; fen/=2; //同上 l/=4;&#125; 这样，我们就可以求出所有的值了。 完整代码如下（做题时提交代码）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pi pair&lt;int,int&gt;int main()&#123; ll n,m; char op; ll x; ll i,j; scanf("%lld %lld",&amp;n,&amp;m); ll line=1; for(ll i=0;i&lt;n;i++) line*=2;// printf("%lld %lld",line,(ll)pow(2,n));// 当时使用pow()提交wa了一次，改后ac了，可能精度有问题 while(m--)&#123; ll l; getchar(); scanf("%c %lld",&amp;op,&amp;x); if(op=='Z')&#123; ll sumx=0,sumy=0; l=line*line/4; ll fen=line/2; while(x&gt;0)&#123; if(x/l==1)&#123; sumy+=fen; x-=l; &#125; else if(x/l==2)&#123; sumx+=fen; x-=l*2; &#125; else if(x/l==3)&#123; sumx+=fen; sumy+=fen; x-=l*3; &#125; fen/=2; l/=4; &#125; printf("%lld\n",sumx*line+sumy); &#125; else if(op=='R')&#123; i=x/line; j=x%line; ll res=0; l=line*line/4; ll fen=line/2; while(i&gt;0 || j&gt;0)&#123; if(j&gt;=fen &amp;&amp; i&lt;fen)&#123; j-=fen; res+=l; &#125; else if(i&gt;=fen &amp;&amp; j&lt;fen)&#123; i-=fen; res+=l*2; &#125; else if(i&gt;=fen &amp;&amp; j&gt;=fen)&#123; i-=fen; j-=fen; res+=l*3; &#125; fen/=2; l/=4; &#125; printf("%lld\n",res); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++常见STL]]></title>
    <url>%2F2019%2F03%2F04%2FC-%E5%B8%B8%E8%A7%81STL%2F</url>
    <content type="text"><![CDATA[学识浅薄，下面写的只是一小部分STL比较浅显的使用方法，不对其内部运行规则进行讨论，只对平时做题可能用到的功能进行讲解。 using namespace stdnamespace是指标识符的各种可见范围。命名空间用关键字namespace 来定义。命名空间是C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。 1234#include&lt;......&gt;#include&lt;......&gt;#include&lt;......&gt;using namespace std;//一般写在标准函数库后面 std是一个命名空间，使用这句的主要原因是处理程序中的命名冲突。 命名空间是用来组织和重用代码的。如同名字一样的意思，NameSpace（名字空间），之所以出来这样一个东西，是因为人类可用的单词数太少，并且不同的人写的程序不可能所有的变量都没有重名现象，对于库来说，这个问题尤其严重，如果两个人写的库文件中出现同名的变量或函数(不可避免)，使用起来就有问题了。为了解决这个问题，引入了名字空间这个概念，通过使用 namespace xxx；你所使用的库函数或变量就是在该名字空间中定义的，这样一来就不会引起不必要的冲突了。 通俗来说，我们使用的scanf()，printf()是来自于&lt;stdio.h&gt;函数库,pow()是来自&lt;math.h&gt;函数库等等。函数库是开发人员写的，但是我们在调用函数时可能会遇到两个函数库里面有名字重复了，因此我们使用了命名空间开区分重复的变量名称的所在空间。 比如接下来要讲的vector,英文释义为“矢量”（显而易见一个非常容易用到的词）。这个词会有很多开发人员使用，我们现在使用vector是在std命名空间内的，因此如果不在前面写using namespace std的话，那我们就得这样使用： 123456789101112131415161718192021222324252627282930//这个会报错:[Error] 'vector' does not name a type#include&lt;stdio.h&gt;#include&lt;vector&gt;vector&lt;int&gt; vec;//这个形式前半部分为数据类型，后半部分为定义的变量。相当于平时用的 int n;int main()&#123; return 0; &#125;//然而下面这个就不会报错#include&lt;stdio.h&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt;vec;int main()&#123; return 0; &#125;//或者#include&lt;stdio.h&gt;#include&lt;vector&gt;std::vector&lt;int&gt;vec;//这是不用写using namespace std;的写法。使用std的方式，但其长度明显变长，可读性明显下降。int main()&#123; return 0; &#125; 因此，在程序开头写上using namespace std;是最好的选择，接下来讲的STL(Standard Template Library, 标准模板库)也是基于其基础上。 vector头文件：#include\ vector 与数组相比最大的优点是可以根据需要动态的分配内存。对于图的储存（有向图，无向图）有非常大的作用。在一般题目中，图的顶点数大约为$$10^5​$$左右，所有边总共有$$n*(n-1)/2​$$个，因此如果用二维数组储存边，那么一定会内存超限。 而vector就没有这个缺点，vector根据输入的边的数量可以动态的分配内存（一般题目输入边的数量也在$$10^6​$$以下），这样，就可以很容易的储存图。而且在查找时，还会节约许多时间。 vector的存储方式接下来看二维数组和vector的对比： 12345678910111213vector&lt;int&gt;vec[maxn];//定义一维vector数组int m[maxn][maxn];int u,v,m;for(int i=0;i&lt;m;i++)&#123;//二维数组直接分配maxn*maxn的内存，在输入时不需要再分配内存。 scanf("%d %d",&amp;u,&amp;v); a[u][v]=1;//表示两个顶点之间有一条边 &#125;for(int i=0;i&lt;m;i++)&#123;//一维vector数组输入时动态分配内存，内存大小最大只为m,要远远小于maxn*maxn scanf("%d %d",&amp;u,&amp;v); vec[u].push_back(v);//表示u连接向v vec[v].push_back(u);//根据有向图和无向图选择是否添加这一句&#125; 因此在一般情况下，使用vector存图是非常节省内存的方法。 vector的使用输入之后，边以数组的形式保存，使用时可以这样操作： 1234567for(int i=0;i&lt;vec[x].size();i++)&#123;//x为节点 printf("%d\n",vec[x][i]);//这段代码作用为输出与节点x相连的所有节点&#125;//相同作用下二维数组的操作for(int i=1;i&lt;=n;i++)&#123; if(a[x][i]==1) printf("%d\n",i);//对所有节点进行判断，如果相连则输出&#125; 上面的vec[x].size()表示输入时保存的与x相连的节点的数量。这个相比二维数组优点在于可以不用遍历那些没有边连接的节点，节省了大量的时间。 因此不管是在时间还是空间上，vector都优于二维数组。 map头文件：#include\ map 是一种容器，用来存储若干元素，这些元素都是由关键值和映射值 配对组成的。 简而言之，map里面的元素都有一定的映射关系。 map的基本应用形式为： 12map&lt;int,int&gt; mp;//一个整数对应一个整数map&lt;char,int&gt; mp;//一个字符对应一个整数 map的存储方式接下来看它们的存储方式： 1234567891011121314int n,x;scanf("%d",&amp;n);map&lt;int,int&gt;mp;for(int i=0;i&lt;n;i++)&#123;//输入n个数，每个数出现的次数进行统计 scanf("%d",&amp;x); mp[x]++;//mp[x]中， x代表上面的第一个int;mp[x]的值即为第二个int，初始值为0 &#125;char s;map&lt;char,int&gt;mp2;for(int i=0;i&lt;n;i++)&#123;//输入n个字符，每个字符出现的次数进行统计 scanf("%c",&amp;s); mp2[s]++;//mp2[s]中， s代表上面的第一个char;mp2[x]的值即为第二个int，初始值为0&#125; map的使用使用就是直接使用： 123int a;scanf("%d",&amp;a);printf("%d",mp[a]);//输出数字a出现的次数 因此，map主要作用就是计数（数字的个数、字符的个数、字符串的个数都可以计算），map&lt;…,…&gt;中，前面是记的元素，就像是数学函数f(x)中的x，后面一个数据类型，就是函数f(x)中的f(x)。 接下来看一个示例： 12345678910111213141516171819202122/*输入n,m。表示输入n个数接下来m次询问，每次输入一个数，输出这个数出现的次数 */#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;int,int&gt;mp; int n,m,x,a; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); mp[x]++; &#125; while(m--)&#123; scanf("%d",&amp;a); printf("%d\n",mp[a]); &#125; return 0;&#125; 关于map中其他元素的计数方式可以下去自行进行探索。 setset的内部结构和map类似，set的主要作用是对输入的元素进行去重和排序。 123456789101112131415int n,x;set&lt;int&gt;se;scanf("%d",&amp;n);for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); se.insert(x);//向se中插入x&#125;for(set&lt;int&gt;::iterator it=se.begin();it!=se.end();it++)&#123; printf("%d\n",*z);&#125;/*iterator是STL中的迭代器，其主要功能为遍历形如vector ,map,set等数据结构的所有元素 迭代器是一种检查容器内元素并遍历元素的数据类型。C++更趋向于使用迭代器而不是下标操作，因为标准库为每一种标准容器（如vector）定义了一种迭代器类型，而只用少数容器（如vector）支持下标操作访问容器元素。*/ 这个输出就是输入的元素去重过后的升序序列。 接下来说几个set中常用操作 1234567891011121314//下面几个使用比较多，需要掌握se.insert()//插入操作se.begin()//返回指向第一个元素的迭代器se.end()//返回指向最后一个元素的迭代器se.empty()//检查se是否为空，空的话返回true，非空的话返回falsese.clear()//清空所有元素//下面这些用的不多，可以了解了解se.count() 返回某个值元素的个数se.erase() 删除集合中的元素se.find() 返回一个指向被查找到元素的迭代器se.max_size() 返回集合能容纳的元素的最大限值se.size() 集合中元素的数目se.swap() 交换两个集合变]]></content>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度的计算及其他补充知识]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%8F%8A%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[时间复杂度时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。（来自百度百科） 时间复杂度最重要的一句话也就是上面加粗的这一句。 我们学习算法的目的就是使用算法使解决问题的时间复杂度尽量的小，就对于排序算法来说，排序有许多种方法，对于初学者来说，最简单的就是冒泡排序 123456789101112int a[maxn];int temp,n;for (j = 0; j &lt; n - 1; j++) for (i = 0; i &lt; n - 1 - j; i++) &#123; if(a[i] &gt; a[i + 1]) &#123; temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; &#125; &#125; 可以看出，两层循环的情况下，里面的 if()语句总共运行了n*(n-1)/2次。展开最高项次数为2,因此时间复杂度为O(n^2)。 再看一个判断质数的代码： 12345678910111213141516171819int n,i;scanf("%d",&amp;n);//时间复杂度O(n) 从定义出发：因子只有1和其本身，因此循环判断是否有其他因子for(i=2;i&lt;n;i++)&#123; if(n%i==0)&#123; break; &#125;&#125;if(i==n) printf("is prime\n");else printf("isn't prime\n");//时间复杂度O(√n) 从因子的角度出发，如果在√n之前没有其他因子，那么之后也不会再有了for(i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; break; &#125;&#125;if(i==n) printf("is prime\n");else printf("isn't prime\n"); 上面就是两个判断质数的时间复杂度的区别。 注意：上述循环中的结束条件( i &lt; n , i * i &lt;=n ) 均与 n 的值有关，在计算复杂度时，我们一般只考虑输入的值对代码时间的影响，比如如下面几个代码： 123456789101112131415int n;scanf("%d",&amp;n);for(int i=0;i&lt;100000;i++)&#123; printf("Hello world\n");&#125;for(int i=0;i&lt;10000;i++)&#123; for(int j=0;j&lt;i;j++)&#123; printf("Hello world\n"); &#125;&#125; while(1)&#123; printf("Hello world\n");&#125; 这几个代码的时间复杂度均为O(1)，因为不管输入为任何值，对这一部分代码的运算不会有任何影响。 所以当我们考虑时间复杂度时，只考虑与输入相关的部分，但在做题时，要考虑这一部分代码对整体时间使用的影响。 然后看接下来的代码： 123456789//计算n的二进制位数int n;scanf("%d",&amp;n);int sum=0;while(n&gt;0)&#123; n/=2; sum++;&#125;printf("%d\n",n); 这个代码的复杂度为O( log(n) )，其中log的底数一般不写，这是在做题时可能遇到的比较低时间复杂度。 接下来看这个代码： 123while(~scanf("%d",&amp;n))&#123; printf("%d",n*n);&#125; 这个代码的时间复杂度为O(1)，因为我们前面说过忽略常数的影响，在OJ系统中，如果说多组输入，那么我们在计算复杂度时只需要考虑单组的时间复杂度。 但是这个代码： 123456int t,n;scanf("%d",&amp;t);while(t--)&#123; scanf("%d",&amp;n); printf("%d\n",n*n);&#125; 这个代码的时间复杂度为O( t )，因为 t 是一个输入的变量，是可以改变的变量，所以我们在计算时间复杂度是需要计算上 t 对代码的影响。 虽然有些代码时间复杂度并不高，但在做题时，如果常数比较大，那么在写代码时仍要注意常数给代码带来的影响。 一般情况下，OJ评测机的每秒运算次数大概为 1e8~1e9 次。 空间复杂度空间复杂度和时间复杂度是相对应的，空间复杂度为输入的变量对空间的要求，一维数组为O( n ) ，二维数组为O(n^2)或O(n*m)等多种形式，一般情况下，代码的数组大小最好在1e8之下，否则，内存就会超限，导致虽然代码正确，但是并不通过的情况发生。 OJ常见评测结果Accepted答案正确！多么完美的返回结果！ #### Wrong Answer答案错误！一定是评测机坏了！本地对了就是对了，OJ上错误说明OJ肯定有问题！ Compile Error编译错误。语言不小心选错了？哦，少复制了一点代码。 此处顺便@某过气OJ。 Time Limit Exceed时间超限。一定是评测机太慢了！ Memory Limit Exceed内存超限。扣死了，内存都不会弄多点，这点内存都不舍得给我！ Presentation Error格式错误。不就多个空格，多个换行吗，又看不见那些字符，真是小心眼！ System Error系统错误。辣鸡评测机，辣鸡OJ！ Output Limit Exceed输出超限。我不是怕你看不懂吗，多输出点给你解释一下我的答案嘛！ Runtime Error运行错误。不就不小心除以零了嘛，就当我又创造了一门数学嘛！啊？数组下标越界了？我就是放这个变量出去数组外面玩了一会嘛。 在刷题的足够多之后，一些超限问题或者运行错误等就会减少，剩下的就只有（听取）WA（声一片）了。哈哈哈哈哈。 常见刷题OJ杭州电子科技大学 ( 杭电 ) OJ : acm.hdu.edu.cn ( 第11页之后有大量中文题目 ) codeforces : codeforces.com (一起来肝cf啊！) 洛谷：luogu.org vj : vjudge.net (Virtual Judge，可以在这里创建比赛)]]></content>
  </entry>
  <entry>
    <title><![CDATA[尺取+二分]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%B0%BA%E5%8F%96%2F</url>
    <content type="text"><![CDATA[尺取-问题引入尺取，顾名思义，就是像尺子一样取一段区间，来快速高效地找到你想要的区间。 接下来看一个题目： 给定一个长度为n的数列a1,a2,…,an及整数S,求不小于S的连续子序列的和的最小值 通俗一点来讲，求 min ( 区间和 ) 且 区间和 &gt;= S。 暴力的情况下，总共有n*(n+1)/2个非零区间，如果我们对每一个区间都进行计算，那么时间复杂度为O（n^2）。对于n比较大的情况，暴力肯定会超时。（事实上，几乎所有的此类题目n都在 1e5~1e6左右） 因此我们就需要更高效的算法来进行求解。 接下来我们进行一下思考： 假如区间 [ l , r ]（l &lt;= r） 的和小于S，那么对于区间[ l + i , r ] ( l + i &lt;= r )肯定也小于S，也就是说，假如一个区间不符合题意，那么它的子区间肯定也不符合题意。因此，我们就可以在这个基础上减少许多的多余的计算。 看懂了上面的思考部分，我们就可以开始尺取的讲解了。 尺取 我们设置两个变量 l , r ，表示当前我们所计算的区间 [ l , r )，初始 l = r = 0（我的数列第一个存储下标为0）。 然后我们开始移动 r , 使 r 逐渐变大，直到区间 [ l , r )的和不小于S（这里就用到了上面思考部分的知识，如果区间 [ l , r )的和小于S，那么其子区间就完全没有了计算的必要）。 当 [ l , r )不小于S时，我们开始移动 l ，使区间慢慢变小，然后继续计算当前区间的值。直到区间和又一次小于S 这里又用到了之前思考部分的知识，在运行第三步时，我们已知 [ l , r - 1 )不符合要求，那么所有的 [ l+i , r-j )（l &lt;= l + i &lt;= r - j &lt; r）均不符合要求，也就是说，如果我们这个时候缩了一下 r 的值，那么肯定是不符合要求的，但是， [ l + i , r )却是可能符合要求的，因为[ l + i , r )并不在我们的否定区间内，所以我们要继续对它进行计算判断。 当 r = n 时，结束运算。 代码如下： 1234567891011121314151617181920int n,s;int a[maxn];void solve()&#123; int l=0,r=0,sum=0;//sum为当前区间和 int res=INF; while(r&lt;n)&#123; sum+=a[r];//扩大区间 r++; /*这个while是代码的核心，题目上给的约束条件就是用while进行判断， 因此只要确定了while里面的内容，就可以轻易地求解尺取的相关问题 */ while(sum&gt;=s)&#123;//这一步原本应为先判断sum是否&gt;=s,但由于while的特性，可以直接省略 res=min(res,sum);//求出当前区间和是否更接近s sum-=a[l];//缩小区间 l++; &#125; &#125; printf("%d\n",res);&#125; 这样，我们就可以把时间复杂度缩小到O(n)了。 这是尺取最基本的一类解决问题，其他形式的尺取问题也基本依靠于这个主要思想。 二分-问题引入二分，顾名思义，就是用二分的方法找出答案。 接下来看一个题目： 农夫 John 建造了一座很长的畜栏，它包括N (2 &lt;= N &lt;= 100,000)个隔间，这些小隔间依次编号为x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000). 但是，John的C (2 &lt;= C &lt;= N)头牛们并不喜欢这种布局，而且几头牛放在一个隔间里，他们就要发生争斗。为了不让牛互相伤害。John决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是什么呢？ Input 有多组测试数据，以EOF结束。 第一行：空格分隔的两个整数N和C 第二行——第N+1行：分别指出了xi的位置 Output 每组测试数据输出一个整数，满足题意的最大的最小值，注意换行。 这个题就是经典的二分题目，暴力的做法就是直接 for 循环找到满足条件的最小的值。但是肯定是要超时的。 那么我们怎么就需要更高效的方法了。 二分 我们可以看出来，假设一个值 x（x是牛的距离） 不能使c头牛完全分配（即在距离为x的情况下隔间内放不下c头牛），那么比 x 大的值更不可以了；相反的，如果 x 能使c头牛完全分配（可行解，非最优解），那么比 x 大的值也可能使c头牛完全分配，从而最小距离也会变得更大。 理解了上面的方法，就可以像尺取一样找到可能的答案了。 这里说一句，对于二分题而言假设答案可能的取值区间为 [ 1 , x ] ,那么对于区间里面的每一个值是否是可行解一定是{可行，可行，…..，可行，不可行，……，不可行，不可行}这样的值规律（不排除全部可行或全部不可行的情况）。如果题目不是这样的规律，那么就无法使用二分的方法求解。 代码如下： 12345678910111213141516171819202122232425262728int n,c;int x[maxn];bool check(int s)&#123;//这个用到了贪心的思想 int sum=1;//初始一个隔间为a[0]，不进行计算 int pos=x[0];//pos是用来记录当前可行的最近的隔间的位置 for(int i=1;i&lt;n;i++)&#123; if(x[i]-pos&gt;=s)&#123;//这里判断当前隔间距离上一个隔间的距离是否不小于s pos=x[i];//当前位置可以放置牛，因此就把pos的值更新为当前隔间的位置 sum++; &#125; &#125; if(sum&gt;=c) return true; else return false;&#125;void solve()&#123; sort(x,x+n); int l=1,r=(x[n-1]-x[0])/(c-1);//由于需要放c头牛,最大距离为(x[n-1]-x[0),因此每头牛之间的距离最大就为(x[n-1]-x[0])/(c-1) 向下取整。 while(l&lt;=r)&#123; int mid=(l+r)/2; if(check(mid))&#123;//当前为可行解 l=mid+1;//由于为可行解，因此即使mid+1不为可行解，l的值也不会再改变，因此最后l的值为第一个不可行解 &#125; else&#123; r=mid-1; &#125; &#125; printf("%d\n",l-1);&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>尺取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂+矩阵快速幂]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%BF%AB%E9%80%9F%E5%B9%82-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[快速幂顾名思义，快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)， 与朴素的O(N)相比效率有了极大的提高。 以a^b为例，假设b=11，则$$a^{11}=a^{2^{0}+2^{1}+2^{3}}$$因为11的二进制为1011，11=2^0 +2^1+2^3,所以可得上式。 所以我们只要判断幂的二进制的值，就可以计算在log()级别的时间求解出答案。 12345678910int mod;int mulpow(int a,int n)&#123;//求a^n int res=1; while(n&gt;0)&#123; if(n&amp;1) res=res*a%mod;//如果当前位为1，则进行计算 a=a*a%mod;//a^(2^i),i为循环次数 n/=2; &#125; return res;&#125; 函数中间的运算数可能超过int的范围，所以当我们使用时要注意数据范围而选取适当的数据类型(int,long long)。 矩阵快速幂矩阵快速幂思想和快速幂一样，只不过由单纯的数字运算变成了矩阵运算（这里需要了解矩阵的运算方法）。 使用矩阵快速幂的场合一般为知道递推式，求解相应的第n项的值。 下面以这个式子为样例，来进行矩阵快速幂的讲解。$$a_{n}=2*a_{n-1}+1$$我们用这个式子构造一个矩阵：$$\left[ \begin{matrix} a_n \\ 1 \end{matrix}\right]=\left[ \begin{matrix} 2 &amp; 1 \\ 0 &amp; 1 \end{matrix} \right] *\left[ \begin{matrix} a_{n-1}\\ 1 \end{matrix}\right]$$如果没学过矩阵运算的相关知识，可以去百度进行学习。 然后我们继续递推：$$\left[ \begin{matrix} a_{n-1} \\ 1 \end{matrix}\right]=\left[ \begin{matrix} 2 &amp; 1 \\ 0 &amp; 1 \end{matrix} \right] *\left[ \begin{matrix} a_{n-2}\\ 1 \end{matrix}\right]$$ $$…$$ $$\left[ \begin{matrix} a_2 \\ 1 \end{matrix}\right]=\left[ \begin{matrix} 2 &amp; 1 \\ 0 &amp; 1 \end{matrix} \right] *\left[ \begin{matrix} a_{1} \\ 1 \end{matrix}\right]$$ 所以$$\left[ \begin{matrix} a_n \\ 1 \end{matrix}\right]={\left[ \begin{matrix} 2 &amp; 1 \\ 0 &amp; 1 \end{matrix} \right]}^{n-1} *\left[ \begin{matrix} a_{1}\\ 1 \end{matrix}\right]$$所以我们只需要求出中间的矩阵的结果就可以求出答案。 其大致步骤和快速幂一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct node&#123; int x[5][5];//一般构造的矩阵大小不会超过5，大小根据情况而定 &#125;;int mod,n,a1;node ope(node a,node b)&#123;//注意函数返回类型为 node,下面的 mulpow()函数返回类型同样是 node; node r; for(int i=0;i&lt;2;i++)&#123; for(int j=0;j&lt;2;j++)&#123; r.x[i][j]=0; for(int k=0;k&lt;2;k++)&#123;//这里是矩阵乘法的运算方法 r.x[i][j]+=a.x[i][k]*b.x[k][j]; &#125; &#125; &#125; return r;&#125;node mulpow(node a,int n)&#123; //这里用到了一个知识，一个矩阵乘以单位矩阵结果仍为原矩阵，所以这一步相当于快速幂里面的 res=1，具体详见百度百科 单位矩阵 node res; for(int i=0;i&lt;2;i++)&#123; for(int j=0;j&lt;2;j++) if(i==j) res.x[i][j]=1; else res.x[i][j]=0; &#125; while(n&gt;0)&#123; if(n&amp;1) res=ope(res,a); a=ope(a,a); n/=2; &#125; return res;&#125;void solve()&#123; //构造需要求幂的初始矩阵 node a; a.x[0][0]=2; a.x[0][1]=a.x[1][1]=1; a.x[1][0]=0; node s=mulpow(a,n-1); //最后一步矩阵乘法,参考前面最后展示的一个的矩阵 int res = s.x[0][0] * a1 + s.x[0][1]; printf("%d\n",res);&#125; 矩阵乘法也几乎是模板，其难点在于矩阵的构造，给你一个递推式，你必须推出相应的矩阵才可以进行运算，因此需要多学习一些矩阵的知识。 接下来展示一个Fibonacci的递推矩阵： Fibonacci的定义式：$$F(1)=f(2)=1\F(n)=F(n-1)+F(n-2) (n&gt;2)$$ 递推矩阵：$$\left[\begin{matrix} F(n)\\ F(n-1)\end{matrix}\right]=\left[\begin{matrix} 1 &amp; 1\\ 1 &amp; 0\end{matrix}\right]*\left[\begin{matrix}F(n-1)\\F(n-2)\end{matrix}\right]$$虽然这这个矩阵的第二个运算式子 F( n - 1 )=F( n - 1 ) 看起来是废话，但我们构造矩阵的目的是合理性，只要矩阵符合条件，就可以进行计算。 计算这个式子时需要注意矩阵快速幂的指数。 相关题目可以百度进行搜索。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[简介并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 简而言之，并查集就是将一些具有一定关系的元素进行合并，以此来减少查询的时间。 并查集是基于树形结构的数据而使用的。 问题提出接下来看一个题目： 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input 测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最少还需要建设的道路数目。 这个题就是经典的并查集。可以看出，当两个城镇互相联通（直接或间接）时，这两个城镇之间就不需要再进行任何道路建设。所以我们需要找出有多少个城镇集合是互不联通的。 如何说明和标记两个城镇是否互相联通？解决这个问题，就是我们的最终目的。 并查集给出一个上面题目的一个样例： 5 2 1 2 3 5 它所对应的图形为： 如果仅仅从图片上看，我们很明显的可以看出来答案是2。 由于所有元素各不相同，对于每个集合，总会有一个最小值，而我们一般把这个最小值作为每个集合的根节点。 以上图为例，1,2,3,4,5对应的根节点分别为 1,1,3,3,4。总共有3种根节点，因此答案为3-1=2； 也可以说，总共有3个元素对应的根节点是其本身。 并查集的作用就是是每个集合里面的元素都找到其对应的根节点。 当我们合并两个元素时，这两个元素可能并不是自己所在集合的根节点，因此我们需要找到其对应的根节点，然后将两个根节点进行合并。 网上有一个很形象的比喻： 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？ 我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。 但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1000+10;const int INF=0x3f3f3f3f;int n,m,u,v;int dep[maxn];void init()&#123;//刚开始每个节点的根节点都是其本身 for(int i=1;i&lt;=n;i++)&#123; dep[i]=i; &#125;&#125;int find(int x)&#123; if(x!=dep[x]) dep[x]=find(dep[x]);//这个的作用就是递归找到最后的根节点 return dep[x];&#125;void Union(int x,int y)&#123;//将两个元素进行合并，两个根节点不一样，就将两个根节点进行合并，大的合并到小的根节点上 int dx=find(x); int dy=find(y); if(dx&lt;dy) dep[dy]=dx;//将大的合并到小的上面 else dep[dx]=dy;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); init(); for(int i=0;i&lt;m;i++)&#123; scanf("%d %d",&amp;u,&amp;v); if(find(u)!=find(v)) Union(u,v);//如果两个元素根节点不一样，就进行合并 &#125; int res=0; for(int i=1;i&lt;=n;i++)&#123;//统计总共有多少个根节点，即集合 if(dep[i]==i) res++; &#125; printf("%d\n",res-1); return 0;&#125; 按照上面的例子，函数init()就是创造一个最初的江湖，find()就是用来找到自己的队长，Union()就是来将两位大侠所在的队伍结盟。对于一个队伍来说，队伍的操作只能由队长来进行，所以我们最后只需要将两个队长串联起来就可以了。]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2019%2F03%2F02%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背包问题是很经典的dp问题，在许多基础的比赛中都会用到。可以这样说，背包问题就是学习dp的第一步，但是其难度对于初学者来说也并不小。 这篇文章主要介绍一下基础的01背包和完全背包。 01背包01背包是最简单的背包问题，其大致描述为： 有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。 二维dp这里我们用一个二维数组dp[maxn][maxn] 来求解背包问题。 其中第一维表示前 i 个物品，第二维表示前 i 个物品在容量为 j 时的最大价值总和。 这里有一个状态方程： 1dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); dp[ i ][ j ]上面说过，表示的是前 i 件物品在容量为 j 时的最大价值，那么得到dp[ i ][ j ]，其中就涉及到了关于第 i 件物品选和不选的问题。 当我们选择第 i 件物品时，总容量为 j ，我们需要腾出来 w[ i ] 的空间来装第 i 件物品，因此得出当选择第 i 件物品时的最大价值 dp[ i - 1 ][ j - w[ i ] ] + v[ i ]。 当我们不选择第 i 件物品时，那么之前的容量也必然为 j ，因为没有东西放进去，所以我们可以得到当不选择第 i 件物品时的最大价值 dp[ i - 1 ][ j ]。 理解了方程的意义，我们就可以写出来解决背包问题的代码了。 123456for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=V;j++)&#123; if(j&lt;v[i]) dp[i][j]=dp[i-1][j];//容量太小，装不下第 i 个物品 else dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]); &#125;&#125; 最终求出来的dp[N][V]即为答案。 这是用二维数组来求解最大价值。我们如果在纸上模拟这个过程，会发现在两层 for 循环的情况下，每个位置的值只会变化一次，当第 i 行求解完之后，我们就再也不会改变第 i 行的值了。 那么这对空间的要求是巨大的，我们是否可以把二维数组压缩成一位数组？答案是可以！ 一维dp我们如果在纸上模拟这个过程，会发现在两层 for 循环的情况下，每个位置的值只会变化一次，当第 i 行求解完之后，我们就再也不会改变第 i 行的值了。 上面的代码过程用图像可以表示为： 从上面代码和图片中可以看出，影响dp[ i ][ j ]的值为 dp[ i - 1][ j ] 和dp[ i - 1 ][ j - w[ i ] ]，两个数的一维二维坐标均小于等于 i , j ，所以我们第一步先改变一下循环的顺序： 123456for(int i=1;i&lt;=N;i++)&#123; for(int j=V;j&gt;=1;j--)&#123;//这里的循环顺序改变了 if(j&lt;v[i]) dp[i][j]=dp[i-1][j]; else dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]); &#125;&#125; 如果表示成一维的话，那么过程就变成了： 可以发现，此时代码中 if(j&lt;v[i]) dp[i][j]=dp[i-1][j] 已经失去了原本的作用。 然后将二维数组压缩成一位数组： 12345for(int i=1;i&lt;=n;i++)&#123; for(int j=V;j&gt;=w[i];j--)&#123;//根据上面的代码，这里假如j&lt;w[i]时，dp[j]=dp[j],可以直接省略 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125;&#125; 在这里可能有人疑问，为什么循环顺序要变化？ 当我们从前往后改变一维数组的值时，我们可能会改变了后面的数的正确的值，因为后面的数还会用到前面的是，从而导致最终结果偏离正确结果。 所以我们选用从后往前的方式进行遍历，前面已经说过，影响这个元素的值一维二维坐标均小于当前坐标，所以即使我们改变了后面的数值，也不会对前面的值有影响。 这样，我们就可以节省大量的空间（还在第二层循环时减少了时间）。 完全背包 有N种物品和一个容量为V的背包。第i种物品的重量是w[i]，价值是v[i]。每种物品都可以无限件使用。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。 完全背包和01背包最大的区别就是物品件数的改变。完全背包每种物品可以无限次使用，而01背包只是用一次。 我们再来看一下01背包一维dp时循环顺序的问题。 上面已经说过，假如第二层for循环的顺序是j++，那么最终结果会偏离正确结果。但是是怎么偏离的呢？我们继续深入探讨一下。 假如dp[ j ]&lt;dp[ j - w[ i ] ] + v[ i ] ，那么dp[ j ]=dp[ j - w[ i ] ] + v[ i ]， 然后对于 k ( j &lt; k &lt;= V)，如果dp[ j ]影响到了dp[ k ] ，那么影响的结果一定是dp[ k ] = dp[ k - w[ i ] ] + v[ i ],其中 k - w[ i ] = j ( 只考虑直接影响 )， 所以我们可以继续递推得出dp[ k ] = dp[ j - w[ i ] ] +v[ i ] +v[ i ]=dp[ j - w[ i ] ] + 2 * v[ i ]。 这里我们就发现，v[ i ]被使用了两次，这在01背包中肯定是错误的，但是在完全背包中却没有任何问题，因为每件物品可以无限次使用，因此我们就可以得出完全背包的求解方法： 12345for(int i=1;i&lt;=n;i++)&#123; for(int j=w[i];j&lt;=V;j++)&#123; dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125;&#125; 这和01背包的区别只在于第二层循环的顺序。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长单调子序列]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[最长上升子序列（LIS） 问题描述： ​ 给你一个序列，让你求出其中的最长的上升子序列。 ​ 比如数组{1,5,3,2,4},其最长递增子序列为{1,3,4}或{1,2,4}。 dp求解（小范围数据）在长度 n 较小的情况下，我们可以用dp的方式来求解，复杂度为O(n^2) : 1234567891011121314int n;int dp[maxn];int a[maxn]; int LIS()&#123; int res=0; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(a[i]&lt;a[j]) dp[j]=max(dp[j],dp[i]+1); //如果是最长非递减的话，则if(a[i]&lt;=a[j]) &#125; res=max(res,dp[i]); &#125; return res+1;&#125; 这个理解起来还算容易：当我们求出前m（m&lt;=n）个数的LIS长度时，那么我们就可以求出当前状态下m后面的数的最长长度。 因为m和m+1之间没有其他的数字，所以我们可以认为我们求出了前m+1个数的LIS长度。 然后依次递推，就可以求出n个数的LIS。 dp求解（大范围数据）当n比较大时,O(N^2)的时间复杂度明显没办法满足需要，所以我们需要更高效的方法。 当我们循环遍历时，我们可以把当前的最长的LIS存储下来。 对于样例{1,5,3,2,4}，我们储存的顺序依次为： {1}， {1,5} {1,3} {1,2} {1,2,,4} 这个刚开始理解起来比较难理解。对于第二步{1,5}来说，当前的LIS长度为2，由LIS的特性可知，我们希望前面的元素尽量的小。 所以当遍历到第三个元素时，由于{1,5}，{1,3}长度均为2，但我们更希望值小一点，所以我们就用3来代替了5的值。 第四个元素也一样。 第五个元素{4}，由于当前我们保存的LIS{1,2}最大值小于4，因此我们就把4放进来，所以最终结果就为3。 注意：储存的元素并不是LIS的值，这个储存的值只是用来寻找LIS的。 再来看一个样例：{1,3,5,4,6,2}，存储的顺序依次为： {1} {1,3} {1,3,5} {1,3,4} {1,3,4,6} {1,2,4,6} 对于第6步，因为2&lt;6，所以我们一定能找到替换2的元素。而我们希望储存的序列尽可能的小，所以我们需要找到2能替换的最小的元素。因此我们的替换操作为3 -&gt; 2。 这一步可以理解为：找到储存的序列中比当前元素大（或者相等）的第一个元素，进行替换。 因为我们在储存时保证了储存的元素单调，因此我们在寻找替换位置时可以用高效的二分法，所以这种方法的复杂度为O( n*log(n) )。 12345678910111213141516171819202122232425int n;int dp[maxn];int a[maxn];int find(int x)&#123; int l=0,r=n-1,mid; while(l&lt;r)&#123; mid=(l+r)/2; if(dp[mid]&lt;x)&#123;//小于的话肯定不是被替换的元素，因此可以+1 l=mid+1; &#125; else&#123;//大于等于的情况下这个元素可能是被替换的元素，所以我们不能忽略这个元素 r=mid; &#125; &#125; return l;&#125;int LIS()&#123; fill(dp,dp+n,INF);//将dp里面的元素全部替换为INF for(int i=0;i&lt;n;i++)&#123; int pos=find(a[i]); dp[pos]=a[i]; &#125; int res=find(INF); return res;&#125; 输出LIS的元素在前面已经说过，储存的值并不是LIS的元素，那么我们如何来输出LIS呢？ 前面已经说过，我们的操作都是找到储存的序列中第一个比当前元素大（或者相等）的位置，那么这个元素的前面一个元素一定是它左边的那个元素，因此我们需要用一个数组来储存每个元素的前驱。 因此我们在上面的代码上做一些小修改： 1234567891011121314151617181920212223242526272829303132int n;int dp[maxn];int a[maxn];int pre[maxn];//用来记录每个元素的前驱void output(int x)&#123;//用来输出LIS的元素（可能有多个答案，这里只取其中一种） if(pre[x]!=0) output(pre[x]); printf("%d ",x);&#125;int find(int x)&#123; int l=0,r=n-1,mid; while(l&lt;r)&#123; mid=(l+r)/2; if(dp[mid]&lt;x)&#123;//小于的话肯定不是被替换的元素，因此可以+1 l=mid+1; &#125; else&#123;//大于等于的情况下这个元素可能是被替换的元素，所以我们不能忽略这个元素 r=mid; &#125; &#125; return l;&#125;int LIS()&#123; fill(dp,dp+n,INF);//将dp里面的元素全部替换为INF for(int i=0;i&lt;n;i++)&#123; int pos=find(a[i]); dp[pos]=a[i]; pre[ dp[pos] ]=dp[pos-1];//当前元素所对应的前一个元素的值。 &#125; int res=find(INF); output(dp[res-1]); return res;&#125; 这样，我们就可以输出LIS的元素了。 最长下降子序列（LDS)最长下降子序列求解方法和LIS相似，只需要把元素的位置翻一下即可求解。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD与LCM及其部分性质]]></title>
    <url>%2F2019%2F02%2F01%2FGCD%E4%B8%8ELCM%E5%8F%8A%E5%85%B6%E9%83%A8%E5%88%86%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[GCDGCD，即最大公约数，指两个或多个整数共有约数中最大的一个。 求最大公约数有多种方法，常见的有质因数分解法、短除法、辗转相除法、更相减损法。 在一般竞赛中，求GCD一般使用辗转相除法。其复杂度约为O(log(max(n,m)))，是一种很高效的算法。而且其代码量也非常少 1int gcd(int a,int b) &#123; return b ? gcd(b,a%b) : a; &#125; 拓展性质如果GCD( n , a ) = 1 , n&gt;a 则GCD( n , n - a ) = 1。 可以用反证法证明 假设GCD( n , n - a ) = i ( i &gt; 1 )，设 n = k1 * i，n - a = k2 * i（ k1 &gt; k2 &gt; 0 ）， 则 n -( n -a ) = a = (k1-k2) * i，与GCD( n , a ) = 1 矛盾，所以上述性质成立。 扩展欧几里得算法设a , b为常数，对于一个表达式 a * x + b * y =GCD( a , b ) ，一定存在解（ x , y）使之成立。 我们就可以通过扩展原来的辗转相除法来求解。 求解的过程如下（最好自己手推一下）： 初始表达式$$a * x + b * y =GCD( a , b )$$由之前的知识可得$$GCD( a , b ) =GCD( b , a \% b )$$因此$$a*x_1+b*y_1=GCD( a , b ) =GCD( b , a\%b ) =b*x_2+(a\%b)*y_2$$ $$a\%b=a-[a/b]*b$$ 其中[a/b]表示整除。带入化简可得：$$a*x_1+b*y_1=a*y_2+b*(x_2-[a/b]*y_2)$$由恒等关系可得$$x_1=y_2$$ $$y_1=x_2-[a/b]*y_2$$ 因此我们只要求出 x2 和 y2 的值就可以求解 x1 和 y1。而 x2 , y2 可通过同种方法求解。 特别的，当 b=0时，表达式为 a * x + b * y = GCD( a , b ) =GCD( a , 0 ) = 0 此时,可求得 x = 1 。y 的值对表达式的值没有影响。 上面就是求解初始表达式的方法。 代码如下： 12345678910111213int extGcd(int a,int b,int &amp;x,int &amp;y)//这里取 x , y的地址 &#123; if(b==0) &#123; x=1;y=0; return a;//函数的返回值一直是 gcd(a,b) &#125; int r=exGcd(b,a%b,x,y); int t=x; x=y; //x1=y2 y=t-a/b*y; //y1=x2-[a/b]*y2 return r;&#125; LCMLCM，即最小公倍数，指两个或多个整数共有倍数中最小的一个。 LCM的求法可以基于GCD的基础上：$$LCM(a,b)=a*b/GCD(a,b)$$证明略。 一般题目求解时使用GCD更多一些，所以LCM相关知识就不多写了。(我也没找到太多关于LCM的相关文献)]]></content>
      <tags>
        <tag>GCD</tag>
        <tag>LCM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数及其部分性质]]></title>
    <url>%2F2019%2F02%2F01%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E9%83%A8%E5%88%86%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[欧拉函数欧拉函数在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。 从欧拉函数引伸出来在环论方面的事实和拉格朗日定理构成了欧拉定理的证明。 欧拉函数的适用范围非常大，许多题目中都会用到欧拉函数的性质。 欧拉函数表达式1：欧拉函数的表达为：$$\varphi (x)=x\prod_{i=1}^{n}{(1-\frac{1}{p_i})}$$ 其中p1,p2,…,pn 表示x的所有质因子，x是不为0的整数。 欧拉函数表达式2：假设$$x= {p_1}^{k_1} * {p_2}^{k_2} * … * {p_n}^{k_n}$$ p1,p2,…,pn同上，则其另一种表达为：$$\varphi(x)=\prod_{i=1}^{n}{(p_i-1)*p_i^{k_i-1}}$$ 特别的，$$\varphi(1)=1$$ 欧拉函数证明容斥定理来证明对于正整数 x 而言，假设其质因子为p1,p2,p3,…,pn，则小于等于 x 且与 x 不互质的数字的个数为：$$g(x)=\frac{x}{p_1}+\frac{x}{p_2}+…+\frac{x}{p_n}-\frac{x}{p_1*p_2}-\frac{x}{p_1*p_3}- …$$ 小于 x 且与 x 互质的数字的个数：$$f(x)=x-g(x)=n-\frac{x}{p_1}-\frac{x}{p_2}- … -\frac{x}{p_n}+\frac{x}{p_1*p_2}+\frac{x}{p_1*p_3}+ …$$ 化简即可得表达式1。（具体化简过程我也不会QAQ） 欧拉函数计算单值计算在编程时，习惯上，我们经常用表达式2计算欧拉函数的值： 12345678910111213141516171819int eular(int n)&#123; int ret=1,i; for(i=2;i*i&lt;=n;i++) &#123; /* n%i==0时，i为n的质因子，因为如果i不是质因子， 则一i定能分成更小的因子，对应的更小的因子一定在之前出现过了，与之矛盾， 所以i一定不能分割成更小的因子，即i为n的质因子。 */ if(n%i==0) &#123; n/=i,ret*=i-1; while(n%i==0) n/=i,ret*=i; &#125; &#125; if(n&gt;1) ret*=n-1; return ret;&#125; 打表计算欧拉函数性质互质数之和小于n的正整数中与n互质的数的数字之和为$$f(n)={n}*\frac{\varphi(n)}{2}$$ 证明如下： 对于每个小于 n 的数正整数 a ，如果gcd( n , a )=1,则gcd( n , n-a )=1（ 此处为gcd相关性质，不再证明。）。 所以对于每个与 n 互质的正整数 a ，一定有一个与之对应的与 n 互质数的 n - a ; 由此可知，欧拉函数的值总为偶数（1除外），并且总有一对之和为 n， 至此，小于n的正整数中与n互质的数的数字之和就可以计算出来了。 积性函数欧拉函数是一个积性函数，如果 n , m 互质，则：$$\varphi(nm)=\varphi(n)*\varphi(m)$$可以推出，如果n为质数，则：$$\varphi(2n)=\varphi(n)$$ 欧拉定理变式对于任何两个互质的正整数 a , n ，(n&gt;2)$${a}^{\varphi(n)}\equiv 1 mod n$$ 费马小定理当 n = p 且 a 与素数 p 互质时，上式可变为 $${a}^{p-1}\equiv 1 mod p$$ n的因数（包括1和它自己）的欧拉函数之和等于n写成数学表达式的形式即为$$n=\sum_{d|n}\varphi(d)$$其中 d|n 表示 n 能被 d 整除。 证明如下： 对于每个 x ( 0 &lt;= x &lt;= n ) 都存在一个gcd( x , n )，可以证得，其值必然为n的因子。 假设gcd( x , n ) = d ,（ d | n ） ，则gcd（ x / d , n / d ）= 1 ，即 x / d 与 n / d 互质。 因此，我们可以求出 gcd( x , n ) 的值为 d 时对应的的数字个数，个数就是 n / d 所对应的欧拉函数值。 由第一行可知，gcd( x , n )的值必然为n的因子，并且只有唯一对应值，因此就可推导出上述公式。]]></content>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2036（多边形面积）]]></title>
    <url>%2F2019%2F01%2F17%2FHDU-2036%2F</url>
    <content type="text"><![CDATA[题目大意： 给你一个多边形，求它的面积。 多边形面积可以用向量知识来求解。 对于一个凸多边形，如下： 其面积可以表示为 S = S△OAB+S△OBC+S△OCD+S△ODE 对于△OAB 其面积用向量表示为 0.5 * |OA| * |OB| * sin∠AOB=0.5 * | OA x OB| 其中OA x OB表示叉乘（非点乘，具体详见百度百科“向量积”） 但因为向量叉乘有正有负，所以我们取的是绝对值，保证题目答案的正负。（正负取决于两条边的位置状态） 这时候就可以简单的计算出多边形的面积。 对于一个 凹多边形，如下： 其面积依然就可以用向量的方法求解 假设点O为坐标原点，则 S = S△OAB+S△OBC+S△OCD+S△ODE+S△OEA S△OAB = 0.5 * OA x OB =0.5 * ( A.x * B.y - A.y * B.x ) 其中S均表示在叉乘意义下的值，由于其具有正负之分，所以可以用来计算凹多边形的面积（具体证明过程略）。 这时候就可以计算出多边形的面积。 代码如下： 12345678910111213141516171819202122232425# include&lt;bits/stdc++.h&gt;using namespace std;# define ll long longint main()&#123; int n,i; double a[1000]; double b[1000]; while(~scanf("%d",&amp;n) &amp;&amp; n)&#123; for(i=1;i&lt;=n;i++)&#123; scanf("%lf %lf",&amp;a[i],&amp;b[i]); &#125; a[0]=a[n]; b[0]=b[n]; double res=0; for(i=0;i&lt;n;i++)&#123; res=res+(a[i]*b[i+1]-b[i]*a[i+1])/2;//由于是逆时针方向，所以求出来结果为正。 &#125; printf("%.1lf\n",res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广西大学第一届程序设计大赛-数论只会GCD]]></title>
    <url>%2F2019%2F01%2F16%2F%E5%B9%BF%E8%A5%BF%E5%A4%A7%E5%AD%A6%E7%AC%AC%E4%B8%80%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-D%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述 小西买了一堆肥宅快乐水和肥宅快乐茶，准备和室友比谁更肥宅。 快乐水有A瓶，快乐茶B瓶。 小西和室友的规则是这样的： 小西先手，轮流到每个人的回合，每个回合只能喝剩余数量较多的饮料 满足规则1的同时，每次只能喝另一种饮料剩余数量的正整数倍 满足1、2的同时，不能超额喝饮料，也就是说剩下2瓶的时候不能喝大于2瓶的数量。 每个人在自己的回合如果能喝完剩下的其中一种饮料，那么就获得胜利。 例如A=10，B=2。 小西只能喝快乐水，且只能喝2/4/6/8/10瓶快乐水。小西可以喝10瓶快乐水直接获得胜利。 小西和室友都是肥宅，所以他们都会才采取为了胜利最优的行动。 现在请你判断小西是否能赢得胜利。 输入描述: 第一行输入一个整数T，表示有T组数据 接下来T行，每行为一组数据，每行有两个正整数表示A和B的初始数量 1 ≤ T ≤ 500 , 1 ≤ A,B ≤ 10^12 输出描述: 对于每组数据，若小西可以获得胜利则输出一行“wula”，否则输出一行“mmp”，不需要输出引号 你真的会GCD吗 这道题其实就和求GCD的过程有关。 求GCD的过程就是GCD( a , b ) = GCD( b , a % b )，其过程就是把 a 减去 b 的正整数倍，然后依次递归求解。 那么对于这个题，最后的状态一定是一个数量为 0 ，一个数量为正整数。而逆推就可以得到题目给出的 A , B 值。 假设 A &lt; 2 * B,那么接下来的操作之后一定是（ A - B , B），接下来也一直持续这个过程，而且这个过程是可以一直递推求出来唯一解的。 假如 A &gt; 2 * B , 那么因为两人足够聪明，接下来的状态可以变为（ A , A%B）或者（ A , A % B + A ）。 可以看到，第二个状态只能有一种操作：（ A , A % B + A ）- &gt;（ A , A%B）,因此这个时候可操作的人就能够随意挑选这两种状态之一来掌握自己的胜负。 假设A % B=0 那就不多说了，直接就赢了。 代码如下： 12345678910111213141516171819202122232425262728293031# include&lt;bits/stdc++.h&gt;using namespace std;# define ll long longint main()&#123; ll t,a,b; scanf("%lld",&amp;t); while(t--)&#123; scanf("%lld %lld",&amp;a,&amp;b); ll flag=1;//用flag来记录当前的赢家，因为此时我们并不知道谁有主动权 while(true)&#123;//遇到可以判断赢家的条件时，循环就结束了 if(a&gt;b) swap(a,b); if(b%a==0) break; else if(a*2&lt;b) break; else&#123; flag*=-1; b=b-a; &#125; &#125; if(flag==1)&#123; printf("wula\n"); &#125; else&#123; printf("mmp\n"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数筛选法]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95%2F</url>
    <content type="text"><![CDATA[素数，是指因子只包含1和其本身的数，那么，我们怎么大批量的判断素数呢？ （以下代码均基于打表（1~1e6）的基础上完成） 1.按照定义计算素数的定义就是一个数的因子只包含1和其本身，那么我们直接就按照定义写： 12345678910111213141516171819202122# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int pri[maxn];int isprime(int n)&#123; for(int i=2;i&lt;n;i++) if(n%i==0) return 0; return 1;&#125;int main()&#123; pri[1]=0; for(int i=2;i&lt;=maxn;i++)&#123; pri[i]=isprime(i); &#125; return 0;&#125; 这是最基础的写法，也是最小白的写法。 这种算法的复杂度为O(n^2),复杂度非常的大，对于1e6的数据范围来说肯定要超时，那么还有没有更优化的算法？答案是肯定的 2.基于定义计算的优化算法我们对一个合数进行考虑，例如12： 它的因子有1 2 3 4 6 12 ，而且112=12 ， 26=12 ， 3*4=12 可见，每一个因子都会有另一个对应的因子，观察可得，它们的分布是平均的，左边的一半对应右边的一半，那么最中间的分界线应该是什么？ √n 。 因此，我们只需要对√n 前面的数字进行判断即可。 12345678910111213141516171819202122# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int pri[maxn];int isprime(int n)&#123; for(int i=2;i*i&lt;=n;i++)//只需要将i变成i*i即可 if(n%i==0) return 0; return 1;&#125;int main()&#123; pri[1]=0; for(int i=2;i&lt;maxn;i++)&#123; pri[i]=isprime(i); &#125; return 0;&#125; 这种算法的复杂度要比上一种好的多，复杂度为O(n√n),但是对于1e6的数据范围来说还是太大了。有没有再快一点的算法？ 3.素数筛选法素数筛选法的思想为： 从2开始，因为2的倍数一定不是素数，所以先把2的倍数全部删去； 接着找下一个素数3，把3的倍数全部删去； 因为4是2的倍数，已经被删去，所以直接找下一个素数5，把5的倍数全部删去； 接着7的倍数，11的倍数，……直到把1e6范围内的合数全部筛选出去，剩下的即为素数： //以下优化均基于打表的基础上 1234567891011121314151617181920212223242526# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int vis[maxn];void isprime()&#123; memset(vis,0,sizeof(vis));//此处vis[i]=1表示不是素数，vis[i]=0表示是素数 vis[1]=1; //由于i*i的数据范围可能会超过int，所以需要用long long表示 for(long long i=2;i*i&lt;=maxn;i++)&#123;//此处有优化，因为如果一个合数&gt;sqrt(maxn),那么他必定在前面已经被标记过。 if(!vis[i])&#123; for(long long j=i*i;j&lt;=maxn;j+=i)&#123;//此处也有优化，我们只需要判断从i*i开始判断即可。 vis[j]=1; &#125; &#125; &#125;&#125;int main()&#123; int n; isprime(); return 0;&#125; 这种算法的复杂度应该为O(n);，是一种非常快速的判断素数的算法。 上述代码有两处优化，第一处优化的证明如下： 假设 maxn &gt; i &gt; sqrt(maxn)并且为合数，那么，他肯定会有一个因子小于等于sqrt(maxn)，因此，i一定在之前已经被标记过了。 第二处优化证明为： 假设i&gt;2，那么对于 i * ( i - 1 )： 如果 i - 1是素数，那么 i * ( i - 1 ) 一定在之前已经被标记过； 否则，如果 i - 1 是合数，那么 i - 1能被分成更小的素数。设其中一个为a，那么 i ( i - 1 )= i ( i - 1 ) / a * a 也一定被标记过。 优化后的算法时间会节省非常多，在平常的算法竞赛中，用上述代码就已经可以解决大部分的涉及素数打表的问题。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马小定理--轻松判断大质数]]></title>
    <url>%2F2019%2F01%2F09%2F%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86-%E8%BD%BB%E6%9D%BE%E5%88%A4%E6%96%AD%E5%A4%A7%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述在算法竞赛中你会遇到各种各样的有关素数的问题，今天你来解决一个最基础的问题：如何判定一个素数。对于给定的正整数p，若p非素数，输出-1若p是素数 输出 ：{sigma(a^(p-1) % p) ，其中a的下界为1，上界为p-1} 即： $$\sum_{a=1}^{p-1}({a^{p-1}\%p})$$输入 多实例测试，每组数据包含一个正整数p（p &lt; 10^16）。 输出 根据情况输出一个正整数，保证答案在int64之内，输出占一行。 样例输入 2 样例输出 1 这个题一般方法是就是暴力求解了，首先判断是不是素数，如果不是素数，那么输出-1，如果是素数，那么就实处上面那个式子的值。 但是题目要求的数据范围为1e16，如果我们用一般判断素数的方法（sqrt(n)）去求解的话，必定会超时，那么我们如何解决这个问题呢，费马小定理出现了。 费马小定理 假如p是质数，且gcd(a,p)=1，那么 a(p-1)≡1（mod p），例如：假如a是整数，p是质数，则a,p显然互质(即两者只有一个公约数1)，那么我们可以得到费马小定理的一个特例，即当p为质数时候， a^(p-1)≡1(mod p)。 因此，我们可以随机几个数字（与p互质），如果a^(p-1)≡1（mod p）对这些数字恒成立，那么p就是一个质数。 一般情况下，我们只需要列举十个左右的数字即可确定一个数字是否为质数。 代码如下： 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll n;ll gcd(ll a,ll b)&#123; return b?gcd(b,a%b):a;&#125;ll mulpow(ll a,ll x)&#123; ll res=1; while(x)&#123; if(x&amp;1) res=res*a%n; a=a*a%n; x&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll t,i; //以下是我自己列举的一些随机数，我们也可以用一些随机数函数来找一些随机数 ll a[20]=&#123;7,43,64,69,87,31,45,72,81,79,47,33,43,97,121,199,173,153,157,53&#125;; while(~scanf("%lld",&amp;n))&#123; for(i=0;i&lt;20;i++)&#123; if(gcd(a[i],n)==1 &amp;&amp; mulpow(a[i],n-1)!=1)&#123;//两个判断条件，两个数字互质且符合费马小定理 break; &#125; &#125; if(i==20)&#123; printf("%lld\n",n-1); &#125; else printf("-1\n"); &#125; return 0;&#125; 用以上方法即可迅速判断一个数是否是质数，对特别大的数字尤其适用。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>费马小定理</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算数基本定理 + 容斥定理]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%AE%97%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86-%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[算数基本定理定义：任何一个大于1的自然数，如果N不为质数，那么N可以分解成有限个质数的乘积，并且在不计次序的情况下，这种分解方式是唯一的。 例如：60可以分解为 2^2 * 3 * 5 数学公式描述 N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn （P1&lt;P2&lt;P3&lt;…=0） 质因子分解计算方法 算法复杂度 ( O(√n) )123456789101112map&lt;int,int&gt; prime_factor(int n)&#123; map&lt;int,int&gt;ans; for(int i=2;i*i&lt;n;i++)&#123; while(n%i==0)&#123; ++ans[i]; n/=i; &#125; &#125; if(n!=1) ans[n]=1; return ans;&#125; 算数基本定理的应用如何求N有几个因子？ 根据算数基本定理：N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn 根据排列组合得到结果： ans=(1+r1) * (1+r2) * (1+r3) * … * (1+rn) 如何求N的所有因子之和？ 根据算数基本定理：N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn 求GCD(X,Y)和LCM(X,Y) 根据算数基本定理： X=P1^x1 * P2^x2 * P3^x3 * … * Pn^xn Y=P1^y1 * P2^y2 * P3^y3 *… * Pn^yn 根据GCD和LCM的定义 容斥定理要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分， 依此类推，一直计算到所有集合相交的部分。 用Venn图来表示 数学公式描述 如果要对n个物体进行选择，那么有多少种情况？ 代码复杂度为O(2^n) 123456for(int i=0;i&lt;(1 &lt;&lt; m);i++)&#123; for(int j=0;j&lt;n;j++)&#123; printf("%d",i&gt;&gt;j &amp; 1); &#125; puts("");&#125; 容斥定理的应用问题：魔镜给小明m个数字（a1、a2 …… am）和一个整数n，魔镜定义：如果有一个数，是这m个数字里面任意一 个数的倍数，那么这个数称为LuckyNumber。而小明会的题数为[1,n]闭区间内LuckyNumber的数量。 (0 &lt; m &lt; 15) 那么请你帮小明计算一下他会的题目数。 代码 复杂度为O(2^n) 123456789101112131415LL ans=0;for(int i=1; i&lt;(i&lt;&lt;m);i++)&#123; int cnt=0; LL LCM=1; for(int j=0;j&lt;m;j++)&#123; if(1&amp;(i&gt;&gt;j))&#123;//按位运算判断第m个数是否使用 cnt++; LCM=lcm(LCM,a[j]); &#125; &#125; if(cnt&amp;1) ans+=n/LCM;//判断n中元素使用的个数，奇加偶减 else ans-=n/LCM;&#125;printf("%lld\n",ans);]]></content>
      <tags>
        <tag>算法</tag>
        <tag>算数基本定理</tag>
        <tag>容斥定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS与DFS]]></title>
    <url>%2F2019%2F01%2F08%2FBFS%E4%B8%8EDFS%2F</url>
    <content type="text"><![CDATA[BFS(宽度优先搜索)宽度优先搜索算法（又称广度优先搜索算法）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。 他并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。 举例： 由橙色位置出发，进行BFS： ​ 灰色位置表示已经走过，橙色标示当前位置 首先进行第一步： ​ 已经走过的位置，不需要再走了 进行第二步： ​ 同上，状态继承，进行第三步： ​ 进行第四步，到达终点，当前步数表示最小步数： ​ 对于一个迷宫而言，我们要进行的步骤是一样的。 ​ 蓝色是起点，红色是终点，黑色为障碍物。 第一步，我们可以走以下几步： ​ 接下来依次为： 当我们走到第十步时，走到了终点，因此，从起点到终点最少的步数即为10步。 接下来看一道基础的例题（HDU1242）Rescue： Problem Description Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison. Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards. You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.) Input First line contains two integers stand for N and M. Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend. Process to the end of the file. Output For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.” Sample Input 123456787 8#.#####.#.a#..r.#..#x.....#..#.##...##...#.............. Sample Output 113 这个题大概的意思就是求从字符a出发，到达字符r的最少时间，其中 . 代表空地，#代表墙，x代表守卫，每杀死一个守卫我们就需要消耗一秒的时间。 这个题可以用BFS直接求解，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;# include&lt;string.h&gt;# include&lt;algorithm&gt;# include&lt;queue&gt;using namespace std;# define MAXN 510char str[MAXN][MAXN];//用来储存地图 int vis[MAXN][MAXN];//用来标记已经走过的地点 int n,m;struct name&#123; int x; int y; int step;&#125;;bool operator &lt;(name i,name j)&#123;//对走过的地点顺序进行排序 return i.step&gt;j.step;&#125;int d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;//表示行走的四个方向，顺序为右，左，上，下 int BFS(int sx,int sy,int ex,int ey)&#123; memset(vis,0,sizeof(vis)); priority_queue&lt;name&gt;que;//使用队列用来储存上一步走过的地点 name e1,e2; e1.x=sx,e1.y=sy,e1.step=0; que.push(e1);//输入起点 vis[sx][sy]=1; int ans=-1; int i; while(!que.empty())&#123;//当队列为空时，即表示我们已经把所有的能走的地点都走了一遍 e1=que.top();//将队列第一个地点的信息赋给e1； 此时e1即表示上一步走过的地点的信息 que.pop(); if(e1.x==ex &amp;&amp; e1.y==ey)&#123;//对这个地点进行判断，看是否是是终点 ans=e1.step; break; &#125; for(i=0;i&lt;4;i++)&#123;//如果e1不是终点，那么对e1的上下左右进行判断，如果可以走，那么就将信息储存在队列中 e2.x=e1.x+d[i][0]; e2.y=e1.y+d[i][1]; if(e2.x&lt;0 || e2.x&gt;=n || e2.y&lt;0 || e2.y&gt;=m) continue;//对边界进行判断，如果超出边界，则不进行保存 if(vis[e2.x][e2.y]==1) continue;//如果当前位置已经走过，那么就不进行保存 if(str[e2.x][e2.y]=='#') continue;//如果是墙壁,不进行保存 if(str[e2.x][e2.y]=='x') e2.step=e1.step+2;//如果是守卫的话，需要消耗两个单位时间 else e2.step=e1.step+1;//如果是空地,一个单位时间 que.push(e2);//将地点存入队列 vis[e2.x][e2.y]=1;//降低点进行标记 &#125; &#125; if(ans==-1)&#123; printf("Poor ANGEL has to stay in the prison all his life.\n"); &#125; else&#123; printf("%d\n",ans); &#125; &#125;int main()&#123; int i,j; while(~scanf("%d %d",&amp;n,&amp;m))&#123; for(i=0;i&lt;n;i++)&#123; scanf("%s",str[i]); &#125; int sx,sy,ex,ey; for(i=0;i&lt;n;i++)&#123;//找寻起点和终点 for(j=0;j&lt;m;j++)&#123; if(str[i][j]=='a') sx=i,sy=j; if(str[i][j]=='r') ex=i,ey=j; &#125; &#125; BFS(sx,sy,ex,ey);//开始BFS &#125; return 0;&#125; 从代码中可以看出，我们使用BFS的步骤为： 1.对地图信息进行保存 2.找到起点和终点信息 3.从起点开始，对所走过的每一步进行判断 4.如果走的这一步可行，那么储存这一步的信息，并标记这个位置，表示不会再走到这个位置 5.如果不可行，那么就不进行操作 6.找到终点 以上，即为BFS的功能。 DFS(深度优先搜索)DFS的目的是要达到被搜索结构的叶结点。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。 DFS的使用基础为递归，当我们顺着一个节点向下走时，如果走不下去了，就回溯，如果上一个节点还有其他的节点，那么我们就会对这个节点再进行搜索。 对于下面这个图 首先我们将从第一个节点开始出发，然后搜索第二个节点， 因为第二个节点下面还有第四个节点，因此我们继续向下搜索， 第四个节点下面已经没有其他节点，因此我们回溯到第二个节点 第二个节点下面还有第五个节点，因此我们搜索第五个节点 然后继续回溯，到第一个节点， 接下来就搜索第三个节点，第五个节点 当再次回溯到第一个节点时，已经没有其他的节点可进行搜索，因此搜索的过程到此结束，DFS也到此结束。 上面就是DFS的功能，DFS是对所有可能的结果进行一次彻底的搜索，这样会保证不会有任何情况会被遗漏。 接下来看一道例题（HDU1312）Red and Black： There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. Write a program to count the number of black tiles which he can reach by repeating the moves described above. Input The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. ‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set) Output For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input 1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output 12344559613 这个题的大概意思就是给你一个起点，你能够走到多少个地点。 其中 ‘ . ‘是空地，#是墙壁，@是起点。 接下来看一下代码，思想和BFS类似： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define clr(a) memset(a,0,sizeof(a))const int MAXN = 1e5+10;const int INF = 0x3f3f3f3f;const int N = 30;int n,m,sum;char mapp[N][N];//储存地图 int vis[N][N];//标记位置 int dx[4] = &#123;1,-1,0,0&#125;;//四个行走方向 int dy[4] = &#123;0,0,1,-1&#125;;bool check(int x,int y)&#123;//检测不能走通的条件 if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||mapp[x][y]=='#')&#123; return false; &#125; else return true;&#125;void DFS(int x,int y)&#123; if(!check(x,y)||vis[x][y])&#123;//如果不能走通，那么直接返回 return ; &#125; else&#123; sum++; int fx,fy; for(int i=0;i&lt;4;i++)&#123;//在此节点的基础上，再对周围四个节点进行判断 vis[x][y] = true; fx = x + dx[i]; fy = y + dy[i]; DFS(fx,fy);//此处使用递归求解 &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n)!=EOF&amp;&amp;(n||m))&#123; clr(mapp);clr(vis); sum = 0; for(int i=0;i&lt;n;i++)&#123; scanf("%s",mapp[i]); &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(mapp[i][j] == '@')&#123; DFS(i,j); break; &#125; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125; 从代码中我们可以看出，DFS的使用方法为： 1.找出起点 2.对起点四个方向的状态进行判断，如果是空地，就进行递归，继续对这四个方向的位置的四周进行判断，如果不是空地，就结束递归 3.输出结果 DFS与BFS有很多相似的地方，不过BFS求的是最短路，DFS求的是方案数，我们可以根据题目要求选择这两种方法。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[现在已经是2019年。我加入HPU-ACM（现为算法协会）是在18年3月份左右，虽然时间不长，但是已经成为这个大家庭的一份子了。 经过了近一年的学习与比赛，我觉得收获了很多。但是回头一想，却又想不起来学过的知识到底有什么，学的扎实不扎实，是否能清晰地描述自己学过的知识。 看着协会里的成员一个个的在努力，在进步，我也希望能够继续深入学习，在ACM的路上走的更远。 同时，我也希望我的学弟学妹们能够比我们走得更远。HPU在这方面很弱，非常弱。因此我们更需要一种行之有效的方法去帮助学弟学妹们入门算法，学习算法。 我在这里写下了我所学过得部分算法和知识，可能并不是十分完善，毕竟我也只是个ACM的小学生。但正因为是这样，我在这些算法里面遇到过的坑还没有忘记，所以在写这些文章时，我会注意那些容易出错的地方，进行提醒，不希望我的学弟学妹们或者其他算法的初学者走弯路。 希望我的这些文章对学习算法能有所启发。 文章持续补充中……]]></content>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2019%2F01%2F07%2FFirst%20blog%2F</url>
    <content type="text"><![CDATA[纪念我的第一篇博客 ^_^]]></content>
  </entry>
</search>

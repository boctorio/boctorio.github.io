<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[素数筛选法]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95%2F</url>
    <content type="text"><![CDATA[素数，是指因子只包含1和其本身的数，那么，我们怎么判断素数呢？ （以下代码均基于打表（1~1e6）的基础上完成） 1.按照定义计算素数的定义就是一个数的因子只包含1和其本身，那么我们直接就按照定义写： 12345678910111213141516171819202122# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int pri[maxn];int isprime(int n)&#123; for(int i=2;i&lt;n;i++) if(n%i==0) return 0; return 1;&#125;int main()&#123; pri[1]=0; for(int i=2;i&lt;=maxn;i++)&#123; pri[i]=isprime(i); &#125; return 0;&#125; 这是最基础的写法，也是最小白的写法。毕竟，当时我刚高一加入大学的某个协会时，考的就有判断素数… 这种算法的复杂度为O(n^2),复杂度非常的大，对于1e6的数据范围来说肯定要超时，那么还有没有更优化的算法？答案是肯定的 2.基于定义计算的优化算法我们对一个合数进行考虑，例如12： 它的因子有1 2 3 4 6 12 ，而且112=12 ， 26=12 ， 3*4=12 可见，每一个因子都会有另一个对应的因子，观察可得，它们的分布是平均的，左边的一半对应右边的一半，那么最中间的分界线应该是什么？ √n 。 因此，我们只需要对√n 前面的数字进行判断即可。 12345678910111213141516171819202122# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int pri[maxn];int isprime(int n)&#123; for(int i=2;i*i&lt;=n;i++)//只需要将i变成i*i即可 if(n%i==0) return 0; return 1;&#125;int main()&#123; pri[1]=0; for(int i=2;i&lt;maxn;i++)&#123; pri[i]=isprime(i); &#125; return 0;&#125; 这种算法的复杂度要比上一种好的多，复杂度为O(n√n),但是对于1e6的数据范围来说还是太大了。有没有再快一点的算法？ 3.素数筛选法素数筛选法的思想为： 从2开始，因为2的倍数一定不是素数，所以先把2的倍数全部删去； 接着找下一个素数3，把3的倍数全部删去； 因为4是2的倍数，已经被删去，所以直接找下一个素数5，把5的倍数全部删去； 接着7的倍数，11的倍数，……直到把1e6范围内的合数全部筛选出去，剩下的即为素数： //以下优化均基于打表的基础上 1234567891011121314151617181920212223242526# include&lt;stdio.h&gt;# include&lt;string.h&gt;# define maxn 1000000+10int vis[maxn];void isprime()&#123; memset(vis,0,sizeof(vis));//此处vis[i]=1表示不是素数，vis[i]=0表示是素数 vis[1]=1; //由于i*i的数据范围可能会超过int，所以需要用long long表示 for(long long i=2;i*i&lt;=maxn;i++)&#123;//此处有优化，因为如果一个合数&gt;sqrt(maxn),那么他必定在前面已经被标记过。 if(!vis[i])&#123; for(long long j=i*i;j&lt;=maxn;j+=i)&#123;//此处也有优化，我们只需要判断从i*i开始判断即可。 vis[j]=1; &#125; &#125; &#125;&#125;int main()&#123; int n; isprime(); return 0;&#125; 这种算法的复杂度应该为O(n);，是一种非常快速的判断素数的算法。 上述代码有两处优化，第一处优化的证明如下： 假设 maxn &gt; i &gt; sqrt(maxn)并且为合数，那么，他肯定会有一个因子小于等于sqrt(maxn)，因此，i一定在之前已经被标记过了。 第二处优化证明为： 假设i&gt;2，那么对于 i * ( i - 1 )： 如果 i - 1是素数，那么 i * ( i - 1 ) 一定在之前已经被标记过； 否则，如果 i - 1 是合数，那么 i - 1能被分成更小的素数。设其中一个为a，那么 i ( i - 1 )= i ( i - 1 ) / a * a 也一定被标记过。 优化后的算法时间会节省非常多，在平常的算法竞赛中，用上述代码就已经可以解决大部分的涉及素数打表的问题。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马小定理--轻松判断大质数]]></title>
    <url>%2F2019%2F01%2F09%2F%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86-%E8%BD%BB%E6%9D%BE%E5%88%A4%E6%96%AD%E5%A4%A7%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述在算法竞赛中你会遇到各种各样的有关素数的问题，今天你来解决一个最基础的问题：如何判定一个素数。对于给定的正整数p，若p非素数，输出-1若p是素数 输出 ：{sigma(a^(p-1) % p) ，其中a的下界为1，上界为p-1} 即： 输入 多实例测试，每组数据包含一个正整数p（p &lt; 10^16）。 输出 根据情况输出一个正整数，保证答案在int64之内，输出占一行。 样例输入 2 样例输出 1 这个题一般方法是就是暴力求解了，首先判断是不是素数，如果不是素数，那么输出-1，如果是素数，那么就实处上面那个式子的值。 但是题目要求的数据范围为1e16，如果我们用一般判断素数的方法（sqrt(n)）去求解的话，必定会超时，那么我们如何解决这个问题呢，费马小定理出现了。 费马小定理 假如p是质数，且gcd(a,p)=1，那么 a(p-1)≡1（mod p），例如：假如a是整数，p是质数，则a,p显然互质(即两者只有一个公约数1)，那么我们可以得到费马小定理的一个特例，即当p为质数时候， a^(p-1)≡1(mod p)。 从费马小定理的定义我们可以知道，一般情况下，只要一个数字a，gcd(a,p)=1，那么p就是一个质数。 因此，我们可以随机几个数字（与p互质），如果a(p-1)≡1（mod p）对这些数字恒成立，那么p就是一个指数。 一般情况下，我们只需要列举十个左右的数字即可确定一个数字是否为质数。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849include&lt;stdio.h&gt;long long n,res,x;long long gcd(long long a,long long b)&#123;​ return b?gcd(b,a%b):a;&#125;long long feima(long long a)&#123;​ long long sum;​ if(x&lt;=1)&#123;​ return (a*res)%n;​ &#125;​ if(x%2==0)&#123;​ a=(a*a)%n;​ x/=2;​ return feima(a);​ &#125;​ else&#123;​ res=(res*a)%n;​ a=(a*a)%n;​ x/=2;​ return feima(a);​ &#125;&#125;int main()&#123;​ long long t,i;​ //以下是我自己列举的一些随机数，我们也可以用一些随机数函数来找一些随机数 ​ long long a[20]=&#123;7,43,64,69,87,31,45,72,81,79,47,33,43,97,121,199,173,153,157,53&#125;; ​ while(~scanf("%lld",&amp;n))&#123;​ if(n==2)&#123;​ printf("1\n");​ continue;​ &#125;​ for(i=0;i&lt;20;i++)&#123;​ res=1;​ x=n-1;​ if(gcd(a[i],n)!=1 || feima(a[i])!=1)&#123;//两个判断条件，两个数字互质且符合费马小定理 ​ break;​ &#125;​ &#125;​ if(i==20)&#123;​ printf("%lld\n",n-1);​ &#125;​ else​ printf("-1\n");​ &#125;​ return 0;&#125; 用以上方法即可迅速判断一个数是否是质数，对特别大的数字尤其适用。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>费马小定理</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算数基本定理 + 容斥定理]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%AE%97%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86-%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[算数基本定理定义：任何一个大于1的自然数，如果N不为质数，那么N可以分解成有限个质数的乘积，并且在不计次序的情况下，这种分解方式是唯一的。 例如：60可以分解为 2^2 * 3 * 5 数学公式描述 N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn （P1&lt;P2&lt;P3&lt;…=0） 质因子分解计算方法 算法复杂度 ( O(√n) )123456789101112map&lt;int,int&gt; prime_factor(int n)&#123; map&lt;int,int&gt;ans; for(int i=2;i*i&lt;n;i++)&#123; while(n%i==0)&#123; ++ans[i]; n/=i; &#125; &#125; if(n!=1) ans[n]=1; return ans;&#125; 算数基本定理的应用如何求N有几个因子？ 根据算数基本定理：N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn 根据排列组合得到结果： ans=(1+r1) * (1+r2) * (1+r3) * … * (1+rn) 如何求N的所有因子之和？ 根据算数基本定理：N=P1^r1 * P2^r2 * P3^r3 * … * Pn^rn 求GCD(X,Y)和LCM(X,Y) 根据算数基本定理： X=P1^x1 * P2^x2 * P3^x3 * … * Pn^xn Y=P1^y1 * P2^y2 * P3^y3 *… * Pn^yn 根据GCD和LCM的定义 容斥定理要计算几个集合并集的大小，我们要先将所有单个集合的大 小计算出来，然后减去所有两个集合相交的部分，再加回所 有三个集合相交的部分，再减去所有四个集合相交的部分， 依此类推，一直计算到所有集合相交的部分。 用Venn图来表示 数学公式描述 如果要对n个物体进行选择，那么有多少种情况？ 代码 复杂度为O(2^n) 123456for(int i=0;i&lt;(1 &lt;&lt; m);i++)&#123; for(int j=0;j&lt;n;j++)&#123; printf("%d",i&gt;&gt;j &amp; 1); &#125; puts("");&#125; 容斥定理的应用问题：魔镜给小明m个数字（a1、a2 …… am）和一个整数n，魔镜定义：如果有一个数，是这m个数字里面任意一 个数的倍数，那么这个数称为LuckyNumber。而小明会的题 数为[1,n]闭区间内LuckyNumber的数量。 (0 &lt; m &lt; 15) 那么请你帮小明计算一下他会的题目数。 代码 复杂度为O(2^n) 123456789101112131415LL ans=0;for(int i=1; i&lt;(i&lt;&lt;m);i++)&#123; int cnt=0; LL LCM=1; for(int j=0;j&lt;m;j++)&#123; if(1&amp;(i&gt;&gt;j))&#123;//按位运算判断第m个数是否使用 cnt++; LCM=lcm(LCM,a[j]); &#125; &#125; if(cnt&amp;1) ans+=n/LCM;//判断n中元素使用的个数，奇加偶减 else ans-=n/LCM;&#125;printf("%lld\n",ans);]]></content>
      <tags>
        <tag>算数基本定理</tag>
        <tag>容斥定理</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS与DFS]]></title>
    <url>%2F2019%2F01%2F08%2FBFS%E4%B8%8EDFS%2F</url>
    <content type="text"><![CDATA[BFS(宽度优先搜索)宽度优先搜索算法（又称广度优先搜索算法）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。 他并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。 举例： 由橙色位置出发，进行BFS： ​ 灰色位置表示已经走过，橙色标示当前位置 首先进行第一步： ​ 已经走过的位置，不需要再走了 进行第二步： ​ 同上，状态继承，进行第三步： ​ 进行第四步，到达终点，当前步数表示最小步数： ​ 对于一个迷宫而言，我们要进行的步骤是一样的。 ​ 蓝色是起点，红色是终点，黑色为障碍物。 第一步，我们可以走以下几步： ​ 接下来依次为： 当我们走到第十步时，走到了终点，因此，从起点到终点最少的步数即为10步。 接下来看一道基础的例题（HDU1242）Rescue： Problem Description Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison. Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards. You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.) Input First line contains two integers stand for N and M. Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend. Process to the end of the file. Output For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.” Sample Input 123456787 8#.#####.#.a#..r.#..#x.....#..#.##...##...#.............. Sample Output 113 这个题大概的意思就是求从字符a出发，到达字符r的最少时间，其中 . 代表空地，#代表墙，x代表守卫，每杀死一个守卫我们就需要消耗一秒的时间。 这个题可以用BFS直接求解，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;# include&lt;string.h&gt;# include&lt;algorithm&gt;# include&lt;queue&gt;using namespace std;# define MAXN 510char str[MAXN][MAXN];//用来储存地图 int vis[MAXN][MAXN];//用来标记已经走过的地点 int n,m;struct name&#123; int x; int y; int step;&#125;;bool operator &lt;(name i,name j)&#123;//对走过的地点顺序进行排序 return i.step&gt;j.step;&#125;int d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;//表示行走的四个方向，顺序为右，左，上，下 int BFS(int sx,int sy,int ex,int ey)&#123; memset(vis,0,sizeof(vis)); priority_queue&lt;name&gt;que;//使用队列用来储存上一步走过的地点 name e1,e2; e1.x=sx,e1.y=sy,e1.step=0; que.push(e1);//输入起点 vis[sx][sy]=1; int ans=-1; int i; while(!que.empty())&#123;//当队列为空时，即表示我们已经把所有的能走的地点都走了一遍 e1=que.top();//将队列第一个地点的信息赋给e1； 此时e1即表示上一步走过的地点的信息 que.pop(); if(e1.x==ex &amp;&amp; e1.y==ey)&#123;//对这个地点进行判断，看是否是是终点 ans=e1.step; break; &#125; for(i=0;i&lt;4;i++)&#123;//如果e1不是终点，那么对e1的上下左右进行判断，如果可以走，那么就将信息储存在队列中 e2.x=e1.x+d[i][0]; e2.y=e1.y+d[i][1]; if(e2.x&lt;0 || e2.x&gt;=n || e2.y&lt;0 || e2.y&gt;=m) continue;//对边界进行判断，如果超出边界，则不进行保存 if(vis[e2.x][e2.y]==1) continue;//如果当前位置已经走过，那么就不进行保存 if(str[e2.x][e2.y]=='#') continue;//如果是墙壁,不进行保存 if(str[e2.x][e2.y]=='x') e2.step=e1.step+2;//如果是守卫的话，需要消耗两个单位时间 else e2.step=e1.step+1;//如果是空地,一个单位时间 que.push(e2);//将地点存入队列 vis[e2.x][e2.y]=1;//降低点进行标记 &#125; &#125; if(ans==-1)&#123; printf("Poor ANGEL has to stay in the prison all his life.\n"); &#125; else&#123; printf("%d\n",ans); &#125; &#125;int main()&#123; int i,j; while(~scanf("%d %d",&amp;n,&amp;m))&#123; for(i=0;i&lt;n;i++)&#123; scanf("%s",str[i]); &#125; int sx,sy,ex,ey; for(i=0;i&lt;n;i++)&#123;//找寻起点和终点 for(j=0;j&lt;m;j++)&#123; if(str[i][j]=='a') sx=i,sy=j; if(str[i][j]=='r') ex=i,ey=j; &#125; &#125; BFS(sx,sy,ex,ey);//开始BFS &#125; return 0;&#125; 从代码中可以看出，我们使用BFS的步骤为： 1.对地图信息进行保存 2.找到起点和终点信息 3.从起点开始，对所走过的每一步进行判断 4.如果走的这一步可行，那么储存这一步的信息，并标记这个位置，表示不会再走到这个位置 5.如果不可行，那么就不进行操作 6.找到终点 以上，即为BFS的功能。 DFS(深度优先搜索)DFS的目的是要达到被搜索结构的叶结点。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。 DFS的使用基础为递归，当我们顺着一个节点向下走时，如果走不下去了，就回溯，如果上一个节点还有其他的节点，那么我们就会对这个节点再进行搜索。 对于下面这个图 首先我们将从第一个节点开始出发，然后搜索第二个节点， 因为第二个节点下面还有第四个节点，因此我们继续向下搜索， 第四个节点下面已经没有其他节点，因此我们回溯到第二个节点 第二个节点下面还有第五个节点，因此我们搜索第五个节点 然后继续回溯，到第一个节点， 接下来就搜索第三个节点，第五个节点 当再次回溯到第一个节点时，已经没有其他的节点可进行搜索，因此搜索的过程到此结束，DFS也到此结束。 上面就是DFS的功能，DFS是对所有可能的结果进行一次彻底的搜索，这样会保证不会有任何情况会被遗漏。 接下来看一道例题（HDU1312）Red and Black： There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. Write a program to count the number of black tiles which he can reach by repeating the moves described above. Input The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. ‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set) Output For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input 1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output 12344559613 这个题的大概意思就是给你一个起点，你能够走到多少个地点。 其中 ‘ . ‘是空地，#是墙壁，@是起点。 接下来看一下代码，思想和BFS类似： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define clr(a) memset(a,0,sizeof(a))const int MAXN = 1e5+10;const int INF = 0x3f3f3f3f;const int N = 30;int n,m,sum;char mapp[N][N];//储存地图 int vis[N][N];//标记位置 int dx[4] = &#123;1,-1,0,0&#125;;//四个行走方向 int dy[4] = &#123;0,0,1,-1&#125;;bool check(int x,int y)&#123;//检测不能走通的条件 if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||mapp[x][y]=='#')&#123; return false; &#125; else return true;&#125;void DFS(int x,int y)&#123; if(!check(x,y)||vis[x][y])&#123;//如果不能走通，那么直接返回 return ; &#125; else&#123; sum++; int fx,fy; for(int i=0;i&lt;4;i++)&#123;//在此节点的基础上，再对周围四个节点进行判断 vis[x][y] = true; fx = x + dx[i]; fy = y + dy[i]; DFS(fx,fy);//此处使用递归求解 &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n)!=EOF&amp;&amp;(n||m))&#123; clr(mapp);clr(vis); sum = 0; for(int i=0;i&lt;n;i++)&#123; scanf("%s",mapp[i]); &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(mapp[i][j] == '@')&#123; DFS(i,j); break; &#125; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125; 从代码中我们可以看出，DFS的使用方法为： 1.找出起点 2.对起点四个方向的状态进行判断，如果是空地，就进行递归，继续对这四个方向的位置的四周进行判断，如果不是空地，就结束递归 3.输出结果 DFS与BFS有很多相似的地方，不过BFS求的是最短路，DFS求的是方案数，我们可以根据题目要求选择这两种方法。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[现在已经是2019年。我加入HPU-ACM（现为算法协会）是在18年3月份左右，虽然时间不长，但是已经成为这个大家庭的一份子了。经过了近一年的学习与比赛，我觉得收获了很多，但是回头一想，却又想不起来我到底学过了多少的东西。看着协会里的成员一个个的在努力，在进步，我也希望能够继续深入学习，在ACM的路上走的更远。]]></content>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2019%2F01%2F07%2FFirst%20blog%2F</url>
    <content type="text"><![CDATA[纪念我的第一篇博客 ^_^]]></content>
  </entry>
</search>

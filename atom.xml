<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Boctorio&#39;s Blog</title>
  
  <subtitle>欢迎访问我校OJ   https://hpuoj.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://boctorio.github.io/"/>
  <updated>2019-08-01T13:50:01.866Z</updated>
  <id>https://boctorio.github.io/</id>
  
  <author>
    <name>Boctorio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十进制下的矩阵快速幂优化</title>
    <link href="https://boctorio.github.io/2019/08/01/%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%8B%E7%9A%84%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%BC%98%E5%8C%96/"/>
    <id>https://boctorio.github.io/2019/08/01/十进制下的矩阵快速幂优化/</id>
    <published>2019-08-01T13:12:22.000Z</published>
    <updated>2019-08-01T13:50:01.866Z</updated>
    
    <content type="html"><![CDATA[<p>矩阵快速幂是一种用来求解递推式问题的高效算法，能在 $log$ 的时间内求解递推式的某一项。但是当 $n$ 变得非常大时（远远超过了 $long long$ 的表示范围，比如$10^{10^{5}}$），单纯的矩阵快速幂就会浪费大量的时间在处理字符串上，这是就需要使用十进制的优化了。</p><a id="more"></a><p><a href="https://ac.nowcoder.com/acm/contest/885/B" target="_blank" rel="noopener">2019牛客多校第五场B题（暂未开放）</a></p><p>题目大意为：</p><blockquote><p>给你一个递推式的第零项 $x_0$ 和第一项 $x_1$ 以及通项公式 $x_i=a*x_{i-1}+b*x_{i-2}(i&gt;1)$ , 求该数列第 $n(1\leq n \leq 10^{10^6})$ 项模 $mod$ 的值。</p></blockquote><p>假如使用二进制模拟，那么时间复杂度为 $log(n)*len(n)$ ，$len$ 为 $n$ 的长度，那么超时是在所难免的，此时就需要用一下(奇)技(淫)巧了。</p><p>十进制的表示下，1234可以分解成$1*1000+2*100+3*10+4$ ，矩阵快速幂的优化也基于此，我们计算出系数矩阵的第 $10^x$ 次方项，然后计算出当前十进制下从低到高第 $x$ 位所对应的值，就可以计算出当前为所对应的系数矩阵的值，然后再用二进制下求解矩阵快速幂的方法求出系数矩阵第 $10^{x+1}$ 项的值，就可以继续依次求解了。</p><p>题目代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll x0,x1,a,b,mod;</span><br><span class="line"><span class="keyword">char</span> n[<span class="number">1000000</span>+<span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ll a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line">node <span class="keyword">operator</span> *(node x,node y)&#123;</span><br><span class="line">    node res;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">            res.a[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">                res.a[i][j]=(res.a[i][j]+x.a[i][k]*y.a[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">qp</span><span class="params">(node a,ll b)</span></span>&#123;</span><br><span class="line">    node res;</span><br><span class="line">    res.a[<span class="number">0</span>][<span class="number">0</span>]=res.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    res.a[<span class="number">0</span>][<span class="number">1</span>]=res.a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld %lld %s %lld"</span>,&amp;x0,&amp;x1,&amp;a,&amp;b,&amp;n,&amp;mod);</span><br><span class="line">    node x;</span><br><span class="line">    x.a[<span class="number">0</span>][<span class="number">0</span>]=a;x.a[<span class="number">0</span>][<span class="number">1</span>]=b;</span><br><span class="line">    x.a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;x.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    node ans;</span><br><span class="line">    ans.a[<span class="number">0</span>][<span class="number">0</span>]=ans.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    ans.a[<span class="number">1</span>][<span class="number">0</span>]=ans.a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    ll len=<span class="built_in">strlen</span>(n);</span><br><span class="line">    <span class="comment">//由于是n-1次方，所以需要减1</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n[i]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">            n[i]--;</span><br><span class="line">            <span class="keyword">for</span>(ll j=i+<span class="number">1</span>;j&lt;len;j++) n[j]=<span class="string">'9'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        ans=ans*qp(x,n[i]-<span class="string">'0'</span>);</span><br><span class="line">        x=qp(x,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans.a[<span class="number">0</span>][<span class="number">0</span>]*x1+ans.a[<span class="number">0</span>][<span class="number">1</span>]*x0)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;矩阵快速幂是一种用来求解递推式问题的高效算法，能在 $log$ 的时间内求解递推式的某一项。但是当 $n$ 变得非常大时（远远超过了 $long long$ 的表示范围，比如$10^{10^{5}}$），单纯的矩阵快速幂就会浪费大量的时间在处理字符串上，这是就需要使用十进制的优化了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线性基</title>
    <link href="https://boctorio.github.io/2019/07/23/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    <id>https://boctorio.github.io/2019/07/23/线性基/</id>
    <published>2019-07-23T00:42:22.000Z</published>
    <updated>2019-07-23T03:07:26.022Z</updated>
    
    <content type="html"><![CDATA[<p>线性基是用来求解数组子集最大异或和的一种方法。其思想与线性代数中的最大线性无关组相似。</p><a id="more"></a><h4 id="线性基的性质"><a href="#线性基的性质" class="headerlink" title="线性基的性质"></a>线性基的性质</h4><p>线性基有以下几种性质：</p><blockquote><ol><li>数组中的所有元素都能够用线性基中的元素相互异或计算出来</li><li>线性基中不存在异或值为0的子集</li><li>满足性质1的前提下，线性基中的元素个数是最少的。</li><li>线性基中每个元素二进制位数均不相同</li></ol></blockquote><h4 id="线性基的计算"><a href="#线性基的计算" class="headerlink" title="线性基的计算"></a>线性基的计算</h4><p>对于当前所求出来的线性基，我们在插入一个新的元素时（即使得其表示范围多一个数 $x$），要保证插入的元素与其他元素异或不为零。</p><p>根据性质4，我们能够通过位运算对插入的元素进行异或计算：<br>$$<br>x = p_1  \bigoplus  p_2 \bigoplus … \bigoplus p_i \bigoplus p_x<br>$$<br>$p_i$ 为线性基中的某个基，则：<br>$$<br>p_x = p_1  \bigoplus  p_2 \bigoplus … \bigoplus p_i \bigoplus x<br>$$<br>根据性质4，我们求解的线性基中不能包含二进制位数相同的数，因此我们把x按照最高位向最低位异或的方式进行计算，假如当前x的二进制最高位所对应的基存在，则x异或这个基（此时x的值会改变），这样能够保证x的二进制位数至少能够减少1位，然后继续进行计算，计算终点有两种结果：</p><blockquote><ol><li>x二进制最高位对应的基不存在，则把x插入线性基，运算结束</li><li>x值变为0，说明当前线性基能够表示最开始的x，则直接结束。</li></ol></blockquote><p>这样就能够求出来 $p_x$ 的值，即线性基需要插入的元素。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;&gt;i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">f[i]=x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">x^=f[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性基是用来求解数组子集最大异或和的一种方法。其思想与线性代数中的最大线性无关组相似。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Operation--2019杭电多校训练第一场-B题</title>
    <link href="https://boctorio.github.io/2019/07/23/Operation-2019%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%B8%80%E5%9C%BA-B%E9%A2%98/"/>
    <id>https://boctorio.github.io/2019/07/23/Operation-2019杭电多校训练第一场-B题/</id>
    <published>2019-07-23T00:41:46.000Z</published>
    <updated>2019-07-23T01:29:56.444Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6579" target="_blank" rel="noopener">题目传送门</a></p><p>题目大意为：</p><blockquote><p>给你一个1~n的数组,然后有m个操作，0操作为在数组最后添加一个新元素，1操作为查询区间 $[l,r]$ 子集异或最大值。</p><p>其中输入经过加密操作，需要经过解密才能获取正确数据（强制在线）</p></blockquote><a id="more"></a><p>看到了子集异或值就应该知道是使用<a href="http://localhost:4000/2019/07/23/%E7%BA%BF%E6%80%A7%E5%9F%BA/" target="_blank" rel="noopener">线性基</a>的知识。</p><p>如果按照暴力的解法一定会超时，但是我们可以通过一定贪心策略找到当前的最优解。</p><p>（下面就需要对线性基有清晰的认识了）</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>对于区间$[1,x]$$(1 \leq x \leq n)$，我们可以通过继承的方式找到每个区间的线性基：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">30</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">f[i][j]=f[i<span class="number">-1</span>][j];<span class="comment">//将上一个区间[1,i-1]的线性基继承到[1,i]</span></span><br><span class="line">pos[i][j]=pos[i<span class="number">-1</span>][j];<span class="comment">//pos数组用来保存 计算出线性基第j个基的元素的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承之后我们就可以求解当前区间的线性基了。</p><p>在求解时，我们需要用贪心的策略对线性基进行更新：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">k=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">30</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;&gt;j)&#123;</span><br><span class="line"><span class="keyword">if</span>(!f[i][j])&#123;</span><br><span class="line">f[i][j]=x;</span><br><span class="line">pos[i][j]=k;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//这一步是贪心策略，将计算出基的元素尽量的靠右</span></span><br><span class="line"><span class="comment">//由线性基的性质可知，在替换掉当前元素后，线性基的性质和表示范围不会发生改变。</span></span><br><span class="line"><span class="keyword">if</span>(k&gt;pos[i][j])&#123;</span><br><span class="line">swap(k,pos);</span><br><span class="line">swap(x,f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">x^=f[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询区间最大值"><a href="#查询区间最大值" class="headerlink" title="查询区间最大值"></a>查询区间最大值</h4><p>假设需要计算的区间为 $[l,r]$ （已经过转换），那么我们接下来就要根据<strong>利用线性基求子集最大值</strong>的方法来进行求解了。</p><p>对于 $f[i][j]$ ,我们可以知道这个基的有效范围为 $[1,pos[i][j]]$ ,当 $l&gt;pos[i][j]时$ 这个基就已经没有了计算的意义。</p><p>所以使用 $S=\lbrace f[r][j]~| l \leq pos[r][j] \rbrace$ 就能够用来表示区间 $[l,r]$ 的所有子集异或和：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">30</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>((ans^f[r][j])&gt;ans &amp;&amp; pos[r][j]&gt;=l)</span><br><span class="line">ans^=f[r][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能够简便的计算出区间 $[l,r]$ 子集的异或和最大值。</p><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,l,r,op,res;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">32</span>],pos[maxn][<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">30</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">pos[i][j]=pos[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">30</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;&gt;j)&#123;</span><br><span class="line"><span class="keyword">if</span>(!f[i][j])&#123;</span><br><span class="line">f[i][j]=x;</span><br><span class="line">pos[i][j]=k;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&gt;pos[i][j])&#123;</span><br><span class="line">swap(k,pos[i][j]);</span><br><span class="line">swap(x,f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">x^=f[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">add(i,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[++n]);</span><br><span class="line">a[n]=a[n]^res;</span><br><span class="line">add(n,a[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;l,&amp;r);</span><br><span class="line">l=(l^res)%n+<span class="number">1</span>;r=(r^res)%n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line">res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">30</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>((res^f[r][j])&gt;res &amp;&amp; pos[r][j]&gt;=l)</span><br><span class="line">res^=f[r][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">30</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">f[i][j]=pos[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6579&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个1~n的数组,然后有m个操作，0操作为在数组最后添加一个新元素，1操作为查询区间 $[l,r]$ 子集异或最大值。&lt;/p&gt;
&lt;p&gt;其中输入经过加密操作，需要经过解密才能获取正确数据（强制在线）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>换根dp</title>
    <link href="https://boctorio.github.io/2019/07/22/%E6%8D%A2%E6%A0%B9dp/"/>
    <id>https://boctorio.github.io/2019/07/22/换根dp/</id>
    <published>2019-07-22T00:53:45.000Z</published>
    <updated>2019-07-22T01:39:00.381Z</updated>
    
    <content type="html"><![CDATA[<p>换根dp是用来求解树上各点到其他点的距离之和的问题。</p><a id="more"></a><p>在进行换根dp时，需要先利用 $dfs$ 计算出根节点到其他节点的距离之和，以及以每个节点为根节点的子树的节点数量。然后再对其进行换根dp。</p><h4 id="Part1-计算根节点到其他节点距离之和"><a href="#Part1-计算根节点到其他节点距离之和" class="headerlink" title="Part1:计算根节点到其他节点距离之和"></a>Part1:计算根节点到其他节点距离之和</h4><p>我们在求解时利用递归的思想进行求解：</p><blockquote><p>假设 $a$ 为根节点，$b$ 为直系子节点，那么对于 $b$ 所在子树对 $a$ 的贡献为 $dis[b]+point[b]$  ,其中 $dis[b]$为 $b$到以b为根节点的子树中所有点的距离之和。$point[b]$为以 $b$ 为根节点的子树中的点的个数，其实很好理解，就相当于以 $b$ 为根节点中的所有路径长度全部 $+1$，然后就到达了 $a$ 节点。</p></blockquote><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[maxn];<span class="comment">//第一次dfs每个节点到其子节点距离之和 </span></span><br><span class="line"><span class="keyword">int</span> point[maxn];<span class="comment">//每个节点下子节点个数（包括这个节点本身） </span></span><br><span class="line"><span class="keyword">int</span> dp[maxn];<span class="comment">//最终结果  </span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec[x].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> y=vec[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">dfs(y);</span><br><span class="line">sum+=point[y];</span><br><span class="line">dis[x]+=dis[y]+point[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">point[x]=sum+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part2-进行换根dp"><a href="#Part2-进行换根dp" class="headerlink" title="Part2:进行换根dp"></a>Part2:进行换根dp</h4><p>准备工作做完之后，我们就可以开始换根dp，换根dp的思想就是<strong>把与根相连的节点通过一定的操作将其变为根</strong>。</p><p>依然利用上述节点 $a,b$ ,将根节点从 $a$ 移动到 $b$ ，$dp[b]$ 的值为：$dp[a]+-point[b]+(n-point[b])$，其中：</p><blockquote><p>$-point[b]$ 表示从 $b$ 引申出来的 $point[b]$ 条路径长度全部 $- 1$.</p><p>$n-point[b]$ 表示从 $a$ 引申出来的不包含 $b$ 的其他路径长度全部 $+1$</p></blockquote><p>状态转移方程计算出来之后就可以利用 $dfs$ 进行换根dp了。</p><p>代码如下（初始状态下$dp[a]=dis[a]$）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec[x].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> y=vec[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">dp[y]=dp[x]-point[y]+n-point[y];</span><br><span class="line">Dp(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能计算出所有的点到其他节点的距离之和了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;换根dp是用来求解树上各点到其他点的距离之和的问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cotree--2019CCPC-江西省赛-A题</title>
    <link href="https://boctorio.github.io/2019/07/22/Cotree-2019CCPC-%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9B-A%E9%A2%98/"/>
    <id>https://boctorio.github.io/2019/07/22/Cotree-2019CCPC-江西省赛-A题/</id>
    <published>2019-07-21T23:56:44.000Z</published>
    <updated>2019-07-22T03:57:59.863Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6567" target="_blank" rel="noopener">题目链接（杭电重现赛）</a></p><p>题目大意：</p><blockquote><p>给你两棵树，在这两棵树上分别找一个点，将其连接，使得$\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}dis(i,j)$ 最小，其中$dis(i,j)$表示从节点 $i$ 到节点 $j$ 的边数。</p></blockquote><a id="more"></a><h4 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h4><p>首先我们需要判断<strong>我们找的这两个点应该是哪个点</strong>，对于两棵树，他们的 $dis$ 和是固定的,因此我们需要讨论将两个点连接起来所增加的花费。</p><blockquote><p>假设需要连接的两棵树$A,B$,两棵树上进行连接的点为 $u,v$ ，</p><p>点 $u,v$ 到其所在子树其他点的距离之和为$Dis_u,Dis_v$ ，$A,B$ 上点的个数为 $P_A,P_B$,</p></blockquote><p>那么将其连接后增加的 $dis$ 值为：<br>$$<br>Dis_u*P_B+Dis_v*P_A+P_A*P_B<br>$$<br>很容易理解：</p><blockquote><p>对于树 $A$ 上的任意一个点 $w$ ，我们需要将其和 $B$ 上的所有点进行一次连接，等同于需要将$dis(w,u)$ 重复计算 $P_B$ 次，其他点同理，因此 $A$ 树上增加的 $dis$ 值为 $Dis_u*P_B$ ，B树同理。</p><p>而对于刚建立的通道 $dis(u,v)=1$  被使用了 $P_A*P_B$ 因此总的增加量即为上式。</p></blockquote><p>$P_A,P_B$为定值，所以我们只需要最小化 $Dis_u,Dis_v$ 即可。</p><h4 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h4><p>现在的问题已经简化成了如何求一棵树上的 $Dis$ 的最小值。</p><p>首先我们需要一遍dfs将树的根节点的 $Dis$ 值找出来，找出来之后，我们就使用<a href="https://boctorio.com/2019/07/22/%E6%8D%A2%E6%A0%B9dp/" target="_blank" rel="noopener">换根dp</a>计算出树上所有节点的$Dis$值。</p><p>然后找出 $Dis$ 最小的点，进行连接，再次进行上述操作即可。</p><p>最后将所有节点的 $Dis$ 全部求和，由于这个值是求的双向的，因此需要除以2。</p><p>代码如下（代码有些冗长）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt;vec[maxn];</span><br><span class="line">ll n;</span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll num[maxn];</span><br><span class="line">ll vis[maxn];</span><br><span class="line">ll vis2[maxn];</span><br><span class="line">ll value[maxn];</span><br><span class="line">ll flag,point;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//清空数组 </span></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(vis2,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis2));</span><br><span class="line"><span class="built_in">memset</span>(value,<span class="number">0</span>,<span class="keyword">sizeof</span>(value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll x)</span></span>&#123;<span class="comment">//dfs找所有的值，num表示以这个点为根节点下面有几个点（包括这个点，dp用），value是这个点到所有子树的距离之和</span></span><br><span class="line">vis[x]=flag;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;vec[x].size();i++)&#123;</span><br><span class="line">ll y=vec[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line"><span class="keyword">int</span> q=dfs(y);</span><br><span class="line">sum+=q;</span><br><span class="line">value[x]+=value[y]+q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num[x]=sum+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> sum+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dp</span><span class="params">(ll x)</span></span>&#123;<span class="comment">//dp数组表示当前这个点到其他点的距离之和 </span></span><br><span class="line">vis2[x]=flag;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;vec[x].size();i++)&#123;</span><br><span class="line">ll y=vec[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis2[y])&#123;</span><br><span class="line">dp[y]=dp[x]-num[y]+point-num[y];<span class="comment">//换根dp方程 </span></span><br><span class="line">Dp(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vec[i].clear();</span><br><span class="line">init();</span><br><span class="line">ll u,v;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;u,&amp;v);</span><br><span class="line">vec[u].push_back(v);</span><br><span class="line">vec[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用flag的值对第一颗子树和第二棵子树进行区分，下同</span></span><br><span class="line">flag=<span class="number">1</span>; dfs(<span class="number">1</span>); dp[<span class="number">1</span>]=value[<span class="number">1</span>]; flag++;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">dfs(i);</span><br><span class="line">dp[i]=value[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//point是当前两个子树之一的点的个数</span></span><br><span class="line">point=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line"><span class="keyword">if</span>(vis[i]==<span class="number">1</span>) </span><br><span class="line">point++;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">Dp(<span class="number">1</span>); </span><br><span class="line">flag++;</span><br><span class="line">point=n-point;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(!vis2[i])&#123;</span><br><span class="line">Dp(i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到两个树上到其他点距离最小的点 </span></span><br><span class="line">ll v1=INF,v2=INF,p1,p2;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis2[i]==<span class="number">1</span> &amp;&amp; dp[i]&lt;=v1)&#123;</span><br><span class="line">p1=i;</span><br><span class="line">v1=dp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis2[i]==<span class="number">2</span> &amp;&amp; dp[i]&lt;=v2)&#123;</span><br><span class="line">p2=i;</span><br><span class="line">v2=dp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vec[p1].push_back(p2);</span><br><span class="line">vec[p2].push_back(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新进行dfs 和 dp 计算出这棵大树的所有dp值</span></span><br><span class="line">init(); flag=<span class="number">1</span>; dfs(<span class="number">1</span>);</span><br><span class="line">dp[<span class="number">1</span>]=value[<span class="number">1</span>]; point=n; Dp(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//a-&gt;b  b-&gt;a计算两次，所以 /2</span></span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) res+=dp[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res/<span class="number">2l</span>l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n))</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6567&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接（杭电重现赛）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你两棵树，在这两棵树上分别找一个点，将其连接，使得$\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}dis(i,j)$ 最小，其中$dis(i,j)$表示从节点 $i$ 到节点 $j$ 的边数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ABAB--2019牛客暑期多校训练营(第一场)- E题</title>
    <link href="https://boctorio.github.io/2019/07/18/ABAB-2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%9C%BA-E%E9%A2%98/"/>
    <id>https://boctorio.github.io/2019/07/18/ABAB-2019牛客暑期多校训练营-第一场-E题/</id>
    <published>2019-07-18T08:45:58.000Z</published>
    <updated>2019-07-22T00:46:06.023Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/881/E" target="_blank" rel="noopener">题目传送门</a></p><p>题目大意：</p><blockquote><p>构造一个长为 $2*(n+m)$ 的字符串，使得能从中按顺序挑出 $n$ 个”AB”子串和 $m$ 个”BA”子串，问这样的字符串一共有多少个。</p></blockquote><p>一个似乎比较明显的dp问题，类似于括号配对。</p><p>二维dp,dp[i][j],表示前i个字符,字母A和字母B的差为j个，然后就可以进行dp了。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll dp[<span class="number">1000</span>*<span class="number">4</span>+<span class="number">10</span>][<span class="number">1000</span>*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(n+m)*<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1000</span>-m<span class="number">-1</span>;j&lt;=<span class="number">1000</span>+n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">dp[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1000</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(n+m)*<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1000</span>-m;j&lt;=<span class="number">1000</span>+n;j++)&#123;</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j+<span class="number">1</span>];</span><br><span class="line">dp[i][j]%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[(n+m)*<span class="number">2</span>][<span class="number">1000</span>]%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/881/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;构造一个长为 $2*(
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Count The Rectangles(Educational Codeforces Round 68-E题)</title>
    <link href="https://boctorio.github.io/2019/07/15/Count-The-Rectangles-Educational-Codeforces-Round-68-E%E9%A2%98/"/>
    <id>https://boctorio.github.io/2019/07/15/Count-The-Rectangles-Educational-Codeforces-Round-68-E题/</id>
    <published>2019-07-15T03:12:50.000Z</published>
    <updated>2019-07-15T04:41:28.775Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1194/problem/E" target="_blank" rel="noopener">题目传送门</a></p><p>题目大意为：</p><blockquote><p>给你n条水平或竖直的线段，问利用这些线段能够圈出多少个不同的矩形。</p></blockquote><a id="more"></a><p>如果利用四条线段圈出了一个矩形，那么两条平行线一定与竖直线都相交。因此，我们只需要求与任意两条水平线均相交的竖直线的数量，然后进行排列组合 $(n*(n-1)/2)$ ,就能够找出用这两条水平线所能够圈出来的矩形的个数。</p><p>所以我们首先需要将所有的水平线与竖直线的相交情况计算出来，之后再进行枚举计算即可。</p><p>但是由于数据范围过大，在枚举两条水平线后如果再用一个循环来寻找竖直线的相交情况会超时，因此我们需要用<strong>bitset</strong>来处理最后一个循环。<strong>bitset</strong> 用法详见<a href="">bitset用法</a>。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">&#125;R[<span class="number">5000</span>+<span class="number">10</span>],C[<span class="number">5000</span>+<span class="number">10</span>];</span><br><span class="line"><span class="built_in">bitset</span>&lt;5000+10&gt;p1[<span class="number">5000</span>+<span class="number">10</span>],p2[<span class="number">5000</span>+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(node i,node j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((i.y2&gt;=j.y1 &amp;&amp; j.y1&gt;=i.y1) &amp;&amp; (j.x2&gt;=i.x1 &amp;&amp; i.x1&gt;=j.x1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,d;</span><br><span class="line"><span class="keyword">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line"><span class="keyword">if</span>(a==c)&#123;</span><br><span class="line">R[sum1].x1=a; R[sum1].y1=min(b,d); R[sum1].x2=c; R[sum1++].y2=max(b,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">C[sum2].x1=min(a,c); C[sum2].y1=b; C[sum2].x2=max(a,c); C[sum2++].y2=d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum1;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sum2;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(judge(R[i],C[j]))&#123;</span><br><span class="line">p1[i][j]=<span class="number">1</span>; p2[j][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll res=<span class="number">0</span>,sum;</span><br><span class="line">    <span class="comment">//选择数量较少的水平线或竖直线进行计算</span></span><br><span class="line"><span class="keyword">int</span> N=min(sum1,sum2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;N;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum1&lt;sum2) sum=(p1[i] &amp; p1[j]).count();</span><br><span class="line"><span class="keyword">else</span>     sum=(p2[i] &amp; p2[j]).count();</span><br><span class="line">res+=sum*(sum<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1194/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你n条水平或竖直的线段，问利用这些线段能够圈出多少个不同的矩形。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>bitset用法</title>
    <link href="https://boctorio.github.io/2019/07/15/bitset%E7%94%A8%E6%B3%95/"/>
    <id>https://boctorio.github.io/2019/07/15/bitset用法/</id>
    <published>2019-07-15T03:11:57.000Z</published>
    <updated>2019-07-15T10:16:38.902Z</updated>
    
    <content type="html"><![CDATA[<p><strong>bitset</strong> 与<strong>map,vector,queue</strong>等相似，为<strong>C++</strong>标准函数库中的一类容器。其结构类似于数组，但是只能够存放0或1。</p><a id="more"></a><h3 id="bitset的定义"><a href="#bitset的定义" class="headerlink" title="bitset的定义"></a>bitset的定义</h3><p>在定义<strong>bitset</strong> 时，一般有以下几种方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个大小为10的bitset</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;10&gt;bit1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个大小为10，初始数据为10的bitset</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;10&gt;bit2(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个大小为10，初始数据为10110的bitset</span></span><br><span class="line"><span class="built_in">string</span> str1=<span class="string">"10110"</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;10&gt;bit3(str1);</span><br></pre></td></tr></table></figure><p>以上三种方法构造出来的bitset所储存的数据分别为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0000000000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0000001010</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0000010110</span></span><br></pre></td></tr></table></figure><p>在定义时后面加的<strong>(10) 、（str1)</strong>作用均为初始化。<br>其中利用<strong>string</strong>进行初始化时字符串中只能包含0或1，包含其他字符时就会报错。</p><p>在初始化时，如果初始化数据大小小于定义的<strong>bitset</strong>大小，那么就直接右对齐，否则：</p><blockquote><p>如果初始化的数字大于定义的bitset大小，则留下后面部分，舍去高位数据<br>如果初始化的字符串长度大于定义的bitset大小，则留下前面部分，舍去低位数据</p></blockquote><p>从其储存的数据来看，其结构类似于<strong>bool</strong>数组，但其功能要比<strong>bool</strong>数组多得多。</p><h3 id="bitset位运算"><a href="#bitset位运算" class="headerlink" title="bitset位运算"></a>bitset位运算</h3><p>对bitset进行位运算时，可以把它当作数字来进行计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;10&gt;bit1(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">bitset</span>&lt;10&gt;bit2(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (bit1&lt;&lt;<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0000000110</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (bit2&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0000000010</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (bit1 &amp; bit2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0000000001</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (bit1 | bit2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0000000111</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (bit1 ^ bit2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0000000110</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>两个bitset进行位运算时，只能够数组大小相同才能够运算，否则就会报错。</strong></p><p>另外，对bitset中元素进行修改时，可按照数组的方式进行修改。<strong>但是其下标顺序为从右到左，最右数组元素下标为0。</strong></p><h3 id="bitset功能函数"><a href="#bitset功能函数" class="headerlink" title="bitset功能函数"></a>bitset功能函数</h3><p>bitset与其他容器一样，也有许多函数：</p><h4 id="统计判断函数"><a href="#统计判断函数" class="headerlink" title="统计判断函数"></a>统计判断函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;10&gt;bit1(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//2  //计算bit1中又多少个1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.any() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//1  //判断其中是否有1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.none() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//0  //判断其中是否全为0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.all() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//0  //盘但其中是否全为1</span></span><br></pre></td></tr></table></figure><h4 id="位运算函数"><a href="#位运算函数" class="headerlink" title="位运算函数"></a>位运算函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;10&gt;bit1(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.flip() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1111110101 //将所有元素倒置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.flip(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1111111101 //将数组下标为3的元素倒置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.<span class="built_in">set</span>() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//1111111111 //全部重置1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.<span class="built_in">set</span>(<span class="number">3</span>,<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1111110111 //将数组下标为3的元素置为0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.<span class="built_in">set</span>(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1111111111 //如果没有第二个参数，默认为1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.reset(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1111110111 //将数组下标为3的元素置为0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bit1.reset() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0000000000 //将所有元素置为0</span></span><br></pre></td></tr></table></figure><h4 id="转化函数"><a href="#转化函数" class="headerlink" title="转化函数"></a>转化函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;10&gt;bit1(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">string</span> str=bit1.to_string(); <span class="comment">//转化为字符串</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> a=bit1.to_ulong();<span class="comment">//转化为unsigned long </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0000001010</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>本文参考于<a href="https://www.cnblogs.com/magisk/p/8809922.html" target="_blank" rel="noopener">长岛冰茶、的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;bitset&lt;/strong&gt; 与&lt;strong&gt;map,vector,queue&lt;/strong&gt;等相似，为&lt;strong&gt;C++&lt;/strong&gt;标准函数库中的一类容器。其结构类似于数组，但是只能够存放0或1。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Tokitsukaze and Strange Rectangle(codeforces Round #573(Div.2)-F)</title>
    <link href="https://boctorio.github.io/2019/07/14/Tokitsukaze-and-Strange-Rectangle-codeforces-Round-573-Div-2-F/"/>
    <id>https://boctorio.github.io/2019/07/14/Tokitsukaze-and-Strange-Rectangle-codeforces-Round-573-Div-2-F/</id>
    <published>2019-07-14T07:20:58.000Z</published>
    <updated>2019-07-14T09:00:09.539Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1191/problem/F" target="_blank" rel="noopener">题目传送门</a></p><a id="more"></a><p>题目大意为：</p><p>给你n个一维象限的坐标，用$y=a,y=INF,x=l,x=r$ 所组成的的矩形包含的点构成一个点集，求所有不相同的点集数量。</p><p>非常复杂的一个题<strong>(just for me)</strong>。</p><p>对于一个点集，一定会有最靠左的点 $x_L$,最靠右的点 $x_R$ ，最靠下的点 $y_D$ .通过观察可知，只要固定了这三个点，就可以确定出一个点集。因此我们现在的任务就变成了如何计算所有的$x_L,x_R,y_D$。</p><p>首先我们固定 $y_D$ 的值，然后根据 $y_D$ 的值求出所有在 $y=y_D$ 上面的点，由定义可知$x_L \leq x_D \leq x_R$ ,$x_D$为$y_D$ 所对定的点的横坐标，因此我们需要计算<strong>纵坐标大于等于y_D的点中横坐标小于等于x_D的点的数量和大于等于x_D的点的数量</strong>。</p><p>在计算点的数量时，我们可以先离散化所有点的横坐标，然后利用线段树或树状数组进行查询。</p><p>但是有一种情况，如果有两个点的横坐标相同，那么求出来的点集就会有重复的情况。所以我们需要对所求的值进行某些简化。</p><p>我们在计算以 $y_{1D}$ 为底的点集时，如果 $y_{2D}==y_{1D} 并且 x_{1D} \leq x_{2D}$ , 那么我们在求大于等于 $x_{1D}$的点的数量时只需要求横坐标在区间$[ x_{1D}  , x_{2D} - 1 ]$的数即可。这样就能避免某些点集被重复计算。</p><p>代码如下（查询方式实现为线段树）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(node i,node j)&#123;</span><br><span class="line"><span class="keyword">if</span>(i.y==j.y) <span class="keyword">return</span> i.x&lt;j.x;</span><br><span class="line"><span class="keyword">return</span> i.y&gt;j.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> c[maxn],vis[maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> n,N;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">N=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(N&lt;x) N*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">k+=N<span class="number">-1</span>;</span><br><span class="line">sum[k]++;</span><br><span class="line"><span class="keyword">while</span>(k)&#123;</span><br><span class="line">k=(k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">sum[k]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(r&lt;a || b&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) <span class="keyword">return</span> sum[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> vl=query(a,b,l,(l+r)/<span class="number">2</span>,k*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> vr=query(a,b,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r,k*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> vl+vr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">c[i]=a[i].x;</span><br><span class="line">&#125;</span><br><span class="line">sort(c,c+n);</span><br><span class="line"><span class="keyword">int</span> p=unique(c,c+n)-c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i].x=lower_bound(c,c+n,a[i].x)-c;</span><br><span class="line">    </span><br><span class="line">sort(a,a+n);</span><br><span class="line">init(n);</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>=<span class="number">0</span>;<span class="comment">//list用来标记相同的纵坐标的数的起点。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].y!=a[i+<span class="number">1</span>].y)&#123;</span><br><span class="line">            <span class="comment">//每次都对相同的纵坐标的数进行一次统一的计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=last;j&lt;=i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[a[j].x])&#123;</span><br><span class="line">vis[a[j].x]=<span class="number">1</span>;</span><br><span class="line">update(a[j].x);</span><br><span class="line">&#125;</span><br><span class="line">ll vl=query(<span class="number">0</span>,a[j].x,<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//当j==i时，没有最右边的限制，因此我们就把N-1作为最右边的边界 </span></span><br><span class="line">ll vr=query(<span class="number">0</span>,(j==i)?N<span class="number">-1</span>:a[j+<span class="number">1</span>].x<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>) - query(<span class="number">0</span>,a[j].x<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">res+=vl*vr;</span><br><span class="line">&#125;</span><br><span class="line">last=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1191/problem/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kiki &amp; Little Kiki 2(HDU-2276)</title>
    <link href="https://boctorio.github.io/2019/06/30/Kiki-Little-Kiki-2-HDU-2276/"/>
    <id>https://boctorio.github.io/2019/06/30/Kiki-Little-Kiki-2-HDU-2276/</id>
    <published>2019-06-30T14:39:55.000Z</published>
    <updated>2019-07-07T06:09:04.597Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2276" target="_blank" rel="noopener">题目传送门</a></p><p>这道题的大致意思为：</p><blockquote><p>给你一圈灯，0表示灭，1表示亮。</p><p>对于任意一个灯，如果在这一秒它的左边的灯（1的左边为n）为亮，那么下一秒这个灯的状态就改变（亮变灭，灭变亮）。问经过n秒后所有灯的状态是什么样的。</p></blockquote><a id="more"></a><p>这个题非常的巧妙，假如前一个灯是1，那么后一个灯状态就会改变，不是1就不变。</p><p>这个操作与二进制中的异或操作十分相似，即 $ a[i]=a[i-1]$ ^ $a[i]$。</p><p>那么每个灯每轮亮或灭对应的操作就转化成了前面这个公式。</p><p>那么我们就把问题简化成了：</p><blockquote><p>对于每个灯，我们分别求 $ a[i]=a[i-1]$ ^ $a[i]$，问经过n轮后所有灯的状态是什么样的。</p></blockquote><p>既然我们已经求出了通项公式，那么我们就可以利用矩阵乘法去求解：<br>$$<br>\begin{bmatrix}<br>a[i] \\<br>a[i-1] \\<br>a[i-2] \\<br>… \\<br>a[1]<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; …&amp; 0 &amp; 1 \\<br>1 &amp; 1 &amp; 0 &amp; …&amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 1 &amp; …&amp; 0 &amp; 0 \\<br>… \\<br>0 &amp; 0 &amp; 0 &amp; …&amp; 1 &amp; 1 \\<br>\end{bmatrix}<br>*<br>\begin{bmatrix}<br>a[i] \\<br>a[i-1] \\<br>a[i-2] \\<br>… \\<br>a[1]<br>\end{bmatrix}<br>$$<br>这里用到了一个关于异或的性质：<strong>异或是不进位的加法</strong>，因此对于求出来的 $a[i]$ ，我们只需要对其进行<strong>%2（或&amp;1）</strong>操作即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clc(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>+<span class="number">10</span>][<span class="number">100</span>+<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line">node <span class="keyword">operator</span> *(node x,node y)&#123;</span><br><span class="line">    node z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">            z.a[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;len;k++)&#123;</span><br><span class="line">                z.a[i][j]+=x.a[i][k]*y.a[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">            z.a[i][j]&amp;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> *(node x,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    node res; clc(res.a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) res.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*x;</span><br><span class="line">        x=x*x;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">        len=<span class="built_in">strlen</span>(str);</span><br><span class="line">        node x;</span><br><span class="line">        <span class="built_in">memset</span>(x.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(x.a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) x.a[i][i]=x.a[i][(i<span class="number">-1</span>+len)%len]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        node res; clc(res.a);</span><br><span class="line">        res=x*n;</span><br><span class="line">        </span><br><span class="line">        node b; clc(b.a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) b.a[i][<span class="number">0</span>]=str[i]-<span class="string">'0'</span>;</span><br><span class="line">        res=res*b;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) <span class="built_in">printf</span>(<span class="string">"%d"</span>,res.a[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2276&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这道题的大致意思为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一圈灯，0表示灭，1表示亮。&lt;/p&gt;
&lt;p&gt;对于任意一个灯，如果在这一秒它的左边的灯（1的左边为n）为亮，那么下一秒这个灯的状态就改变（亮变灭，灭变亮）。问经过n秒后所有灯的状态是什么样的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lower_bound()基本操作方法</title>
    <link href="https://boctorio.github.io/2019/06/18/lower-bound-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://boctorio.github.io/2019/06/18/lower-bound-的使用/</id>
    <published>2019-06-18T03:44:43.000Z</published>
    <updated>2019-06-18T04:24:04.215Z</updated>
    
    <content type="html"><![CDATA[<p><strong>lower_bound()</strong>函数是一个非常有用的查找函数，其作用为在<strong>log</strong>级别的时间内查找数组中所需要的元素。</p><a id="more"></a><h3 id="lower-bound-的使用"><a href="#lower-bound-的使用" class="headerlink" title="lower_bound()的使用"></a>lower_bound()的使用</h3><h4 id="数组的lower-bound"><a href="#数组的lower-bound" class="headerlink" title="数组的lower_bound()"></a>数组的lower_bound()</h4><p><strong>lower_bound()</strong>所在函数头文件为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><p>其基本格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lower(a+x,a+y,z)</span><br></pre></td></tr></table></figure><p>上面这个代码作用为查找数组 <strong>a[]</strong> 中 <strong>a[x]~a[y]</strong> 之间第一个<strong>大于等于 </strong>z 的值。其返回值是一个地址，并不是一个数，因此在赋值时使用下面这两种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找到的位置减去数组初始位置就是该元素在数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> pos = lower_bound(a+x,a+y,z) - a;</span><br><span class="line">a[pos] = t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接对该位置进行赋值操作</span></span><br><span class="line">*lower_bound(a+x,a+y,z) = t;</span><br></pre></td></tr></table></figure><p>这是最基本的使用方式。</p><p>而它很巧妙的一种应用就是计算一个数组的<strong>最长连续递增子序列（LIS）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">*lower_bound(dp,dp+n,a[i])=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=lower_bound(dp,dp+n,INF)-a;</span><br></pre></td></tr></table></figure><p>这个代码对初学者来说有点难理解，但是理解之后感觉到这个代码的精彩之处。</p><h4 id="结构体的lower-bound"><a href="#结构体的lower-bound" class="headerlink" title="结构体的lower_bound()"></a>结构体的lower_bound()</h4><p>先来看一道题目：<a href="https://ac.nowcoder.com/acm/contest/917/H" target="_blank" rel="noopener">数据结构题</a></p><p>这个题目就使用到了<strong>lower_bound()</strong>，但是并不那么容易直接想到。</p><p>首先我们对输入的信息进行处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,pos;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(node i,node j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i.x==j.x) <span class="keyword">return</span> i.pos&lt;j.pos;</span><br><span class="line">        <span class="keyword">return</span> i.x&lt;j.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].x);</span><br><span class="line">    a[i].pos=i;</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>上述操作是为了将输入的数组元素<strong>从小到大排序，如果相同，则按照输入顺序进行排序</strong>。</p><p>当我们处理完数据后，我们就可以使用 <strong>lower_bound()</strong> 直接来进行操作。</p><p>我们的目的是找到所有的 <strong>x</strong> 中位于 <strong>l</strong> 和 <strong>r</strong> 之间的个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=lower_bound(a+<span class="number">1</span>,a+n+<span class="number">1</span>,(node)&#123;x,l&#125;)-a;</span><br><span class="line">    <span class="keyword">int</span> t=upper_bound(a+<span class="number">1</span>,a+n+<span class="number">1</span>,(node)&#123;x,r&#125;)-a;</span><br><span class="line">    <span class="keyword">return</span> t-s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>s</strong> 是找到的第一个等于符合条件的 <strong>x</strong> 的位置。</p><p><strong>t</strong> 是找到的第一个大于符合条件的 <strong>x</strong> 的位置。</p><p>两者相减即为符合条件的元素的个数。</p><p>其中，如何进行查找则是根据结构体中重载的规则。</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> mod=<span class="number">20180623</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,pos;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(node i,node j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i.x==j.x) <span class="keyword">return</span> i.pos&lt;j.pos;</span><br><span class="line">        <span class="keyword">return</span> i.x&lt;j.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=lower_bound(a+<span class="number">1</span>,a+n+<span class="number">1</span>,(node)&#123;x,l&#125;)-a;</span><br><span class="line">    <span class="keyword">int</span> t=upper_bound(a+<span class="number">1</span>,a+n+<span class="number">1</span>,(node)&#123;x,r&#125;)-a;</span><br><span class="line">    <span class="keyword">return</span> t-s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].x);</span><br><span class="line">        a[i].pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l,r,l1,r1,x;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d"</span>,&amp;l,&amp;r,&amp;l1,&amp;r1,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) swap(l,r); <span class="keyword">if</span>(l1&gt;r1) swap(l1,r1);</span><br><span class="line">        <span class="keyword">int</span> s=query(l,r,x),t=query(l1,r1,x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n%d\n%lld\n"</span>,s%mod,t%mod,(<span class="number">1l</span>l*s*t)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="upper-bound-的使用"><a href="#upper-bound-的使用" class="headerlink" title="upper_bound()的使用"></a>upper_bound()的使用</h3><p><strong>upper_bound()</strong>的作用于<strong>lower_bound()</strong>类似，只是查找位置变成了第一个<strong>大于</strong>查找元素的位置，其他操作与<strong>lower_bound()</strong>相同，因此不再赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;lower_bound()&lt;/strong&gt;函数是一个非常有用的查找函数，其作用为在&lt;strong&gt;log&lt;/strong&gt;级别的时间内查找数组中所需要的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://boctorio.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈梯度下降</title>
    <link href="https://boctorio.github.io/2019/05/18/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <id>https://boctorio.github.io/2019/05/18/梯度下降/</id>
    <published>2019-05-18T08:52:00.000Z</published>
    <updated>2019-05-20T01:58:02.760Z</updated>
    
    <content type="html"><![CDATA[<p>梯度下降是迭代法的一种,可以用于求解最小二乘问题(线性和非线性都可以)。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。反过来，如果我们需要求解损失函数的最大值，这时就需要用梯度上升法来迭代了。在机器学习中，基于基本的梯度下降法发展了两种梯度下降方法，分别为随机梯度下降法和批量梯度下降法。</p><a id="more"></a><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>梯度下降法是使用迭代的方法求解曲线的近似函数。</p><p>梯度下降主要的步骤为：</p><blockquote><ol><li><p>猜想近似函数 $h(x)$</p></li><li><p>计算出损失函数 $J(θ)= \frac{1}{2}*( h(x) - y )^2$,其中 $y$ 为 $θ$ 对应的实际值。</p></li><li>迭代求解。</li></ol></blockquote><h4 id="猜想近似函数"><a href="#猜想近似函数" class="headerlink" title="猜想近似函数"></a>猜想近似函数</h4><p>梯度下降的第一步就是猜想近似函数，猜想出来后才能根据这个函数进行函数求解。一般是根据实际值在图像中所形成的图形进行猜想。</p><h4 id="计算损失函数"><a href="#计算损失函数" class="headerlink" title="计算损失函数"></a>计算损失函数</h4><p>实际值和近似函数计算出来的值会有一些差异，梯度下降就是尽量减少这个差异。因此我们需要计算损失函数，使得损失函数尽可能的接近0.</p><p>前两步是准备工作。</p><h4 id="迭代求解"><a href="#迭代求解" class="headerlink" title="迭代求解"></a>迭代求解</h4><p>在我们计算出损失函数后，我们需要对其函数系数值进行修正。梯度下降是按照函数在<strong>某一点的导数</strong>进行修正，当迭代的次数足够多时，系数值趋于稳定时，我们就可以认为近似的求出来了曲线的近似函数。</p><h3 id="单变量线性回归问题"><a href="#单变量线性回归问题" class="headerlink" title="单变量线性回归问题"></a>单变量线性回归问题</h3><p>房屋价格与面积（数据在下面表格中）</p><table><thead><tr><th><strong>序号</strong></th><th><strong>面积</strong></th><th><strong>价格</strong></th></tr></thead><tbody><tr><td>1</td><td>150</td><td>6450</td></tr><tr><td>2</td><td>200</td><td>7450</td></tr><tr><td>3</td><td>250</td><td>8450</td></tr><tr><td>4</td><td>300</td><td>9450</td></tr><tr><td>5</td><td>350</td><td>11450</td></tr><tr><td>6</td><td>400</td><td>15450</td></tr><tr><td>7</td><td>600</td><td>18450</td></tr></tbody></table><p>使用梯度下降求解线性回归（求 $θ_0 ,  θ_1$ ）:</p><p>$$<br>h_{θ(x)}=θ_0+θ_1*x<br>$$</p><p>首先我们要写出损失函数：<br>$$<br>J(θ)=\frac{1}{2m}\sum_{i=1}^{m}{(h_θ(x^{(i)}）-y^{(i)})^2}<br>$$<br>其中 $x^{(i)} ，y^{(i)}$ 分别表示房屋面积和价格的值。$\frac{1}{2}$ 方便函数化简，不影响最终结果。$\frac{1}{m}$ 中 $m$ 表示数据集中元素个数，本题 $m=7$ .</p><p>然后我们求解导函数：</p><p>$$<br>\nabla J_{θ0} =\frac{1}{m}\sum_{i=1}^{m}{(h_{θ_1}(x^{(i)})-y^{(i)})}*θ_1<br>$$</p><p>$$<br>\nabla {J_{θ1}}= \frac{1}{m} \sum_{i=1}^{m}{(h_{θ_1}(x^{(i)})-y^{(i)})}*θ_1<br>$$</p><p>上面两式是对 $θ_1,θ_2$ 求偏导所得到的函数。然后我们根据两个函数的函数值进行迭代求解即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置数据集</span></span><br><span class="line">m=<span class="number">7</span></span><br><span class="line">alpha=<span class="number">0.000000001</span><span class="comment">#步长，即每次迭代距离</span></span><br><span class="line">area=[<span class="number">150</span>,<span class="number">200</span>,<span class="number">250</span>,<span class="number">300</span>,<span class="number">350</span>,<span class="number">400</span>,<span class="number">600</span>]</span><br><span class="line">price=[<span class="number">6450</span>,<span class="number">7450</span>,<span class="number">8450</span>,<span class="number">9450</span>,<span class="number">11450</span>,<span class="number">15450</span>,<span class="number">18450</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始值，可在合理范围内任意选，迭代次数足够多后对结果没有太大影响，建议选在数据集中的值</span></span><br><span class="line">Theta0=<span class="number">150</span></span><br><span class="line">Theta1=<span class="number">6450</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#求Theta0的偏导，即斜率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_theta0</span><span class="params">(Theta0,Theta1)</span>:</span></span><br><span class="line">    ans=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,m):</span><br><span class="line">        ans=ans+(Theta0+Theta1*area[i]-price[i])</span><br><span class="line">    <span class="keyword">return</span> ans/m</span><br><span class="line"></span><br><span class="line"><span class="comment">#求Theta1的偏导，即斜率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_Theta1</span><span class="params">(Theta0,Theta1)</span>:</span></span><br><span class="line">    ans=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,m):</span><br><span class="line">        ans=ans+(Theta0+Theta1*area[i]-price[i])*area[i]</span><br><span class="line">    <span class="keyword">return</span> ans/m;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nxt_Theta0,nxt_Theta1分别表示当前的Theta0,Theta1下一步的位置</span></span><br><span class="line"><span class="comment">#alpha * get_theta() 步长*斜率=函数值变化的多少</span></span><br><span class="line">nxt_Theta0 = Theta0 - alpha * get_theta0(Theta0,Theta1)</span><br><span class="line">nxt_Theta1 = Theta1 - alpha * get_Theta1(Theta0,Theta1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果当前位置到下一个位置函数值差距小于给定值，则退出迭代</span></span><br><span class="line"><span class="keyword">while</span> fabs(Theta1-nxt_Theta1)&gt;=<span class="number">0.000000001</span> :</span><br><span class="line">    Theta0 = nxt_Theta0</span><br><span class="line">    Theta1 = nxt_Theta1</span><br><span class="line">    a = Theta0 - alpha * get_theta0(nxt_Theta0,nxt_Theta1)</span><br><span class="line">    b = Theta1 - alpha * get_Theta1(nxt_Theta0,nxt_Theta1)</span><br><span class="line">    nxt_Theta0 = a</span><br><span class="line">    nxt_Theta1 = b</span><br><span class="line">print(Theta0,Theta1)</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">133.20781607232527 33.07613925785978</span><br></pre></td></tr></table></figure><p>接下来画图验证结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">area=[<span class="number">150</span>,<span class="number">200</span>,<span class="number">250</span>,<span class="number">300</span>,<span class="number">350</span>,<span class="number">400</span>,<span class="number">600</span>]</span><br><span class="line">price=[<span class="number">6450</span>,<span class="number">7450</span>,<span class="number">8450</span>,<span class="number">9450</span>,<span class="number">11450</span>,<span class="number">15450</span>,<span class="number">18450</span>]</span><br><span class="line"></span><br><span class="line">scatter(area,price) <span class="comment">#画出点阵图</span></span><br><span class="line"></span><br><span class="line">x=arange(<span class="number">100</span>,<span class="number">700</span>,<span class="number">100</span>) <span class="comment">#设置范围和步长</span></span><br><span class="line">y=<span class="number">133.20781607232527</span> + <span class="number">33.07613925785978</span> * x</span><br><span class="line"></span><br><span class="line">plot(x,y)</span><br><span class="line">xlabel(<span class="string">'area'</span>)</span><br><span class="line">ylabel(<span class="string">'price'</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>图像为：</p><p><img src="/2019/05/18/梯度下降/图像.png" alt=""></p><p>结果与实际情况与和很好，可认为求出近似函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;梯度下降是迭代法的一种,可以用于求解最小二乘问题(线性和非线性都可以)。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。反过来，如果我们需要求解损失函数的最大值，这时就需要用梯度上升法来迭代了。在机器学习中，基于基本的梯度下降法发展了两种梯度下降方法，分别为随机梯度下降法和批量梯度下降法。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="https://boctorio.github.io/categories/AI/"/>
    
    
      <category term="梯度下降" scheme="https://boctorio.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>二分图匹配</title>
    <link href="https://boctorio.github.io/2019/05/16/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    <id>https://boctorio.github.io/2019/05/16/二分图匹配/</id>
    <published>2019-05-16T13:55:05.000Z</published>
    <updated>2019-05-19T00:09:16.410Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。（源于百度百科）</p><a id="more"></a><p>通俗来讲，有一堆人（图中的点），每个人都有一定的人际关系（图中的边），你需要使他们和他们的朋友两两组队，每个人只能在一个队伍。这就是二分图匹配。</p><blockquote><p>极大匹配(Maximal Matching)是指在<strong>当前已完成的匹配下</strong>,无法再通过增加未完成匹配的边的方式来增加匹配的边数。</p><p>最大匹配(maximum matching)是所有极大匹配当中<strong>边数最大</strong>的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。</p></blockquote><p>一般问题都是求解二分图最大匹配问题。求解最大匹配最常用的算法为匈牙利算法。</p><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><p><a href="https://blog.csdn.net/sunny_hun/article/details/80627351" target="_blank" rel="noopener">匈牙利算法</a></p><p>这是网上最好的一篇关于匈牙利算法的文章，我不能写的比他更好了。</p><p>匈牙利算法代码量并不多，记忆起来也不复杂，在做题时遇到最主要的问题就是建图。如何将问题转化成简单的二分图匹配问题，是最需要解决的。</p><h4 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h4><p>接下来直接看一个比较复杂的二分图问题：</p><p><a href="http://poj.org/problem?id=3020" target="_blank" rel="noopener">poj3020</a></p><p>这个题大致意思就是一个天线可以覆盖本身以及相邻四个方向其中一个，问最少需要多少个天线才能覆盖所有点。</p><p><a href="https://blog.csdn.net/qq_36172505/article/details/81568552" target="_blank" rel="noopener">建图思路</a>（懒得码字了→_→）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。（源于百度百科）&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://boctorio.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Tarjan算法</title>
    <link href="https://boctorio.github.io/2019/05/12/Tarjan%E7%AE%97%E6%B3%95/"/>
    <id>https://boctorio.github.io/2019/05/12/Tarjan算法/</id>
    <published>2019-05-12T06:59:33.000Z</published>
    <updated>2019-05-12T08:19:26.830Z</updated>
    
    <content type="html"><![CDATA[<p>Tarjan算法是用来求强连通的一种算法。在学习算法之前，我们需要了解强连通的概念。</p><a id="more"></a><blockquote><p><strong>强联通</strong>：</p><p>​    在一张有向图中，对于任意两个点v1,v2,存在从v1-&gt;v2 和v2-&gt;v1 的路径，则称这张图为强连通图。</p><p><strong>强联通子图</strong>：</p><p>​    在一张有向图中，存在一张子图是强连通图，则称这个子图为强连通子图，其极大强连通子图称之为<strong>强连通分量</strong>。</p></blockquote><p>Tarjan的作用就是求强连通分量。</p><p>在遍历之前，我们需要建立一个栈来统计当前未被处理的节点。</p><p>对于下图：</p><p><img src="/2019/05/12/Tarjan算法/1.png" alt=""></p><p>我们从节点1开始dfs遍历，其中DFN表示遍历的编号，LOW表示连通块中最小的遍历的编号：</p><p>（此时栈中元素为：1 2 3 6）</p><p><img src="/2019/05/12/Tarjan算法/2.png" alt=""></p><p>遍历到节点6后，开始回溯，此时判断DFN是否等于LOW，如果相等，那么这是强连通分量上的一个点：</p><p>（此时栈中元素为：1 2 3）</p><p><img src="/2019/05/12/Tarjan算法/3.png" alt=""></p><p>回溯到节点3时，没有其他路可走，那么就判断DFN是否等于LOW，同时更新LOW[ 3 ]的值：</p><p>（此时栈中元素为：1 2）</p><p><img src="/2019/05/12/Tarjan算法/4.png" alt=""></p><p>接下来从节点2向下遍历：</p><p>（此时栈中元素为：1 2 5）</p><p><img src="/2019/05/12/Tarjan算法/5.png" alt=""></p><p>由于5 -&gt; 1 中节点1已经访问过了，那么此时我们更新LOW[ 5 ] = LOW[ 1 ] = 1,然后回溯更新LOW[2]=LOW[ 1 ]：</p><p>（此时栈中元素为：1 2 5）</p><p><img src="/2019/05/12/Tarjan算法/6.png" alt=""></p><p>回溯到节点1，向下搜节点4，节点5被访问过，回溯LOW[ 4 ]=LOW[ 5 ] = 1 ：</p><p>（此时栈中元素：1 2 5 4）</p><p><img src="/2019/05/12/Tarjan算法/7.png" alt=""></p><p>继续回溯到节点1，此时节点1相邻边已被访问完毕，判断DFN是否等于LOW，相等就开始标记强连通分量。将栈中元素LOW相等的全部连通。</p><p>完毕。</p><p>模板为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,tt,cnt,sig;</span><br><span class="line"><span class="keyword">int</span> vis[maxn],low[maxn],dfn[maxn];</span><br><span class="line"><span class="keyword">int</span> color[maxn];<span class="comment">//color[]为染色，即强连通中的元素染成同一种颜色。</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line"><span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line"><span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vec[i].clear();</span><br><span class="line"><span class="keyword">while</span>(!st.empty()) st.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line">dfn[x]=low[x]=cnt++;</span><br><span class="line">st.push(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec[x].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> y=vec[x][i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]==<span class="number">0</span>) tarjan(y);<span class="comment">//未被访问过，向下遍历</span></span><br><span class="line"><span class="keyword">if</span>(vis[y]==<span class="number">1</span>) low[x]=min(low[x],low[y]);<span class="comment">//更新LOW下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">sig++;<span class="comment">//染色序号</span></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;<span class="comment">//将栈中x及其以后的节点全部标记为同一种颜色（sig）</span></span><br><span class="line"><span class="keyword">int</span> t=st.top(); st.pop();</span><br><span class="line"><span class="keyword">if</span>(t==x) flag=<span class="number">1</span>;</span><br><span class="line">color[t]=sig;</span><br><span class="line">vis[t]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">tt=<span class="number">-1</span>;cnt=<span class="number">1</span>;sig=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]==<span class="number">0</span>) tarjan(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此处添加其他操作 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tarjan算法是用来求强连通的一种算法。在学习算法之前，我们需要了解强连通的概念。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最短编辑距离</title>
    <link href="https://boctorio.github.io/2019/05/09/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>https://boctorio.github.io/2019/05/09/最短编辑距离/</id>
    <published>2019-05-09T11:59:20.000Z</published>
    <updated>2019-05-09T13:32:23.150Z</updated>
    
    <content type="html"><![CDATA[<p>编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。</p><a id="more"></a><p>例如两个字符串 “main” 和 “mian”，从前一个字符串变成后一个串，需要先删除一个字符 ‘ a ’ ,然后再在字符 ‘ i ‘ 后面加一个 ‘ a ‘ ,那么他们的最短编辑距离就为2。</p><p>求解这类问题的方法一般为动态规划。</p><h4 id="不加权最短编辑距离"><a href="#不加权最短编辑距离" class="headerlink" title="不加权最短编辑距离"></a>不加权最短编辑距离</h4><p>这是最基本的裸题，只求字符串操作次数。</p><p>假设当前第一个串位置为 i ,第二个串位置为 j ，dp[ i ][ j ] 表示最短编辑距离。</p><p>我们看一下三种操作：<strong>替换，插入，删除</strong></p><blockquote><p><strong>替换</strong>：</p><p>​    如果仅仅是替换，假设我们已经求出来了 dp[ i - 1 ][ j - 1 ] , 那么从dp[ i - 1 ][ j - 1 ] 到  dp[ i ][ j ]  $只操作了一次，即 dp[ i ][ j ] = dp[ i - 1 ][ j - 1 ] +1  。</p><p><strong>插入</strong>：</p><p>​    如果插入后串的长度分别为 i , j ,那么当前状态可以是从 i - 1 , j 的情况下第一个串插入一个字符得到的，因此 dp[ i ][ j ]= dp[ i - 1 ][ j ] + 1  ；  </p><p><strong>删除</strong>：</p><p>​    删除同上，当前状态可以是从 i , j - 1 的情况下删除了一个字符得到的，因此dp[ i ][ j ]= dp[ i ][ j - 1 ] + 1  ；  </p></blockquote><p>这就是三种状态分别对应的状态方程，特殊的，当 i = 0 或 j = 0 时，最短编辑距离就是当前两个串的差值，即另一个变量对应的值。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串数组下标从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化i=0或j=0的情况。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++) dp[<span class="number">0</span>][j]=j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//四种状态 按顺序为：删除，插入，字符匹配（不需要编辑），替换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">    dp[i][j]=min(min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(a[i]==b[j]?<span class="number">0</span>:<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加权最短编辑距离"><a href="#加权最短编辑距离" class="headerlink" title="加权最短编辑距离"></a>加权最短编辑距离</h4><p>省赛原题：</p><blockquote><p>多组输入</p><p>第一行输入四个数 a,b,c,d,表示字符匹配加 a 分，替换减b分，插入减c分，删除减d分。</p><p>接下来两行，每行一个字符串。</p><p>输出最大得分。</p></blockquote><p>这个题其实也算是编辑距离的裸题，当时状态方程写了出来，但是不知道为什么wa了（可能还是不熟悉）。</p><p>加权的转移方程其实和不加权的差不多，只是在转移方程的加减上做了一点变化。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于对应的权值不同，初始化的值也不同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=-i*d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++) dp[<span class="number">0</span>][j]=-j*c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">dp[i][j]=max(max(dp[i<span class="number">-1</span>][j]-c,dp[i][j<span class="number">-1</span>]-d),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(s1[i]==s2[j]?a:-b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="https://boctorio.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>模板库（持续更新）</title>
    <link href="https://boctorio.github.io/2019/05/05/%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://boctorio.github.io/2019/05/05/模板库（持续更新）/</id>
    <published>2019-05-05T04:43:33.000Z</published>
    <updated>2019-06-26T10:40:37.142Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下我学过的部分算法模板。</p><a id="more"></a><h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2222" target="_blank" rel="noopener">HDU2222</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[maxn][<span class="number">26</span>];<span class="comment">//trie树 每个节点对应一个数字 </span></span><br><span class="line"><span class="keyword">int</span> cntword[maxn];<span class="comment">//统计每个节点为单词终点的个数 </span></span><br><span class="line"><span class="keyword">int</span> fail[maxn];<span class="comment">//fail指针 </span></span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span>(trie));</span><br><span class="line"><span class="built_in">memset</span>(cntword,<span class="number">0</span>,<span class="keyword">sizeof</span>(cntword));</span><br><span class="line"><span class="built_in">memset</span>(fail,<span class="number">0</span>,<span class="keyword">sizeof</span>(fail));</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[root][s[i]-<span class="string">'a'</span>]) trie[root][s[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">root=trie[root][s[i]-<span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line">cntword[root]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(trie[<span class="number">0</span>][i]) que.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> now=que.front();</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(trie[now][i])&#123;</span><br><span class="line">fail[trie[now][i]]=trie[fail[now]][i];</span><br><span class="line">que.push(trie[now][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">trie[now][i]=trie[fail[now]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">now=trie[now][s[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=now;j &amp;&amp; cntword[j]!=<span class="number">-1</span>;j=fail[j])&#123;</span><br><span class="line">res+=cntword[j];</span><br><span class="line">cntword[j]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">insert(s);</span><br><span class="line">&#125;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">getfail();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x==pre[x]?x:pre[x]=find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">x=find(x);</span><br><span class="line">y=find(y);</span><br><span class="line"><span class="keyword">if</span>(x&lt;y) pre[y]=x;</span><br><span class="line"><span class="keyword">else</span> pre[x]=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> y?gcd(y,x%y):x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KM"><a href="#KM" class="headerlink" title="KM"></a>KM</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> love[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> exgirl[maxn],exboy[maxn];</span><br><span class="line"><span class="keyword">bool</span> visgirl[maxn],visboy[maxn];</span><br><span class="line"><span class="keyword">int</span> match[maxn],slack[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">visgirl[x]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visboy[i])&#123;</span><br><span class="line"><span class="keyword">int</span> gap=exgirl[x]+exboy[i]-love[x][i];</span><br><span class="line"><span class="keyword">if</span>(gap==<span class="number">0</span>)&#123;</span><br><span class="line">visboy[i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(match[i]==<span class="number">-1</span> || dfs(match[i]))&#123;</span><br><span class="line">match[i]=x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">slack[i]=min(slack[i],gap);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">km</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line"><span class="built_in">memset</span>(exboy,<span class="number">0</span>,<span class="keyword">sizeof</span>(exboy));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">exgirl[i]=love[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">exgirl[i]=max(exgirl[i],love[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">fill(slack,slack+n,INF);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(visgirl,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visgirl));</span><br><span class="line"><span class="built_in">memset</span>(visboy,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visboy));</span><br><span class="line"><span class="keyword">if</span>(dfs(i)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visboy[i]) d=min(d,slack[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visgirl[i]) exgirl[i]-=d;</span><br><span class="line"><span class="keyword">if</span>(visboy[i]) exboy[i]+=d;</span><br><span class="line"><span class="keyword">else</span> slack[i]-=d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">res+=love[match[i]][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void get_nxt()&#123;</span><br><span class="line">int i=1,next[1]=0,j=0;</span><br><span class="line">int len=strlen(str);</span><br><span class="line">while(i&lt;len)&#123;</span><br><span class="line">if(j==0 || str[i]==str[j])&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">j=next[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,tt,cnt,sig;</span><br><span class="line"><span class="keyword">int</span> vis[maxn],low[maxn],dfn[maxn];</span><br><span class="line"><span class="keyword">int</span> color[maxn],st[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line"><span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line"><span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line"><span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span>(st));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vec[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line">dfn[x]=low[x]=cnt++;</span><br><span class="line">st.push(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec[x].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> y=vec[x][i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]==<span class="number">0</span>) tarjan(y);</span><br><span class="line"><span class="keyword">if</span>(vis[y]==<span class="number">1</span>) low[x]=min(low[x],low[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">sig++;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">color[st[tt]]=sig;</span><br><span class="line">vis[st[tt]]=<span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(st[tt--]!=x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">tt=<span class="number">-1</span>;cnt=<span class="number">1</span>;sig=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]==<span class="number">0</span>) tarjan(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此处添加其他操作 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line">&#125;p[maxn],q[maxn];</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line"><span class="function">node <span class="title">getmag</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">node s;</span><br><span class="line">s.x=b.x-a.x;</span><br><span class="line">s.y=b.y-a.y;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiX</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> multiX(getmag(p[<span class="number">1</span>],a),getmag(p[<span class="number">1</span>],b))&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graham</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123; </span><br><span class="line"><span class="keyword">if</span>(p[i].x&lt;p[id].x || (p[i].x==p[id].x &amp;&amp; p[i].y&lt;p[id].y)) id=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(id!=<span class="number">1</span>) swap(p[id],p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">sort(p+<span class="number">2</span>,p+n+<span class="number">1</span>,cmp); </span><br><span class="line">q[++l]=p[<span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l&gt;=<span class="number">2</span> &amp;&amp; multiX(getmag(q[l<span class="number">-1</span>],p[i]),getmag(q[l<span class="number">-1</span>],q[l]))&gt;=<span class="number">0</span>) l--;</span><br><span class="line">q[++l]=p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="线段树单点更新-查询区间最大值"><a href="#线段树单点更新-查询区间最大值" class="headerlink" title="线段树单点更新+查询区间最大值"></a>线段树单点更新+查询区间最大值</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="noopener">HDU1754</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> dat[maxn],n;</span><br><span class="line"><span class="keyword">int</span> m,a,b;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&lt;x) n*=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">dat[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">k+=n<span class="number">-1</span>;</span><br><span class="line">dat[k]=a;</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">k=(k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">dat[k]=max(dat[k*<span class="number">2</span>+<span class="number">1</span>],dat[k*<span class="number">2</span>+<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r&lt;a || b&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) <span class="keyword">return</span> dat[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> vl=query(a,b,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> vr=query(a,b,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">return</span> max(vl,vr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n_;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">n_=n;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n_;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dat[i+n<span class="number">-1</span>]);</span><br><span class="line">update(i,dat[i+n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c %d %d"</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(a<span class="number">-1</span>,b<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'U'</span>) update(a<span class="number">-1</span>,b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树区间更新"><a href="#线段树区间更新" class="headerlink" title="线段树区间更新"></a>线段树区间更新</h4><p><a href="http://acm.fzu.edu.cn/problem.php?pid=1608" target="_blank" rel="noopener">FZU1608</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,dat[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&lt;x) n*=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">dat[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&lt;l || r&lt;a) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) dat[k]=max(x,dat[k]);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> mmax)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> max(mmax,dat[k]);</span><br><span class="line">dat[k]=max(mmax,dat[k]);</span><br><span class="line"><span class="keyword">int</span> vl=query(l,(l+r)/<span class="number">2</span>,k*<span class="number">2</span>+<span class="number">1</span>,dat[k]);</span><br><span class="line"><span class="keyword">int</span> vr=query((l+r)/<span class="number">2</span>+<span class="number">1</span>,r,k*<span class="number">2</span>+<span class="number">2</span>,dat[k]);</span><br><span class="line"><span class="keyword">return</span> vl+vr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,x;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;x);</span><br><span class="line">update(a,b<span class="number">-1</span>,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树区间更新-区间求和"><a href="#线段树区间更新-区间求和" class="headerlink" title="线段树区间更新+区间求和"></a>线段树区间更新+区间求和</h4><p><a href="http://poj.org/problem?id=3468" target="_blank" rel="noopener">POJ3468</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll maxn=<span class="number">1000000</span>;</span><br><span class="line">ll dat[maxn],sum[maxn],n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll a,ll b,ll x,ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b)&#123;</span><br><span class="line">dat[k]+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l&lt;=b &amp;&amp; a&lt;=r)&#123;</span><br><span class="line">sum[k]+=(min(b,r)-max(a,l)+<span class="number">1</span>)*x;</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll a,ll b,ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&lt;l || r&lt;a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) <span class="keyword">return</span> dat[k]*(r-l+<span class="number">1</span>)+sum[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ll res=(min(b,r)-max(a,l)+<span class="number">1</span>)*dat[k];</span><br><span class="line">res+=query(a,b,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">res+=query(a,b,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll a,b,x;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">update(i,i,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'Q'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(a<span class="number">-1</span>,b<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;a,&amp;b,&amp;x);</span><br><span class="line">update(a<span class="number">-1</span>,b<span class="number">-1</span>,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h3><h4 id="静态主席树"><a href="#静态主席树" class="headerlink" title="静态主席树"></a>静态主席树</h4><p>//查询区间第k小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> rt[maxn],ls[maxn*<span class="number">2</span>],rs[maxn*<span class="number">2</span>],sum[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> tot,N,n,q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">o=++tot;</span><br><span class="line">sum[o]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">build(ls[o],l,m);</span><br><span class="line">build(rs[o],m+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> last,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">o=++tot;</span><br><span class="line">ls[o]=ls[last];</span><br><span class="line">rs[o]=rs[last];</span><br><span class="line">sum[o]=sum[last]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=m) update(ls[o],l,m,ls[last],k);</span><br><span class="line"><span class="keyword">else</span> update(rs[o],m+<span class="number">1</span>,r,rs[last],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">int</span> cnt=sum[ls[e]]-sum[ls[s]];</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=cnt) <span class="keyword">return</span> query(ls[s],ls[e],l,m,k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(rs[s],rs[e],m+<span class="number">1</span>,r,k-cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> l,r,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">b[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line">sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">N=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-(b+<span class="number">1</span>);</span><br><span class="line">build(rt[<span class="number">0</span>],<span class="number">1</span>,N);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) update(rt[i],<span class="number">1</span>,N,rt[i<span class="number">-1</span>],lower_bound(b+<span class="number">1</span>,b+N+<span class="number">1</span>,a[i])-b);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line"><span class="keyword">int</span> ans=query(rt[l<span class="number">-1</span>],rt[r],<span class="number">1</span>,N,k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[ans]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态主席树"><a href="#动态主席树" class="headerlink" title="动态主席树"></a>动态主席树</h4><p>//修改单点+查询区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">60000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],hash[maxn];</span><br><span class="line"><span class="keyword">int</span> rt[maxn],RT[maxn],ls[maxn*<span class="number">32</span>],rs[maxn*<span class="number">32</span>],sum[maxn*<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> ul[maxn],ur[maxn]; </span><br><span class="line"><span class="keyword">int</span> tot,n,q,N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,k;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">&#125;op[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123; </span><br><span class="line">o=++tot;</span><br><span class="line">sum[o]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">build(ls[o],l,m);</span><br><span class="line">build(rs[o],m+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> last,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123; </span><br><span class="line">o=++tot;</span><br><span class="line">ls[o]=ls[last];</span><br><span class="line">rs[o]=rs[last];</span><br><span class="line">sum[o]=sum[last]+val;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(p&lt;=m) update(ls[o],l,m,ls[last],p,val);</span><br><span class="line"><span class="keyword">else</span> update(rs[o],m+<span class="number">1</span>,r,rs[last],p,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=lower_bound(hash+<span class="number">1</span>,hash+N+<span class="number">1</span>,a[x])-hash;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)&#123; </span><br><span class="line">update(RT[x],<span class="number">1</span>,N,RT[x],res,val);</span><br><span class="line">x+=lowbit(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) res+=sum[ls[ur[x]]];</span><br><span class="line"><span class="keyword">else</span> res+=sum[ls[ul[x]]];</span><br><span class="line">x-=lowbit(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> ts,<span class="keyword">int</span> te,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=Sum(e,<span class="literal">true</span>)-Sum(s,<span class="literal">false</span>)+sum[ls[te]]-sum[ls[ts]];</span><br><span class="line"><span class="keyword">if</span>(k&lt;=cnt)&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=e;i;i-=lowbit(i)) ur[i]=ls[ur[i]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s;i;i-=lowbit(i)) ul[i]=ls[ul[i]];</span><br><span class="line"><span class="keyword">return</span> query(s,e,ls[ts],ls[te],l,m,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=e;i;i-=lowbit(i)) ur[i]=rs[ur[i]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s;i;i-=lowbit(i)) ul[i]=rs[ul[i]];</span><br><span class="line"><span class="keyword">return</span> query(s,e,rs[ts],rs[te],m+<span class="number">1</span>,r,k-cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">hash[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">2</span>];</span><br><span class="line">N=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;op[i].l,&amp;op[i].r,&amp;op[i].k);</span><br><span class="line">op[i].flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;op[i].r,&amp;op[i].k);</span><br><span class="line">op[i].flag=<span class="literal">false</span>;</span><br><span class="line">hash[++N]=op[i].k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(hash+<span class="number">1</span>,hash+N+<span class="number">1</span>);</span><br><span class="line">N=unique(hash+<span class="number">1</span>,hash+N+<span class="number">1</span>)-(hash+<span class="number">1</span>);</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line">build(rt[<span class="number">0</span>],<span class="number">1</span>,N);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) update(rt[i],<span class="number">1</span>,N,rt[i<span class="number">-1</span>],lower_bound(hash+<span class="number">1</span>,hash+N+<span class="number">1</span>,a[i])-hash,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) RT[i]=rt[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> l=op[i].l,r=op[i].r,k=op[i].k;</span><br><span class="line"><span class="keyword">if</span>(op[i].flag)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=r;j;j-=lowbit(j)) ur[j]=RT[j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=l<span class="number">-1</span>;j;j-=lowbit(j)) ul[j]=RT[j];</span><br><span class="line">                <span class="keyword">int</span> res=query(l<span class="number">-1</span>,r,rt[l<span class="number">-1</span>],rt[r],<span class="number">1</span>,N,k);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hash[res]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                add(r,<span class="number">-1</span>);</span><br><span class="line">                a[r]=k;</span><br><span class="line">                add(r,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一下我学过的部分算法模板。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>凸包</title>
    <link href="https://boctorio.github.io/2019/04/30/%E5%87%B8%E5%8C%85/"/>
    <id>https://boctorio.github.io/2019/04/30/凸包/</id>
    <published>2019-04-30T11:13:39.000Z</published>
    <updated>2019-05-02T08:45:51.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><blockquote><p>凸包（Convex Hull）是一个计算几何（图形学）中的概念。<br>在一个实数向量空间V中，对于给定集合X，所有包含X的凸集的交集S被称为X的凸包。X的凸包可以用X内所有点(X1，…Xn)的凸组合来构造.<br>在二维欧几里得空间中，凸包可想象为一条刚好包著所有点的橡皮圈。<br>用不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边形，它能包含点集中所有的点。（来源于百度百科）</p></blockquote><a id="more"></a><p>凸包是计算几何题目中经常出现的概念，一般形式为给你 $ n ​$ 个点，求这些点所构成的凸包的面积。</p><p><img src="/2019/04/30/凸包/凸包.gif" alt=""></p><p>这张动图是求凸包的过程。</p><p>求凸包的基本顺序为：</p><blockquote><ol><li>找到凸包上的一个点，一般为x坐标最小的点。</li><li>将找到的点设为原点，根据极角排序方式将剩余的点进行排序</li><li>循环找凸包上的点<ol><li>如果当前点比上一个点更可能是凸包上的点，那么就覆盖上一个点，更新为当前点。</li><li>如果当前点没有上一个点适合当凸包上的点，那么就先放进凸包集合中，继续寻找下一个点。</li></ol></li><li>循环结束。</li></ol></blockquote><p>关于当前点是否更有可能是凸包上的点，用下面的几张图来讲解：</p><p><img src="/2019/04/30/凸包/t1.png" alt=""></p><p>当前凸包内有三个点v0,v1,v2，接下来判断v3的时候，我们需要对它进行判断：</p><p><img src="/2019/04/30/凸包/t2.png" alt=""></p><p>$v1$ 与 $v2,v3$ 相连，判断两条线的夹角的方向，如果是逆时针方向，那么就可以放入凸包集合中:</p><p><img src="/2019/04/30/凸包/t3.png" alt=""></p><p>接下来同样的办法判断v4:</p><p><img src="/2019/04/30/凸包/t4.png" alt=""></p><p>如果是顺时针方向，那么 $v4$ 就优于 $v3$ ，我们删去 $v3$ ，接下来继续判断：</p><p><img src="/2019/04/30/凸包/t6.png" alt=""></p><p>逆时针，所以可以放入图包集合：</p><p><img src="/2019/04/30/凸包/t5.png" alt=""></p><p>之后一直重复这个过程即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line">&#125;p[maxn],q[maxn];</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line"><span class="function">node <span class="title">getmag</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//计算边 表示从a-&gt;b的向量 </span></span><br><span class="line">node s;</span><br><span class="line">s.x=b.x-a.x;</span><br><span class="line">s.y=b.y-a.y;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiX</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//叉乘的正负代表两条直线夹角的顺逆 </span></span><br><span class="line"><span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//根据极角排序</span></span><br><span class="line"><span class="keyword">return</span> multiX(getmag(p[<span class="number">1</span>],a),getmag(p[<span class="number">1</span>],b))&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graham</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="comment">//找出最开始的一个点 </span></span><br><span class="line"><span class="keyword">if</span>(p[i].x&lt;p[id].x || (p[i].x==p[id].x &amp;&amp; p[i].y&lt;p[id].y)) id=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(id!=<span class="number">1</span>) swap(p[id],p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">sort(p+<span class="number">2</span>,p+n+<span class="number">1</span>,cmp);<span class="comment">//极角排序 </span></span><br><span class="line">q[++l]=p[<span class="number">1</span>];<span class="comment">//p: 所有点集合  q: 凸包点集合 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="comment">//如果夹角是顺时针方向，那么就可以取代 </span></span><br><span class="line"><span class="keyword">while</span>(l&gt;=<span class="number">2</span> &amp;&amp; multiX(getmag(q[l<span class="number">-1</span>],p[i]),getmag(q[l<span class="number">-1</span>],q[l]))&gt;=<span class="number">0</span>) l--;</span><br><span class="line">q[++l]=p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;凸包&quot;&gt;&lt;a href=&quot;#凸包&quot; class=&quot;headerlink&quot; title=&quot;凸包&quot;&gt;&lt;/a&gt;凸包&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;凸包（Convex Hull）是一个计算几何（图形学）中的概念。&lt;br&gt;在一个实数向量空间V中，对于给定集合X，所有包含X的凸集的交集S被称为X的凸包。X的凸包可以用X内所有点(X1，…Xn)的凸组合来构造.&lt;br&gt;在二维欧几里得空间中，凸包可想象为一条刚好包著所有点的橡皮圈。&lt;br&gt;用不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边形，它能包含点集中所有的点。（来源于百度百科）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="凸包" scheme="https://boctorio.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="https://boctorio.github.io/2019/04/16/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>https://boctorio.github.io/2019/04/16/树状数组/</id>
    <published>2019-04-16T03:21:17.000Z</published>
    <updated>2019-04-17T12:54:31.758Z</updated>
    
    <content type="html"><![CDATA[<p>树状数组在数据结构上和线段树类似，功能上均用来求解区间的修改，查询，计数等问题。</p><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>树状数组的突出优点为代码简洁，相比于线段树，其修改、查询函数均非常简短。</p><p>线段树的数据结构为：</p><p><img src="/2019/04/16/树状数组/二叉树.png" alt=""></p><p>将线段树数组的位置进行改变就得到了树状数组：</p><p><img src="/2019/04/16/树状数组/树状数组.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树状数组在数据结构上和线段树类似，功能上均用来求解区间的修改，查询，计数等问题。&lt;/p&gt;
&lt;h3 id=&quot;树状数组&quot;&gt;&lt;a href=&quot;#树状数组&quot; class=&quot;headerlink&quot; title=&quot;树状数组&quot;&gt;&lt;/a&gt;树状数组&lt;/h3&gt;&lt;p&gt;树状数组的突出优点为代码简洁
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nim博弈--简单证明</title>
    <link href="https://boctorio.github.io/2019/04/15/Nim%E5%8D%9A%E5%BC%88-%E7%AE%80%E5%8D%95%E8%AF%81%E6%98%8E/"/>
    <id>https://boctorio.github.io/2019/04/15/Nim博弈-简单证明/</id>
    <published>2019-04-15T09:32:37.000Z</published>
    <updated>2019-04-16T03:10:48.990Z</updated>
    
    <content type="html"><![CDATA[<p>Nim博弈是ACM入门的博弈之一，其基本描述为：</p><blockquote><p>有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。</p><a id="more"></a><p>这游戏看上去有点复杂，先从简单情况开始研究吧。如果轮到你的时候，只剩下一堆石子，那么此时的必胜策略肯定是把这堆石子全部拿完一颗也不给对手剩，然后对手就输了。如果剩下两堆不相等的石子，必胜策略是通过取多的一堆的石子将两堆石子变得相等，以后如果对手在某一堆里拿若干颗，你就可以在另一堆中拿同样多的颗数，直至胜利。如果你面对的是两堆相等的石子，那么此时你是没有任何必胜策略的，反而对手可以遵循上面的策略保证必胜。如果是三堆石子……好像已经很难分析了，看来我们必须要借助一些其它好用的（最好是程式化的）分析方法了，或者说，我们最好能够设计出一种在有必胜策略时就能找到必胜策略的算法。（源自百度百科）</p></blockquote><p>如果有点基础的同学就会知道Nim博弈的判断胜负的办法：</p><blockquote><p>将每堆石子个数异或，如果异或结果非零，则先手必胜，否则先手必败。</p></blockquote><p>我们先对必败局面，即最终异或结果为  $0​$  （假设异或结果为 $A​$）进行分析：</p><p>如果现在第一个人拿任意一堆石子中的 $B​$ 个，那么现在剩余石子的异或结果 $A’​$必定不为  $0​$ ，而且可以看出$A’=B​$。</p><p>接下来是第二个人的操作。在二进制的情况下，$A’$ 的位数和 $B$ 的位数相同（假定为 $n+1$位），<strong>即剩余的所有石子中必定有一堆石子的数量（假定为 $C$ ）不少于 $2^n$ 个，且二进制下第 $n$ 位必定为 1 。假如我们拿出这一堆石子中的 $2 ^ n$ 个，现在剩下的所有石子异或结果 $A’’$ 一定小于  $2 ^ n$ ($A’’$ 第 $n$ 位此时变成了 $0$ )</strong> ，所以我们可以从这 $C$ 个石子中拿走  $2^n-A’’$ 个，剩余 $A’’$ 个，这样，剩余的石子异或的结果一定为 $A’’$ ^ $A’’ $  $=0$ 。这样，第二个人就能在一次操作后将异或的结果变为  $0$ 。</p><p>第二个人持续上述操作，就能够使第一个人当前的异或结果永远为 $0​$ ，第二个人当前的异或结果永远不为 $0​$ ，而最终当取完所有石子时，结果也为  $0​$ 。</p><p>假如初始 $A​$ 不为零，那么第一个人也可通过上述操作使得异或结果为 $0​$ 。</p><p>这样就证明了异或结果可以判断最终胜负的正确性。</p><p>（持续更新……）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nim博弈是ACM入门的博弈之一，其基本描述为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="博弈" scheme="https://boctorio.github.io/categories/%E5%8D%9A%E5%BC%88/"/>
    
    
      <category term="Nim博弈" scheme="https://boctorio.github.io/tags/Nim%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>菜鸡的CCPC河南省赛一日游</title>
    <link href="https://boctorio.github.io/2019/04/13/%E8%8F%9C%E9%B8%A1%E7%9A%84CCPC%E6%B2%B3%E5%8D%97%E7%9C%81%E8%B5%9B%E4%B8%80%E6%97%A5%E6%B8%B8/"/>
    <id>https://boctorio.github.io/2019/04/13/菜鸡的CCPC河南省赛一日游/</id>
    <published>2019-04-13T14:23:26.000Z</published>
    <updated>2019-04-16T03:13:21.076Z</updated>
    
    <content type="html"><![CDATA[<p>希望下回有个好成绩。</p><a id="more"></a><p>公元2019年4月13日。</p><p>清晨一如既往地冷，校园内三三两两的学生在路上悠闲地走着。餐厅内工作人员已经在这个放假的日子早早的起床做饭。</p><p>餐厅中央侧边的两张餐桌旁，坐着我们学校早起的参赛选手们。在体育节放假的这两天，两回训练赛早就冲淡了我们比赛的紧张感。我们坐在这里，吃着饭，聊着即将到来的CCPC省赛。</p><p>餐厅外，象征着青春活力的太阳已经爬上了天空。</p><p>吃完饭后，我们出了餐厅，就朝着东门的方向走去，7:50我们将准时出发去郑州轻工业大学。</p><p>这次比赛学校多了不少新的队员，都是在之前的三次积分赛上选拔出来的优秀选手。其中还包括两只大一的队伍，他们很努力；他们也很幸运，能够在大一就有机会去参加省赛。还有一只留学生的队伍，他们是教练的学生，对算法有着和我们一样的兴趣，但是我们一行人只有会长能够和他们谈笑风生，我这个连四级都没有过的人只能在旁边看着他们聊天。</p><p>这次比赛由于教练有事，所以我们教练又找了一个带队老师。这位老师在我们的校赛方面也提供很大的帮助。很年轻的一位老师，性格也很好，和我们的教练一样好。</p><p>清点完人数，我们就踏上了去打比赛的征途。又是熟悉的大巴，和蓝桥杯、天梯赛的大巴一样，坐满了我们心情忐忑的一行人。去年我们的学长在ICPC省赛中拿到了非常优异的成绩，作为学校大二的顶尖力量（其实也不过如此），我们队的压力–主要是我的压力–也是非常的大，想拿个更好的成绩去向学长们报汇报。学长为了培养我们，牺牲了自己的课余时间，给我们开公开课，开集训，我也不想在这样一个比赛中拿到并不是非常优异的成绩去报答学长们的付出。</p><p>今天的阳光很好。前几天天阴着，刮着冷风，像是又一季的冬天。</p><p>由于学校行程的安排，我们在到达轻大的时候开幕式已经开始了。报完到后，我们又在外面逛了许久，轻大看起来还是那么广阔，在清晨阳光的照射下，图书馆前的广场看起来有了别样的感觉。不久，我们就前往了考场。</p><p>到达机房门口，我们看到了比赛的环境，win10系统，电脑也和上回来的时候不一样了，看来是主办方为了省赛确实花了很大力气。</p><p>由于没有参加开幕式，到达机房时间有点早，我们几个队伍也在机房外面闲谈了起来，免不了的一波毒奶。</p><p>进入机房后，惊奇的发现键盘也换了，上次打天梯赛的键盘是老式的键盘，按起来也非常的费力。这一次的换了一种薄膜键盘，虽然用起来并没有机械键盘那么舒服，但是相比之前的还是好了很多。</p><p>在距比赛开始前几分钟，我和我队友就发现现场好像并没有纸质题面。询问了一下考场的老师，老师也说去问一下。果然没多久，就传来了比赛推迟的消息。十分钟后，又传来了比赛推迟的消息。10:20，比赛正式开始了。</p><p>由于刚开始我们以为会发三个纸质题面，但是发下来之后发现只有一个，有点大乱了我们的阵脚，dicer提议把题面撕成两份，我和codancer一人看半份，dicer看电脑。当我看了第一题我的脑子里只剩下了“？？？？？？？？”，这…应该不是签到题吧。于是我又看了B，这…应该也不是签到题吧。当我在看B的时候，dicer看了一下榜，说 D E 好像是签到题，我看了一下，确实是签到题，然后dicer就迅速的敲起了键盘，两个签到题花了8分钟写完了。</p><p>之后过了好久，没人再开出来其他题了。由于我拿的是前半部分，所以一直在看ABC，差点看自闭了，图论是我的弱项，然而BC全是树形结构，然后我就GG了。签到题写完后，dicer看了 A ，感觉可写，就给codancer说了一下，于是他们就开始全心攻A题，我觉得BC我不可写，就让codancer把另一半题面给了我，我看了 F，发现是个数学题，这就很不错了嘛。刚开始看懂题意，那不就是直接模拟吗，dicer看了题，提醒我说数据范围1e18,然后我又陷入了自闭之中，之后我就开始了漫长的化简之旅。</p><p>在纸上算了一会后，我发现符合条件的区间可以被分为不连续和连续两部分，然后我就开始继续慢慢计算每个小区间怎么处理，然后想了一个极其复杂的处理方法。我正在疯狂想办法化简的时候，dicer 和 codancer 经过激烈的讨论以及盲猜了一发结论WA了之后，看出来 A 是dp，于是把代码全盘来写。我在化简的时候发现可以先计算出小区间的范围，然后根据l r 值进行判断，激动了一下，但是看他们还在写 A ，我就决定先把代码写在纸上，看看能不能行的通，不一会，他们俩就又交了一发 A ，WA了，然后我问 A 题怎么样了，他们说害还得再找找思路有没有问题，我就说让我先敲 F 题吧，然后他们就在旁边讨论找反例来了。</p><p>我根据我的思路，很快写好了 F 题，但是测样例的时候四个就过了一个，我思考起是不是哪里写错了，就看着代码一步步的进行计算，他们在讨论了一阵之后，发现了问题在哪，然后又开始修改他们的代码，我就在旁边看我的思路是不是哪错了，之后没一会，他们又交了一发 A ，过了！然后看榜单，发现排名前几，但是罚时有点多，三题垫底。</p><p>我又开始了我的改bug之旅，他们又在旁边讨论起了 C 题，我对着样例又计算了一遍，才发现区间是左闭右开的，赶紧改bug，测样例，过了！提交，过了！</p><p>我问他们 C 题怎么样了，他们说稍微有点思路，但是复杂度太大，我看了看题，发现复杂度确实有点高。看了一眼榜单，发现开出来的这几个都差不多了，于是想着再开一个新题，我看了 H 还是图论，但是看着好像没那么难（还是太年轻了）于是就开始看起了 H 题，他们俩觉得  C 题有点不可写之后，就决定开一道新的题出来。发现 I 是一个暴力的题目，我看了看题，感觉不可写，复杂度太大了。但是他们说省赛的复杂度不用管，全是玄学复杂度。争执了一会后，我就说让他们试试吧。反正现在也开不出来其他的题目了。于是我又看起了我的 H 题。</p><p>我在纸上算了一会后，发现还是有点复杂，情况太多了。想着既然没开出来，说不定就是因为太复杂了呢。然后就继续疯狂的枚举那么多的情况，最多的时候直接开了 7 8 个数组存变量，正在我怀疑人生的时候，他们开始了调试   I 题，我想着放松会大脑，就看着他们调试，也看看是不是有设么bug，过了一会，他们调试完了，随便测试了一下样例，输入样例，过了快一秒，答案才出来，我们直接被吓了一下，但是想着省赛都是玄学复杂度，就叫一下试试吧。提交，看着他那个圈圈一直在转，我觉得肯定要凉了，又过了好久，评测机返回了 AC ，欢呼了一下。看了一下榜单，排名第5，还是有点靠后，想着必须再做一题才能保证前三名吧。</p><p>此时还剩了两个小时。榜单上 C 和 H 都有人做了出来，我继续算我的 H ,他们看起了 C。我刚才看了一会 H 了，想着思路应该差不多了，就直接上机开始敲代码，但是敲到一半，发现越敲越难敲，思路好像越来越不对了， 手放在键盘上，但是就是不知道应该写些什么。他们为我写的咋样了，我说应该差不多了，然后他们继续看 C ，我继续写代码，最后是在写不下去了，我说你们来写写试试吧。</p><p>dicer开始敲代码，我把我的思路给他们说了一下。由于他们没怎么看这个题，这个题并没有看得太明白，所以对我的思路也没办法找反例。我就在旁边说我的思路，dicer在敲代码，实现我的每一步功能，敲了好久，他们问我是不是写完了，我想了一下，应该是没啥问题了，于是测样例，果然没过。看代码，发现少了两步功能，加上后，再继续测，样例过了。然后就直接交，不出所料，果然是 WA 了。由于现在只剩这一个可写题了，我们就集中精力做这个题，他们让我把思路再发给他们说一下，我说了之后，codancer问我如果第一个是父节点怎么办，我想了一下……悲伤！果然是个假算法！然后陷入了疯狂的自闭……算法是错的，只能推倒重来。</p><p>他们因为时间复杂度一直没写 C 题，但是现在已经没办法了，他们就决定试一下，我就在旁边一会看他们敲代码，一会想着如何解决 H 题，最后二十分钟左右，我又想出了一个算法，实现简单，而且还没啥大问题。他们看起来也打算放弃 C 题了，我就说让我在挣扎一下，他们同意了，于是他们在旁边看我敲起了代码，一直敲了十几分钟，最后几分钟，代码算是敲完了，测样例，没过…检查了一下，发现我手残把两个输出设置的一样。被嘲讽了一波后过了样例，此时还有三分钟，提交，焦急的的等待着评判结果，WA……，还有两分钟，再看了一下代码，有一个地方忘记写了，加上后，测样例，提交，又WA……此时剩下了最后一分钟，机房里面有人已经开始收拾起了行李，我还在看我的代码，但是最后还是没检查出来，不得不失落地走了。</p><p>赛后看群消息，发现金奖和一A有500奖金，然后又小激动了一下，继而又后悔起了差四分钟 1A 的 H 题，太亏了。</p><p>之前教练和我们说的是比赛完直接走，但是我们想参加颁奖典礼，于是和带队老师说了一下，老师也同意了。颁奖典礼现场，赞助方现场发现金！！！简直不要太阔气。拿了500，也算是有点收获。最后第九名，没达到预期的排名，心有不甘，接下来还有一场ICPC省赛，希望接下来一场比赛能好好打，争取不丢学长的脸。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;希望下回有个好成绩。&lt;/p&gt;
    
    </summary>
    
      <category term="游记" scheme="https://boctorio.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="游记" scheme="https://boctorio.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Boctorio&#39;s Blog</title>
  
  <subtitle>欢迎访问我校OJ   https://www.hpuoj.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://boctorio.github.io/"/>
  <updated>2019-05-20T01:58:02.760Z</updated>
  <id>https://boctorio.github.io/</id>
  
  <author>
    <name>Boctorio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈梯度下降</title>
    <link href="https://boctorio.github.io/2019/05/18/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <id>https://boctorio.github.io/2019/05/18/梯度下降/</id>
    <published>2019-05-18T08:52:00.000Z</published>
    <updated>2019-05-20T01:58:02.760Z</updated>
    
    <content type="html"><![CDATA[<p>梯度下降是迭代法的一种,可以用于求解最小二乘问题(线性和非线性都可以)。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。反过来，如果我们需要求解损失函数的最大值，这时就需要用梯度上升法来迭代了。在机器学习中，基于基本的梯度下降法发展了两种梯度下降方法，分别为随机梯度下降法和批量梯度下降法。</p><a id="more"></a><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>梯度下降法是使用迭代的方法求解曲线的近似函数。</p><p>梯度下降主要的步骤为：</p><blockquote><ol><li><p>猜想近似函数 $h(x)$</p></li><li><p>计算出损失函数 $J(θ)= \frac{1}{2}*( h(x) - y )^2$,其中 $y$ 为 $θ$ 对应的实际值。</p></li><li>迭代求解。</li></ol></blockquote><h4 id="猜想近似函数"><a href="#猜想近似函数" class="headerlink" title="猜想近似函数"></a>猜想近似函数</h4><p>梯度下降的第一步就是猜想近似函数，猜想出来后才能根据这个函数进行函数求解。一般是根据实际值在图像中所形成的图形进行猜想。</p><h4 id="计算损失函数"><a href="#计算损失函数" class="headerlink" title="计算损失函数"></a>计算损失函数</h4><p>实际值和近似函数计算出来的值会有一些差异，梯度下降就是尽量减少这个差异。因此我们需要计算损失函数，使得损失函数尽可能的接近0.</p><p>前两步是准备工作。</p><h4 id="迭代求解"><a href="#迭代求解" class="headerlink" title="迭代求解"></a>迭代求解</h4><p>在我们计算出损失函数后，我们需要对其函数系数值进行修正。梯度下降是按照函数在<strong>某一点的导数</strong>进行修正，当迭代的次数足够多时，系数值趋于稳定时，我们就可以认为近似的求出来了曲线的近似函数。</p><h3 id="单变量线性回归问题"><a href="#单变量线性回归问题" class="headerlink" title="单变量线性回归问题"></a>单变量线性回归问题</h3><p>房屋价格与面积（数据在下面表格中）</p><table><thead><tr><th><strong>序号</strong></th><th><strong>面积</strong></th><th><strong>价格</strong></th></tr></thead><tbody><tr><td>1</td><td>150</td><td>6450</td></tr><tr><td>2</td><td>200</td><td>7450</td></tr><tr><td>3</td><td>250</td><td>8450</td></tr><tr><td>4</td><td>300</td><td>9450</td></tr><tr><td>5</td><td>350</td><td>11450</td></tr><tr><td>6</td><td>400</td><td>15450</td></tr><tr><td>7</td><td>600</td><td>18450</td></tr></tbody></table><p>使用梯度下降求解线性回归（求 $θ_0 ,  θ_1$ ）:</p><p>$$<br>h_{θ(x)}=θ_0+θ_1*x<br>$$</p><p>首先我们要写出损失函数：<br>$$<br>J(θ)=\frac{1}{2m}\sum_{i=1}^{m}{(h_θ(x^{(i)}）-y^{(i)})^2}<br>$$<br>其中 $x^{(i)} ，y^{(i)}$ 分别表示房屋面积和价格的值。$\frac{1}{2}$ 方便函数化简，不影响最终结果。$\frac{1}{m}$ 中 $m$ 表示数据集中元素个数，本题 $m=7$ .</p><p>然后我们求解导函数：</p><p>$$<br>\nabla J_{θ0} =\frac{1}{m}\sum_{i=1}^{m}{(h_{θ_1}(x^{(i)})-y^{(i)})}*θ_1<br>$$</p><p>$$<br>\nabla {J_{θ1}}= \frac{1}{m} \sum_{i=1}^{m}{(h_{θ_1}(x^{(i)})-y^{(i)})}*θ_1<br>$$</p><p>上面两式是对 $θ_1,θ_2$ 求偏导所得到的函数。然后我们根据两个函数的函数值进行迭代求解即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置数据集</span></span><br><span class="line">m=<span class="number">7</span></span><br><span class="line">alpha=<span class="number">0.000000001</span><span class="comment">#步长，即每次迭代距离</span></span><br><span class="line">area=[<span class="number">150</span>,<span class="number">200</span>,<span class="number">250</span>,<span class="number">300</span>,<span class="number">350</span>,<span class="number">400</span>,<span class="number">600</span>]</span><br><span class="line">price=[<span class="number">6450</span>,<span class="number">7450</span>,<span class="number">8450</span>,<span class="number">9450</span>,<span class="number">11450</span>,<span class="number">15450</span>,<span class="number">18450</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始值，可在合理范围内任意选，迭代次数足够多后对结果没有太大影响，建议选在数据集中的值</span></span><br><span class="line">Theta0=<span class="number">150</span></span><br><span class="line">Theta1=<span class="number">6450</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#求Theta0的偏导，即斜率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_theta0</span><span class="params">(Theta0,Theta1)</span>:</span></span><br><span class="line">    ans=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,m):</span><br><span class="line">        ans=ans+(Theta0+Theta1*area[i]-price[i])</span><br><span class="line">    <span class="keyword">return</span> ans/m</span><br><span class="line"></span><br><span class="line"><span class="comment">#求Theta1的偏导，即斜率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_Theta1</span><span class="params">(Theta0,Theta1)</span>:</span></span><br><span class="line">    ans=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,m):</span><br><span class="line">        ans=ans+(Theta0+Theta1*area[i]-price[i])*area[i]</span><br><span class="line">    <span class="keyword">return</span> ans/m;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nxt_Theta0,nxt_Theta1分别表示当前的Theta0,Theta1下一步的位置</span></span><br><span class="line"><span class="comment">#alpha * get_theta() 步长*斜率=函数值变化的多少</span></span><br><span class="line">nxt_Theta0 = Theta0 - alpha * get_theta0(Theta0,Theta1)</span><br><span class="line">nxt_Theta1 = Theta1 - alpha * get_Theta1(Theta0,Theta1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果当前位置到下一个位置函数值差距小于给定值，则退出迭代</span></span><br><span class="line"><span class="keyword">while</span> fabs(Theta1-nxt_Theta1)&gt;=<span class="number">0.000000001</span> :</span><br><span class="line">    Theta0 = nxt_Theta0</span><br><span class="line">    Theta1 = nxt_Theta1</span><br><span class="line">    a = Theta0 - alpha * get_theta0(nxt_Theta0,nxt_Theta1)</span><br><span class="line">    b = Theta1 - alpha * get_Theta1(nxt_Theta0,nxt_Theta1)</span><br><span class="line">    nxt_Theta0 = a</span><br><span class="line">    nxt_Theta1 = b</span><br><span class="line">print(Theta0,Theta1)</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">133.20781607232527 33.07613925785978</span><br></pre></td></tr></table></figure><p>接下来画图验证结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">area=[<span class="number">150</span>,<span class="number">200</span>,<span class="number">250</span>,<span class="number">300</span>,<span class="number">350</span>,<span class="number">400</span>,<span class="number">600</span>]</span><br><span class="line">price=[<span class="number">6450</span>,<span class="number">7450</span>,<span class="number">8450</span>,<span class="number">9450</span>,<span class="number">11450</span>,<span class="number">15450</span>,<span class="number">18450</span>]</span><br><span class="line"></span><br><span class="line">scatter(area,price) <span class="comment">#画出点阵图</span></span><br><span class="line"></span><br><span class="line">x=arange(<span class="number">100</span>,<span class="number">700</span>,<span class="number">100</span>) <span class="comment">#设置范围和步长</span></span><br><span class="line">y=<span class="number">133.20781607232527</span> + <span class="number">33.07613925785978</span> * x</span><br><span class="line"></span><br><span class="line">plot(x,y)</span><br><span class="line">xlabel(<span class="string">'area'</span>)</span><br><span class="line">ylabel(<span class="string">'price'</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>图像为：</p><p><img src="/2019/05/18/梯度下降/图像.png" alt=""></p><p>结果与实际情况与和很好，可认为求出近似函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;梯度下降是迭代法的一种,可以用于求解最小二乘问题(线性和非线性都可以)。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。反过来，如果我们需要求解损失函数的最大值，这时就需要用梯度上升法来迭代了。在机器学习中，基于基本的梯度下降法发展了两种梯度下降方法，分别为随机梯度下降法和批量梯度下降法。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="https://boctorio.github.io/categories/AI/"/>
    
    
      <category term="梯度下降" scheme="https://boctorio.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>二分图匹配</title>
    <link href="https://boctorio.github.io/2019/05/16/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    <id>https://boctorio.github.io/2019/05/16/二分图匹配/</id>
    <published>2019-05-16T13:55:05.000Z</published>
    <updated>2019-05-19T00:09:16.410Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。（源于百度百科）</p><a id="more"></a><p>通俗来讲，有一堆人（图中的点），每个人都有一定的人际关系（图中的边），你需要使他们和他们的朋友两两组队，每个人只能在一个队伍。这就是二分图匹配。</p><blockquote><p>极大匹配(Maximal Matching)是指在<strong>当前已完成的匹配下</strong>,无法再通过增加未完成匹配的边的方式来增加匹配的边数。</p><p>最大匹配(maximum matching)是所有极大匹配当中<strong>边数最大</strong>的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。</p></blockquote><p>一般问题都是求解二分图最大匹配问题。求解最大匹配最常用的算法为匈牙利算法。</p><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><p><a href="https://blog.csdn.net/sunny_hun/article/details/80627351" target="_blank" rel="noopener">匈牙利算法</a></p><p>这是网上最好的一篇关于匈牙利算法的文章，我不能写的比他更好了。</p><p>匈牙利算法代码量并不多，记忆起来也不复杂，在做题时遇到最主要的问题就是建图。如何将问题转化成简单的二分图匹配问题，是最需要解决的。</p><h4 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h4><p>接下来直接看一个比较复杂的二分图问题：</p><p><a href="http://poj.org/problem?id=3020" target="_blank" rel="noopener">poj3020</a></p><p>这个题大致意思就是一个天线可以覆盖本身以及相邻四个方向其中一个，问最少需要多少个天线才能覆盖所有点。</p><p><a href="https://blog.csdn.net/qq_36172505/article/details/81568552" target="_blank" rel="noopener">建图思路</a>（懒得码字了→_→）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。（源于百度百科）&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://boctorio.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Tarjan算法</title>
    <link href="https://boctorio.github.io/2019/05/12/Tarjan%E7%AE%97%E6%B3%95/"/>
    <id>https://boctorio.github.io/2019/05/12/Tarjan算法/</id>
    <published>2019-05-12T06:59:33.000Z</published>
    <updated>2019-05-12T08:19:26.830Z</updated>
    
    <content type="html"><![CDATA[<p>Tarjan算法是用来求强连通的一种算法。在学习算法之前，我们需要了解强连通的概念。</p><a id="more"></a><blockquote><p><strong>强联通</strong>：</p><p>​    在一张有向图中，对于任意两个点v1,v2,存在从v1-&gt;v2 和v2-&gt;v1 的路径，则称这张图为强连通图。</p><p><strong>强联通子图</strong>：</p><p>​    在一张有向图中，存在一张子图是强连通图，则称这个子图为强连通子图，其极大强连通子图称之为<strong>强连通分量</strong>。</p></blockquote><p>Tarjan的作用就是求强连通分量。</p><p>在遍历之前，我们需要建立一个栈来统计当前未被处理的节点。</p><p>对于下图：</p><p><img src="/2019/05/12/Tarjan算法/1.png" alt=""></p><p>我们从节点1开始dfs遍历，其中DFN表示遍历的编号，LOW表示连通块中最小的遍历的编号：</p><p>（此时栈中元素为：1 2 3 6）</p><p><img src="/2019/05/12/Tarjan算法/2.png" alt=""></p><p>遍历到节点6后，开始回溯，此时判断DFN是否等于LOW，如果相等，那么这是强连通分量上的一个点：</p><p>（此时栈中元素为：1 2 3）</p><p><img src="/2019/05/12/Tarjan算法/3.png" alt=""></p><p>回溯到节点3时，没有其他路可走，那么就判断DFN是否等于LOW，同时更新LOW[ 3 ]的值：</p><p>（此时栈中元素为：1 2）</p><p><img src="/2019/05/12/Tarjan算法/4.png" alt=""></p><p>接下来从节点2向下遍历：</p><p>（此时栈中元素为：1 2 5）</p><p><img src="/2019/05/12/Tarjan算法/5.png" alt=""></p><p>由于5 -&gt; 1 中节点1已经访问过了，那么此时我们更新LOW[ 5 ] = LOW[ 1 ] = 1,然后回溯更新LOW[2]=LOW[ 1 ]：</p><p>（此时栈中元素为：1 2 5）</p><p><img src="/2019/05/12/Tarjan算法/6.png" alt=""></p><p>回溯到节点1，向下搜节点4，节点5被访问过，回溯LOW[ 4 ]=LOW[ 5 ] = 1 ：</p><p>（此时栈中元素：1 2 5 4）</p><p><img src="/2019/05/12/Tarjan算法/7.png" alt=""></p><p>继续回溯到节点1，此时节点1相邻边已被访问完毕，判断DFN是否等于LOW，相等就开始标记强连通分量。将栈中元素LOW相等的全部连通。</p><p>完毕。</p><p>模板为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,tt,cnt,sig;</span><br><span class="line"><span class="keyword">int</span> vis[maxn],low[maxn],dfn[maxn];</span><br><span class="line"><span class="keyword">int</span> color[maxn];<span class="comment">//color[]为染色，即强连通中的元素染成同一种颜色。</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line"><span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line"><span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vec[i].clear();</span><br><span class="line"><span class="keyword">while</span>(!st.empty()) st.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line">dfn[x]=low[x]=cnt++;</span><br><span class="line">st.push(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec[x].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> y=vec[x][i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]==<span class="number">0</span>) tarjan(y);<span class="comment">//未被访问过，向下遍历</span></span><br><span class="line"><span class="keyword">if</span>(vis[y]==<span class="number">1</span>) low[x]=min(low[x],low[y]);<span class="comment">//更新LOW下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">sig++;<span class="comment">//染色序号</span></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;<span class="comment">//将栈中x及其以后的节点全部标记为同一种颜色（sig）</span></span><br><span class="line"><span class="keyword">int</span> t=st.top(); st.pop();</span><br><span class="line"><span class="keyword">if</span>(t==x) flag=<span class="number">1</span>;</span><br><span class="line">color[t]=sig;</span><br><span class="line">vis[t]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">tt=<span class="number">-1</span>;cnt=<span class="number">1</span>;sig=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]==<span class="number">0</span>) tarjan(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此处添加其他操作 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tarjan算法是用来求强连通的一种算法。在学习算法之前，我们需要了解强连通的概念。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最短编辑距离</title>
    <link href="https://boctorio.github.io/2019/05/09/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>https://boctorio.github.io/2019/05/09/最短编辑距离/</id>
    <published>2019-05-09T11:59:20.000Z</published>
    <updated>2019-05-09T13:32:23.150Z</updated>
    
    <content type="html"><![CDATA[<p>编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。</p><a id="more"></a><p>例如两个字符串 “main” 和 “mian”，从前一个字符串变成后一个串，需要先删除一个字符 ‘ a ’ ,然后再在字符 ‘ i ‘ 后面加一个 ‘ a ‘ ,那么他们的最短编辑距离就为2。</p><p>求解这类问题的方法一般为动态规划。</p><h4 id="不加权最短编辑距离"><a href="#不加权最短编辑距离" class="headerlink" title="不加权最短编辑距离"></a>不加权最短编辑距离</h4><p>这是最基本的裸题，只求字符串操作次数。</p><p>假设当前第一个串位置为 i ,第二个串位置为 j ，dp[ i ][ j ] 表示最短编辑距离。</p><p>我们看一下三种操作：<strong>替换，插入，删除</strong></p><blockquote><p><strong>替换</strong>：</p><p>​    如果仅仅是替换，假设我们已经求出来了 dp[ i - 1 ][ j - 1 ] , 那么从dp[ i - 1 ][ j - 1 ] 到  dp[ i ][ j ]  $只操作了一次，即 dp[ i ][ j ] = dp[ i - 1 ][ j - 1 ] +1  。</p><p><strong>插入</strong>：</p><p>​    如果插入后串的长度分别为 i , j ,那么当前状态可以是从 i - 1 , j 的情况下第一个串插入一个字符得到的，因此 dp[ i ][ j ]= dp[ i - 1 ][ j ] + 1  ；  </p><p><strong>删除</strong>：</p><p>​    删除同上，当前状态可以是从 i , j - 1 的情况下删除了一个字符得到的，因此dp[ i ][ j ]= dp[ i ][ j - 1 ] + 1  ；  </p></blockquote><p>这就是三种状态分别对应的状态方程，特殊的，当 i = 0 或 j = 0 时，最短编辑距离就是当前两个串的差值，即另一个变量对应的值。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串数组下标从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化i=0或j=0的情况。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++) dp[<span class="number">0</span>][j]=j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//四种状态 按顺序为：删除，插入，字符匹配（不需要编辑），替换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">    dp[i][j]=min(min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(a[i]==b[j]?<span class="number">0</span>:<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加权最短编辑距离"><a href="#加权最短编辑距离" class="headerlink" title="加权最短编辑距离"></a>加权最短编辑距离</h4><p>省赛原题：</p><blockquote><p>多组输入</p><p>第一行输入四个数 a,b,c,d,表示字符匹配加 a 分，替换减b分，插入减c分，删除减d分。</p><p>接下来两行，每行一个字符串。</p><p>输出最大得分。</p></blockquote><p>这个题其实也算是编辑距离的裸题，当时状态方程写了出来，但是不知道为什么wa了（可能还是不熟悉）。</p><p>加权的转移方程其实和不加权的差不多，只是在转移方程的加减上做了一点变化。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于对应的权值不同，初始化的值也不同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=-i*d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++) dp[<span class="number">0</span>][j]=-j*c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">dp[i][j]=max(max(dp[i<span class="number">-1</span>][j]-c,dp[i][j<span class="number">-1</span>]-d),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(s1[i]==s2[j]?a:-b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="https://boctorio.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>模板库（持续更新）</title>
    <link href="https://boctorio.github.io/2019/05/05/%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://boctorio.github.io/2019/05/05/模板库（持续更新）/</id>
    <published>2019-05-05T04:43:33.000Z</published>
    <updated>2019-06-03T07:38:20.614Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下我学过的部分算法模板。</p><a id="more"></a><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x==pre[x]?x:pre[x]=find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">x=find(x);</span><br><span class="line">y=find(y);</span><br><span class="line"><span class="keyword">if</span>(x&lt;y) pre[y]=x;</span><br><span class="line"><span class="keyword">else</span> pre[x]=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> y?gcd(y,x%y):x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void get_nxt()&#123;</span><br><span class="line">int i=1,next[1]=0,j=0;</span><br><span class="line">int len=strlen(str);</span><br><span class="line">while(i&lt;len)&#123;</span><br><span class="line">if(j==0 || str[i]==str[j])&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">j=next[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tt,cnt,sig;</span><br><span class="line"><span class="keyword">int</span> vis[maxn],low[maxn],dfn[maxn];</span><br><span class="line"><span class="keyword">int</span> color[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line"><span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line"><span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vec[i].clear();</span><br><span class="line"><span class="keyword">while</span>(!st.empty()) st.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line">dfn[x]=low[x]=cnt++;</span><br><span class="line">st.push(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec[x].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> y=vec[x][i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]==<span class="number">0</span>) tarjan(y);</span><br><span class="line"><span class="keyword">if</span>(vis[y]==<span class="number">1</span>) low[x]=min(low[x],low[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">sig++;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line"><span class="keyword">int</span> t=st.top(); st.pop();</span><br><span class="line"><span class="keyword">if</span>(t==x) flag=<span class="number">1</span>;</span><br><span class="line">color[t]=sig;</span><br><span class="line">vis[t]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">tt=<span class="number">-1</span>;cnt=<span class="number">1</span>;sig=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]==<span class="number">0</span>) tarjan(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此处添加其他操作 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line">&#125;p[maxn],q[maxn];</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line"><span class="function">node <span class="title">getmag</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">node s;</span><br><span class="line">s.x=b.x-a.x;</span><br><span class="line">s.y=b.y-a.y;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiX</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> multiX(getmag(p[<span class="number">1</span>],a),getmag(p[<span class="number">1</span>],b))&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graham</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123; </span><br><span class="line"><span class="keyword">if</span>(p[i].x&lt;p[id].x || (p[i].x==p[id].x &amp;&amp; p[i].y&lt;p[id].y)) id=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(id!=<span class="number">1</span>) swap(p[id],p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">sort(p+<span class="number">2</span>,p+n+<span class="number">1</span>,cmp); </span><br><span class="line">q[++l]=p[<span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l&gt;=<span class="number">2</span> &amp;&amp; multiX(getmag(q[l<span class="number">-1</span>],p[i]),getmag(q[l<span class="number">-1</span>],q[l]))&gt;=<span class="number">0</span>) l--;</span><br><span class="line">q[++l]=p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="线段树单点更新-查询区间最大值"><a href="#线段树单点更新-查询区间最大值" class="headerlink" title="线段树单点更新+查询区间最大值"></a>线段树单点更新+查询区间最大值</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="noopener">HDU1754</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> dat[maxn],n;</span><br><span class="line"><span class="keyword">int</span> m,a,b;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&lt;x) n*=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">dat[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">k+=n<span class="number">-1</span>;</span><br><span class="line">dat[k]=a;</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">k=(k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">dat[k]=max(dat[k*<span class="number">2</span>+<span class="number">1</span>],dat[k*<span class="number">2</span>+<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r&lt;a || b&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) <span class="keyword">return</span> dat[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> vl=query(a,b,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> vr=query(a,b,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">return</span> max(vl,vr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n_;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">n_=n;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n_;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dat[i+n<span class="number">-1</span>]);</span><br><span class="line">update(i,dat[i+n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c %d %d"</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(a<span class="number">-1</span>,b<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'U'</span>) update(a<span class="number">-1</span>,b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树区间更新"><a href="#线段树区间更新" class="headerlink" title="线段树区间更新"></a>线段树区间更新</h4><p><a href="http://acm.fzu.edu.cn/problem.php?pid=1608" target="_blank" rel="noopener">FZU1608</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,dat[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&lt;x) n*=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">dat[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&lt;l || r&lt;a) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) dat[k]=max(x,dat[k]);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> mmax)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> max(mmax,dat[k]);</span><br><span class="line">dat[k]=max(mmax,dat[k]);</span><br><span class="line"><span class="keyword">int</span> vl=query(l,(l+r)/<span class="number">2</span>,k*<span class="number">2</span>+<span class="number">1</span>,dat[k]);</span><br><span class="line"><span class="keyword">int</span> vr=query((l+r)/<span class="number">2</span>+<span class="number">1</span>,r,k*<span class="number">2</span>+<span class="number">2</span>,dat[k]);</span><br><span class="line"><span class="keyword">return</span> vl+vr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,x;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;x);</span><br><span class="line">update(a,b<span class="number">-1</span>,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树区间更新-区间求和"><a href="#线段树区间更新-区间求和" class="headerlink" title="线段树区间更新+区间求和"></a>线段树区间更新+区间求和</h4><p><a href="http://poj.org/problem?id=3468" target="_blank" rel="noopener">POJ3468</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll maxn=<span class="number">1000000</span>;</span><br><span class="line">ll dat[maxn],sum[maxn],n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll a,ll b,ll x,ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b)&#123;</span><br><span class="line">dat[k]+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l&lt;=b &amp;&amp; a&lt;=r)&#123;</span><br><span class="line">sum[k]+=(min(b,r)-max(a,l)+<span class="number">1</span>)*x;</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll a,ll b,ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&lt;l || r&lt;a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) <span class="keyword">return</span> dat[k]*(r-l+<span class="number">1</span>)+sum[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ll res=(min(b,r)-max(a,l)+<span class="number">1</span>)*dat[k];</span><br><span class="line">res+=query(a,b,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">res+=query(a,b,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll a,b,x;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">update(i,i,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'Q'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(a<span class="number">-1</span>,b<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;a,&amp;b,&amp;x);</span><br><span class="line">update(a<span class="number">-1</span>,b<span class="number">-1</span>,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h3><h4 id="静态主席树"><a href="#静态主席树" class="headerlink" title="静态主席树"></a>静态主席树</h4><p>//查询区间第k小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> rt[maxn],ls[maxn*<span class="number">2</span>],rs[maxn*<span class="number">2</span>],sum[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> tot,N,n,q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">o=++tot;</span><br><span class="line">sum[o]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">build(ls[o],l,m);</span><br><span class="line">build(rs[o],m+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> last,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">o=++tot;</span><br><span class="line">ls[o]=ls[last];</span><br><span class="line">rs[o]=rs[last];</span><br><span class="line">sum[o]=sum[last]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=m) update(ls[o],l,m,ls[last],k);</span><br><span class="line"><span class="keyword">else</span> update(rs[o],m+<span class="number">1</span>,r,rs[last],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">int</span> cnt=sum[ls[e]]-sum[ls[s]];</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=cnt) <span class="keyword">return</span> query(ls[s],ls[e],l,m,k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(rs[s],rs[e],m+<span class="number">1</span>,r,k-cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> l,r,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">b[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line">sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">N=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-(b+<span class="number">1</span>);</span><br><span class="line">build(rt[<span class="number">0</span>],<span class="number">1</span>,N);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) update(rt[i],<span class="number">1</span>,N,rt[i<span class="number">-1</span>],lower_bound(b+<span class="number">1</span>,b+N+<span class="number">1</span>,a[i])-b);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line"><span class="keyword">int</span> ans=query(rt[l<span class="number">-1</span>],rt[r],<span class="number">1</span>,N,k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[ans]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态主席树"><a href="#动态主席树" class="headerlink" title="动态主席树"></a>动态主席树</h4><p>//修改单点+查询区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">60000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],hash[maxn];</span><br><span class="line"><span class="keyword">int</span> rt[maxn],RT[maxn],ls[maxn*<span class="number">32</span>],rs[maxn*<span class="number">32</span>],sum[maxn*<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> ul[maxn],ur[maxn]; </span><br><span class="line"><span class="keyword">int</span> tot,n,q,N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,k;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">&#125;op[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123; </span><br><span class="line">o=++tot;</span><br><span class="line">sum[o]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">build(ls[o],l,m);</span><br><span class="line">build(rs[o],m+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> last,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123; </span><br><span class="line">o=++tot;</span><br><span class="line">ls[o]=ls[last];</span><br><span class="line">rs[o]=rs[last];</span><br><span class="line">sum[o]=sum[last]+val;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(p&lt;=m) update(ls[o],l,m,ls[last],p,val);</span><br><span class="line"><span class="keyword">else</span> update(rs[o],m+<span class="number">1</span>,r,rs[last],p,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=lower_bound(hash+<span class="number">1</span>,hash+N+<span class="number">1</span>,a[x])-hash;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)&#123; </span><br><span class="line">update(RT[x],<span class="number">1</span>,N,RT[x],res,val);</span><br><span class="line">x+=lowbit(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) res+=sum[ls[ur[x]]];</span><br><span class="line"><span class="keyword">else</span> res+=sum[ls[ul[x]]];</span><br><span class="line">x-=lowbit(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> ts,<span class="keyword">int</span> te,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=Sum(e,<span class="literal">true</span>)-Sum(s,<span class="literal">false</span>)+sum[ls[te]]-sum[ls[ts]];</span><br><span class="line"><span class="keyword">if</span>(k&lt;=cnt)&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=e;i;i-=lowbit(i)) ur[i]=ls[ur[i]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s;i;i-=lowbit(i)) ul[i]=ls[ul[i]];</span><br><span class="line"><span class="keyword">return</span> query(s,e,ls[ts],ls[te],l,m,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=e;i;i-=lowbit(i)) ur[i]=rs[ur[i]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s;i;i-=lowbit(i)) ul[i]=rs[ul[i]];</span><br><span class="line"><span class="keyword">return</span> query(s,e,rs[ts],rs[te],m+<span class="number">1</span>,r,k-cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">hash[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">2</span>];</span><br><span class="line">N=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;op[i].l,&amp;op[i].r,&amp;op[i].k);</span><br><span class="line">op[i].flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;op[i].r,&amp;op[i].k);</span><br><span class="line">op[i].flag=<span class="literal">false</span>;</span><br><span class="line">hash[++N]=op[i].k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(hash+<span class="number">1</span>,hash+N+<span class="number">1</span>);</span><br><span class="line">N=unique(hash+<span class="number">1</span>,hash+N+<span class="number">1</span>)-(hash+<span class="number">1</span>);</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line">build(rt[<span class="number">0</span>],<span class="number">1</span>,N);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) update(rt[i],<span class="number">1</span>,N,rt[i<span class="number">-1</span>],lower_bound(hash+<span class="number">1</span>,hash+N+<span class="number">1</span>,a[i])-hash,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) RT[i]=rt[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> l=op[i].l,r=op[i].r,k=op[i].k;</span><br><span class="line"><span class="keyword">if</span>(op[i].flag)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=r;j;j-=lowbit(j)) ur[j]=RT[j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=l<span class="number">-1</span>;j;j-=lowbit(j)) ul[j]=RT[j];</span><br><span class="line">                <span class="keyword">int</span> res=query(l<span class="number">-1</span>,r,rt[l<span class="number">-1</span>],rt[r],<span class="number">1</span>,N,k);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hash[res]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                add(r,<span class="number">-1</span>);</span><br><span class="line">                a[r]=k;</span><br><span class="line">                add(r,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一下我学过的部分算法模板。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>凸包</title>
    <link href="https://boctorio.github.io/2019/04/30/%E5%87%B8%E5%8C%85/"/>
    <id>https://boctorio.github.io/2019/04/30/凸包/</id>
    <published>2019-04-30T11:13:39.000Z</published>
    <updated>2019-05-02T08:45:51.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><blockquote><p>凸包（Convex Hull）是一个计算几何（图形学）中的概念。<br>在一个实数向量空间V中，对于给定集合X，所有包含X的凸集的交集S被称为X的凸包。X的凸包可以用X内所有点(X1，…Xn)的凸组合来构造.<br>在二维欧几里得空间中，凸包可想象为一条刚好包著所有点的橡皮圈。<br>用不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边形，它能包含点集中所有的点。（来源于百度百科）</p></blockquote><a id="more"></a><p>凸包是计算几何题目中经常出现的概念，一般形式为给你 $ n ​$ 个点，求这些点所构成的凸包的面积。</p><p><img src="/2019/04/30/凸包/凸包.gif" alt=""></p><p>这张动图是求凸包的过程。</p><p>求凸包的基本顺序为：</p><blockquote><ol><li>找到凸包上的一个点，一般为x坐标最小的点。</li><li>将找到的点设为原点，根据极角排序方式将剩余的点进行排序</li><li>循环找凸包上的点<ol><li>如果当前点比上一个点更可能是凸包上的点，那么就覆盖上一个点，更新为当前点。</li><li>如果当前点没有上一个点适合当凸包上的点，那么就先放进凸包集合中，继续寻找下一个点。</li></ol></li><li>循环结束。</li></ol></blockquote><p>关于当前点是否更有可能是凸包上的点，用下面的几张图来讲解：</p><p><img src="/2019/04/30/凸包/t1.png" alt=""></p><p>当前凸包内有三个点v0,v1,v2，接下来判断v3的时候，我们需要对它进行判断：</p><p><img src="/2019/04/30/凸包/t2.png" alt=""></p><p>$v1$ 与 $v2,v3$ 相连，判断两条线的夹角的方向，如果是逆时针方向，那么就可以放入凸包集合中:</p><p><img src="/2019/04/30/凸包/t3.png" alt=""></p><p>接下来同样的办法判断v4:</p><p><img src="/2019/04/30/凸包/t4.png" alt=""></p><p>如果是顺时针方向，那么 $v4$ 就优于 $v3$ ，我们删去 $v3$ ，接下来继续判断：</p><p><img src="/2019/04/30/凸包/t6.png" alt=""></p><p>逆时针，所以可以放入图包集合：</p><p><img src="/2019/04/30/凸包/t5.png" alt=""></p><p>之后一直重复这个过程即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line">&#125;p[maxn],q[maxn];</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line"><span class="function">node <span class="title">getmag</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//计算边 表示从a-&gt;b的向量 </span></span><br><span class="line">node s;</span><br><span class="line">s.x=b.x-a.x;</span><br><span class="line">s.y=b.y-a.y;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiX</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//叉乘的正负代表两条直线夹角的顺逆 </span></span><br><span class="line"><span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//根据极角排序</span></span><br><span class="line"><span class="keyword">return</span> multiX(getmag(p[<span class="number">1</span>],a),getmag(p[<span class="number">1</span>],b))&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graham</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="comment">//找出最开始的一个点 </span></span><br><span class="line"><span class="keyword">if</span>(p[i].x&lt;p[id].x || (p[i].x==p[id].x &amp;&amp; p[i].y&lt;p[id].y)) id=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(id!=<span class="number">1</span>) swap(p[id],p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">sort(p+<span class="number">2</span>,p+n+<span class="number">1</span>,cmp);<span class="comment">//极角排序 </span></span><br><span class="line">q[++l]=p[<span class="number">1</span>];<span class="comment">//p: 所有点集合  q: 凸包点集合 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="comment">//如果夹角是顺时针方向，那么就可以取代 </span></span><br><span class="line"><span class="keyword">while</span>(l&gt;=<span class="number">2</span> &amp;&amp; multiX(getmag(q[l<span class="number">-1</span>],p[i]),getmag(q[l<span class="number">-1</span>],q[l]))&gt;=<span class="number">0</span>) l--;</span><br><span class="line">q[++l]=p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;凸包&quot;&gt;&lt;a href=&quot;#凸包&quot; class=&quot;headerlink&quot; title=&quot;凸包&quot;&gt;&lt;/a&gt;凸包&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;凸包（Convex Hull）是一个计算几何（图形学）中的概念。&lt;br&gt;在一个实数向量空间V中，对于给定集合X，所有包含X的凸集的交集S被称为X的凸包。X的凸包可以用X内所有点(X1，…Xn)的凸组合来构造.&lt;br&gt;在二维欧几里得空间中，凸包可想象为一条刚好包著所有点的橡皮圈。&lt;br&gt;用不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边形，它能包含点集中所有的点。（来源于百度百科）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="凸包" scheme="https://boctorio.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="https://boctorio.github.io/2019/04/16/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>https://boctorio.github.io/2019/04/16/树状数组/</id>
    <published>2019-04-16T03:21:17.000Z</published>
    <updated>2019-04-17T12:54:31.758Z</updated>
    
    <content type="html"><![CDATA[<p>树状数组在数据结构上和线段树类似，功能上均用来求解区间的修改，查询，计数等问题。</p><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>树状数组的突出优点为代码简洁，相比于线段树，其修改、查询函数均非常简短。</p><p>线段树的数据结构为：</p><p><img src="/2019/04/16/树状数组/二叉树.png" alt=""></p><p>将线段树数组的位置进行改变就得到了树状数组：</p><p><img src="/2019/04/16/树状数组/树状数组.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树状数组在数据结构上和线段树类似，功能上均用来求解区间的修改，查询，计数等问题。&lt;/p&gt;
&lt;h3 id=&quot;树状数组&quot;&gt;&lt;a href=&quot;#树状数组&quot; class=&quot;headerlink&quot; title=&quot;树状数组&quot;&gt;&lt;/a&gt;树状数组&lt;/h3&gt;&lt;p&gt;树状数组的突出优点为代码简洁
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nim博弈--简单证明</title>
    <link href="https://boctorio.github.io/2019/04/15/Nim%E5%8D%9A%E5%BC%88-%E7%AE%80%E5%8D%95%E8%AF%81%E6%98%8E/"/>
    <id>https://boctorio.github.io/2019/04/15/Nim博弈-简单证明/</id>
    <published>2019-04-15T09:32:37.000Z</published>
    <updated>2019-04-16T03:10:48.990Z</updated>
    
    <content type="html"><![CDATA[<p>Nim博弈是ACM入门的博弈之一，其基本描述为：</p><blockquote><p>有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。</p><a id="more"></a><p>这游戏看上去有点复杂，先从简单情况开始研究吧。如果轮到你的时候，只剩下一堆石子，那么此时的必胜策略肯定是把这堆石子全部拿完一颗也不给对手剩，然后对手就输了。如果剩下两堆不相等的石子，必胜策略是通过取多的一堆的石子将两堆石子变得相等，以后如果对手在某一堆里拿若干颗，你就可以在另一堆中拿同样多的颗数，直至胜利。如果你面对的是两堆相等的石子，那么此时你是没有任何必胜策略的，反而对手可以遵循上面的策略保证必胜。如果是三堆石子……好像已经很难分析了，看来我们必须要借助一些其它好用的（最好是程式化的）分析方法了，或者说，我们最好能够设计出一种在有必胜策略时就能找到必胜策略的算法。（源自百度百科）</p></blockquote><p>如果有点基础的同学就会知道Nim博弈的判断胜负的办法：</p><blockquote><p>将每堆石子个数异或，如果异或结果非零，则先手必胜，否则先手必败。</p></blockquote><p>我们先对必败局面，即最终异或结果为  $0​$  （假设异或结果为 $A​$）进行分析：</p><p>如果现在第一个人拿任意一堆石子中的 $B​$ 个，那么现在剩余石子的异或结果 $A’​$必定不为  $0​$ ，而且可以看出$A’=B​$。</p><p>接下来是第二个人的操作。在二进制的情况下，$A’$ 的位数和 $B$ 的位数相同（假定为 $n+1$位），<strong>即剩余的所有石子中必定有一堆石子的数量（假定为 $C$ ）不少于 $2^n$ 个，且二进制下第 $n$ 位必定为 1 。假如我们拿出这一堆石子中的 $2 ^ n$ 个，现在剩下的所有石子异或结果 $A’’$ 一定小于  $2 ^ n$ ($A’’$ 第 $n$ 位此时变成了 $0$ )</strong> ，所以我们可以从这 $C$ 个石子中拿走  $2^n-A’’$ 个，剩余 $A’’$ 个，这样，剩余的石子异或的结果一定为 $A’’$ ^ $A’’ $  $=0$ 。这样，第二个人就能在一次操作后将异或的结果变为  $0$ 。</p><p>第二个人持续上述操作，就能够使第一个人当前的异或结果永远为 $0​$ ，第二个人当前的异或结果永远不为 $0​$ ，而最终当取完所有石子时，结果也为  $0​$ 。</p><p>假如初始 $A​$ 不为零，那么第一个人也可通过上述操作使得异或结果为 $0​$ 。</p><p>这样就证明了异或结果可以判断最终胜负的正确性。</p><p>（持续更新……）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nim博弈是ACM入门的博弈之一，其基本描述为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="博弈" scheme="https://boctorio.github.io/categories/%E5%8D%9A%E5%BC%88/"/>
    
    
      <category term="Nim博弈" scheme="https://boctorio.github.io/tags/Nim%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>菜鸡的CCPC河南省赛一日游</title>
    <link href="https://boctorio.github.io/2019/04/13/%E8%8F%9C%E9%B8%A1%E7%9A%84CCPC%E6%B2%B3%E5%8D%97%E7%9C%81%E8%B5%9B%E4%B8%80%E6%97%A5%E6%B8%B8/"/>
    <id>https://boctorio.github.io/2019/04/13/菜鸡的CCPC河南省赛一日游/</id>
    <published>2019-04-13T14:23:26.000Z</published>
    <updated>2019-04-16T03:13:21.076Z</updated>
    
    <content type="html"><![CDATA[<p>希望下回有个好成绩。</p><a id="more"></a><p>公元2019年4月13日。</p><p>清晨一如既往地冷，校园内三三两两的学生在路上悠闲地走着。餐厅内工作人员已经在这个放假的日子早早的起床做饭。</p><p>餐厅中央侧边的两张餐桌旁，坐着我们学校早起的参赛选手们。在体育节放假的这两天，两回训练赛早就冲淡了我们比赛的紧张感。我们坐在这里，吃着饭，聊着即将到来的CCPC省赛。</p><p>餐厅外，象征着青春活力的太阳已经爬上了天空。</p><p>吃完饭后，我们出了餐厅，就朝着东门的方向走去，7:50我们将准时出发去郑州轻工业大学。</p><p>这次比赛学校多了不少新的队员，都是在之前的三次积分赛上选拔出来的优秀选手。其中还包括两只大一的队伍，他们很努力；他们也很幸运，能够在大一就有机会去参加省赛。还有一只留学生的队伍，他们是教练的学生，对算法有着和我们一样的兴趣，但是我们一行人只有会长能够和他们谈笑风生，我这个连四级都没有过的人只能在旁边看着他们聊天。</p><p>这次比赛由于教练有事，所以我们教练又找了一个带队老师。这位老师在我们的校赛方面也提供很大的帮助。很年轻的一位老师，性格也很好，和我们的教练一样好。</p><p>清点完人数，我们就踏上了去打比赛的征途。又是熟悉的大巴，和蓝桥杯、天梯赛的大巴一样，坐满了我们心情忐忑的一行人。去年我们的学长在ICPC省赛中拿到了非常优异的成绩，作为学校大二的顶尖力量（其实也不过如此），我们队的压力–主要是我的压力–也是非常的大，想拿个更好的成绩去向学长们报汇报。学长为了培养我们，牺牲了自己的课余时间，给我们开公开课，开集训，我也不想在这样一个比赛中拿到并不是非常优异的成绩去报答学长们的付出。</p><p>今天的阳光很好。前几天天阴着，刮着冷风，像是又一季的冬天。</p><p>由于学校行程的安排，我们在到达轻大的时候开幕式已经开始了。报完到后，我们又在外面逛了许久，轻大看起来还是那么广阔，在清晨阳光的照射下，图书馆前的广场看起来有了别样的感觉。不久，我们就前往了考场。</p><p>到达机房门口，我们看到了比赛的环境，win10系统，电脑也和上回来的时候不一样了，看来是主办方为了省赛确实花了很大力气。</p><p>由于没有参加开幕式，到达机房时间有点早，我们几个队伍也在机房外面闲谈了起来，免不了的一波毒奶。</p><p>进入机房后，惊奇的发现键盘也换了，上次打天梯赛的键盘是老式的键盘，按起来也非常的费力。这一次的换了一种薄膜键盘，虽然用起来并没有机械键盘那么舒服，但是相比之前的还是好了很多。</p><p>在距比赛开始前几分钟，我和我队友就发现现场好像并没有纸质题面。询问了一下考场的老师，老师也说去问一下。果然没多久，就传来了比赛推迟的消息。十分钟后，又传来了比赛推迟的消息。10:20，比赛正式开始了。</p><p>由于刚开始我们以为会发三个纸质题面，但是发下来之后发现只有一个，有点大乱了我们的阵脚，dicer提议把题面撕成两份，我和codancer一人看半份，dicer看电脑。当我看了第一题我的脑子里只剩下了“？？？？？？？？”，这…应该不是签到题吧。于是我又看了B，这…应该也不是签到题吧。当我在看B的时候，dicer看了一下榜，说 D E 好像是签到题，我看了一下，确实是签到题，然后dicer就迅速的敲起了键盘，两个签到题花了8分钟写完了。</p><p>之后过了好久，没人再开出来其他题了。由于我拿的是前半部分，所以一直在看ABC，差点看自闭了，图论是我的弱项，然而BC全是树形结构，然后我就GG了。签到题写完后，dicer看了 A ，感觉可写，就给codancer说了一下，于是他们就开始全心攻A题，我觉得BC我不可写，就让codancer把另一半题面给了我，我看了 F，发现是个数学题，这就很不错了嘛。刚开始看懂题意，那不就是直接模拟吗，dicer看了题，提醒我说数据范围1e18,然后我又陷入了自闭之中，之后我就开始了漫长的化简之旅。</p><p>在纸上算了一会后，我发现符合条件的区间可以被分为不连续和连续两部分，然后我就开始继续慢慢计算每个小区间怎么处理，然后想了一个极其复杂的处理方法。我正在疯狂想办法化简的时候，dicer 和 codancer 经过激烈的讨论以及盲猜了一发结论WA了之后，看出来 A 是dp，于是把代码全盘来写。我在化简的时候发现可以先计算出小区间的范围，然后根据l r 值进行判断，激动了一下，但是看他们还在写 A ，我就决定先把代码写在纸上，看看能不能行的通，不一会，他们俩就又交了一发 A ，WA了，然后我问 A 题怎么样了，他们说害还得再找找思路有没有问题，我就说让我先敲 F 题吧，然后他们就在旁边讨论找反例来了。</p><p>我根据我的思路，很快写好了 F 题，但是测样例的时候四个就过了一个，我思考起是不是哪里写错了，就看着代码一步步的进行计算，他们在讨论了一阵之后，发现了问题在哪，然后又开始修改他们的代码，我就在旁边看我的思路是不是哪错了，之后没一会，他们又交了一发 A ，过了！然后看榜单，发现排名前几，但是罚时有点多，三题垫底。</p><p>我又开始了我的改bug之旅，他们又在旁边讨论起了 C 题，我对着样例又计算了一遍，才发现区间是左闭右开的，赶紧改bug，测样例，过了！提交，过了！</p><p>我问他们 C 题怎么样了，他们说稍微有点思路，但是复杂度太大，我看了看题，发现复杂度确实有点高。看了一眼榜单，发现开出来的这几个都差不多了，于是想着再开一个新题，我看了 H 还是图论，但是看着好像没那么难（还是太年轻了）于是就开始看起了 H 题，他们俩觉得  C 题有点不可写之后，就决定开一道新的题出来。发现 I 是一个暴力的题目，我看了看题，感觉不可写，复杂度太大了。但是他们说省赛的复杂度不用管，全是玄学复杂度。争执了一会后，我就说让他们试试吧。反正现在也开不出来其他的题目了。于是我又看起了我的 H 题。</p><p>我在纸上算了一会后，发现还是有点复杂，情况太多了。想着既然没开出来，说不定就是因为太复杂了呢。然后就继续疯狂的枚举那么多的情况，最多的时候直接开了 7 8 个数组存变量，正在我怀疑人生的时候，他们开始了调试   I 题，我想着放松会大脑，就看着他们调试，也看看是不是有设么bug，过了一会，他们调试完了，随便测试了一下样例，输入样例，过了快一秒，答案才出来，我们直接被吓了一下，但是想着省赛都是玄学复杂度，就叫一下试试吧。提交，看着他那个圈圈一直在转，我觉得肯定要凉了，又过了好久，评测机返回了 AC ，欢呼了一下。看了一下榜单，排名第5，还是有点靠后，想着必须再做一题才能保证前三名吧。</p><p>此时还剩了两个小时。榜单上 C 和 H 都有人做了出来，我继续算我的 H ,他们看起了 C。我刚才看了一会 H 了，想着思路应该差不多了，就直接上机开始敲代码，但是敲到一半，发现越敲越难敲，思路好像越来越不对了， 手放在键盘上，但是就是不知道应该写些什么。他们为我写的咋样了，我说应该差不多了，然后他们继续看 C ，我继续写代码，最后是在写不下去了，我说你们来写写试试吧。</p><p>dicer开始敲代码，我把我的思路给他们说了一下。由于他们没怎么看这个题，这个题并没有看得太明白，所以对我的思路也没办法找反例。我就在旁边说我的思路，dicer在敲代码，实现我的每一步功能，敲了好久，他们问我是不是写完了，我想了一下，应该是没啥问题了，于是测样例，果然没过。看代码，发现少了两步功能，加上后，再继续测，样例过了。然后就直接交，不出所料，果然是 WA 了。由于现在只剩这一个可写题了，我们就集中精力做这个题，他们让我把思路再发给他们说一下，我说了之后，codancer问我如果第一个是父节点怎么办，我想了一下……悲伤！果然是个假算法！然后陷入了疯狂的自闭……算法是错的，只能推倒重来。</p><p>他们因为时间复杂度一直没写 C 题，但是现在已经没办法了，他们就决定试一下，我就在旁边一会看他们敲代码，一会想着如何解决 H 题，最后二十分钟左右，我又想出了一个算法，实现简单，而且还没啥大问题。他们看起来也打算放弃 C 题了，我就说让我在挣扎一下，他们同意了，于是他们在旁边看我敲起了代码，一直敲了十几分钟，最后几分钟，代码算是敲完了，测样例，没过…检查了一下，发现我手残把两个输出设置的一样。被嘲讽了一波后过了样例，此时还有三分钟，提交，焦急的的等待着评判结果，WA……，还有两分钟，再看了一下代码，有一个地方忘记写了，加上后，测样例，提交，又WA……此时剩下了最后一分钟，机房里面有人已经开始收拾起了行李，我还在看我的代码，但是最后还是没检查出来，不得不失落地走了。</p><p>赛后看群消息，发现金奖和一A有500奖金，然后又小激动了一下，继而又后悔起了差四分钟 1A 的 H 题，太亏了。</p><p>之前教练和我们说的是比赛完直接走，但是我们想参加颁奖典礼，于是和带队老师说了一下，老师也同意了。颁奖典礼现场，赞助方现场发现金！！！简直不要太阔气。拿了500，也算是有点收获。最后第九名，没达到预期的排名，心有不甘，接下来还有一场ICPC省赛，希望接下来一场比赛能好好打，争取不丢学长的脸。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;希望下回有个好成绩。&lt;/p&gt;
    
    </summary>
    
      <category term="游记" scheme="https://boctorio.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="游记" scheme="https://boctorio.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2017浙江省赛E题--Seven Segment Display（数位dp）</title>
    <link href="https://boctorio.github.io/2019/04/12/Seven-Segment-Display/"/>
    <id>https://boctorio.github.io/2019/04/12/Seven-Segment-Display/</id>
    <published>2019-04-12T06:50:32.000Z</published>
    <updated>2019-04-17T03:50:39.619Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接: <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3962" target="_blank" rel="noopener">Seven Segment Display</a></p><a id="more"></a><p>题意大致为:</p><blockquote><p> t 组数据</p><p>每组数据一个时间 n 和计数器当前显示时间 m（8位16进制数） ，求在n秒内（包括当前秒）每秒所出现的数字的权值和。</p><p>特别的是，当 m =  FFFFFFFF 时，下一秒会变成 00000000。</p><p>每个数字的权值为：</p><p><img src="/2019/04/12/Seven-Segment-Display/权值.png" alt=""></p><p>For example, in order to display the hexadecimal number “5A8BEF67” on the component for one second, 5 + 6 + 7 + 5 + 5 + 4 + 6 + 3 = 41 units of energy will be consumed.</p><p><strong>Sample Input</strong></p><p>3<br>5 89ABCDEF<br>3 FFFFFFFF<br>7 00000000</p><p><strong>Sample Output</strong></p><p>208<br>124<br>327</p></blockquote><p>一个比较复杂的数位dp，我们在数位dp的时候还需要记录一下每个数字被使用的个数。</p><p>dp[ i ][ j ]表示第 i 位为 j 时所需要加的权值。</p><p>由于还需要记录每个数被使用的次数，所以返回值需要有两个（权值和，使用次数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">ll value,times;</span><br><span class="line">&#125;;</span><br><span class="line">ll dp[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line">ll bit[<span class="number">10</span>];</span><br><span class="line">ll mp[<span class="number">20</span>]=&#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">node <span class="title">dfs</span><span class="params">(ll pos,ll pre,<span class="keyword">bool</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> (node)&#123; mp[pre] , <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">if</span>(!limit &amp;&amp; dp[pos][pre]) <span class="keyword">return</span> (node)&#123; dp[pos][pre] , <span class="number">1</span>&lt;&lt;(<span class="number">4</span>*pos) &#125;;<span class="comment">//使用次数 16^pos 次 </span></span><br><span class="line"></span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line">ll times=<span class="number">0</span>;</span><br><span class="line">node x;</span><br><span class="line">ll maxn=limit?bit[pos]:<span class="number">15</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">x=dfs(pos<span class="number">-1</span>,i,limit &amp;&amp; i==maxn);</span><br><span class="line">cnt+=x.value;</span><br><span class="line">times+=x.times;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cnt+=mp[pre]*times;<span class="comment">//权值*使用的次数</span></span><br><span class="line"><span class="keyword">if</span>(!limit) dp[pos][pre]=cnt;</span><br><span class="line"><span class="keyword">return</span> (node)&#123; cnt , times &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;<span class="comment">//由于0也有权值，所以必须计算八位 </span></span><br><span class="line">bit[i]=x%<span class="number">16</span>;</span><br><span class="line">x/=<span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line">node res=dfs(<span class="number">8</span>,<span class="number">16</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> res.value; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll n,m;</span><br><span class="line">ll res;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %X"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">if</span>(n+m<span class="number">-1</span>&gt;INF)&#123;<span class="comment">//溢出 </span></span><br><span class="line">res=solve(INF)-solve(m<span class="number">-1</span>);</span><br><span class="line">res+=solve(m+n<span class="number">-2</span>-INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">res=solve(n+m<span class="number">-1</span>)-solve(m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接: &lt;a href=&quot;http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3962&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Seven Segment Display&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="数位dp" scheme="https://boctorio.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"/>
    
  </entry>
  
  <entry>
    <title>“高教社杯”第三届福建省大学生程序设计竞赛F题--华容道</title>
    <link href="https://boctorio.github.io/2019/04/07/%E5%8D%8E%E5%AE%B9%E9%81%93/"/>
    <id>https://boctorio.github.io/2019/04/07/华容道/</id>
    <published>2019-04-07T13:40:07.000Z</published>
    <updated>2019-04-12T14:38:07.665Z</updated>
    
    <content type="html"><![CDATA[<p>模拟界的泥石流。</p><p>差点就想要手算了。</p><a id="more"></a><p>题目描述：</p><blockquote><p>Cao Cao was hunted down by thousands of enemy soldiers when he  escaped from Hua Rong Dao. Assuming Hua Rong Dao is a narrow aisle (one  N*4 rectangle), while Cao Cao can be regarded as one 2*2 grid. Cross  general can be regarded as one 1*2 grid.Vertical general can be regarded  as one 2*1 grid. Soldiers can be regarded as one 1*1 grid. Now Hua Rong  Dao is full of people, no grid is empty.</p><p>There is only one Cao Cao. The number of Cross general, vertical  general, and soldier is not fixed. How many ways can all the people  stand?</p><p><strong>Input</strong></p><p>There is a single integer T (T≤4) in the first line of the test data indicating that there are T test cases.</p><p>Then for each case, only one integer N (1≤N≤4) in a single line indicates the length of Hua Rong Dao.</p><p><strong>Output</strong></p><p>  For each test case, print the number of ways all the people can stand in a single line. </p><p><strong>Sample Input</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 2</span><br><span class="line">&gt; 1</span><br><span class="line">&gt; 2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>Sample Output</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0</span><br><span class="line">&gt; 18</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>题目的大致意思就是：给你一个 n*4 的网格，你要找到所有的方案，使得在这个网格中有且仅有一个 2*2 大小的曹操，其他的网格任意放。</p><p>看到数据范围我就惊了，从没看过这么小的数据范围，然而当我写的时候才发现这是有多么的艰难……</p><p>大致思路就是：</p><blockquote><ol><li>先固定曹操的位置。</li><li>枚举 1*2 和 2*1 的方块的个数。</li><li>固定 1*2 方块</li><li>固定 2*1 方块</li><li>全部完成后判断是否是已经出现过的排列方式，如果没出现过，那么累加；否则不累加。</li></ol></blockquote><p>代码写的我都有点不敢相信这是正确的…</p><p>由于写的着急，没有进行剪枝和其他优化操作，时间可能会耗费太多。但由于数据范围很小，所以在本地跑出来直接输出就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll mp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,ll&gt;p;<span class="comment">//标记出现过的放置情况 </span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>,mp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">()</span></span>&#123;<span class="comment">//判断当前情况是否出现过 </span></span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">res=res*<span class="number">4</span>+mp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!p[res])&#123;</span><br><span class="line">p[res]++;</span><br><span class="line">sum++;</span><br><span class="line"><span class="comment">//output();</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">val</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> maxv)</span></span>&#123;<span class="comment">//放完 1*2 的方块以后放 2*1 的方块 </span></span><br><span class="line"><span class="keyword">if</span>(num==maxv) <span class="keyword">return</span> judge();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mp[i][j] &amp;&amp; !mp[i+<span class="number">1</span>][j] &amp;&amp;i+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">mp[i][j]=mp[i+<span class="number">1</span>][j]=<span class="number">3</span>;</span><br><span class="line">val(num+<span class="number">1</span>,maxv);</span><br><span class="line">mp[i][j]=mp[i+<span class="number">1</span>][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> maxc,<span class="keyword">int</span> maxv)</span></span>&#123;<span class="comment">//放 1*2 的方块 </span></span><br><span class="line"><span class="keyword">if</span>(num==maxc)&#123;</span><br><span class="line"><span class="keyword">return</span> val(<span class="number">0</span>,maxv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mp[i][j] &amp;&amp; !mp[i][j+<span class="number">1</span>] &amp;&amp; j+<span class="number">1</span>&lt;m)&#123;</span><br><span class="line">mp[i][j]=mp[i][j+<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> x=cal(num+<span class="number">1</span>,maxc,maxv);</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">res+=x;</span><br><span class="line">mp[i][j]=mp[i][j+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caocao</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//枚举曹操的位置 </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;=n<span class="number">-1</span> || y&gt;=m<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">mp[x][y]=mp[x+<span class="number">1</span>][y+<span class="number">1</span>]=mp[x][y+<span class="number">1</span>]=mp[x+<span class="number">1</span>][y]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">8</span>;j++)&#123;<span class="comment">//枚举 1*2 2*1 方块的个数。 </span></span><br><span class="line"><span class="keyword">int</span> x=cal(<span class="number">0</span>,i,j);</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">res+=cal(<span class="number">0</span>,i,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mp[x][y]=mp[x+<span class="number">1</span>][y+<span class="number">1</span>]=mp[x][y+<span class="number">1</span>]=mp[x+<span class="number">1</span>][y]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">p.clear();</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">caocao(i,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模拟界的泥石流。&lt;/p&gt;
&lt;p&gt;差点就想要手算了。&lt;/p&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="模拟" scheme="https://boctorio.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>“高教社杯”第三届福建省大学生程序设计竞赛H题--Mountain Number（数位dp）</title>
    <link href="https://boctorio.github.io/2019/04/07/Mountain-Number-%E6%95%B0%E4%BD%8Ddp/"/>
    <id>https://boctorio.github.io/2019/04/07/Mountain-Number-数位dp/</id>
    <published>2019-04-07T12:01:41.000Z</published>
    <updated>2019-04-17T03:50:59.079Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵学到的数位dp终于派上了用场。</p><a id="more"></a><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>One integer number x is called “Mountain Number” if:</p><p>(1) x&gt;0 and x is an integer;</p><p>(2) Assume $ x=a[0]a[1]…a[len-2]a[len-1] $  ($ 0≤a[i]≤9​$ , a[0] is  positive). Any a[2i+1]  is larger or equal to a[2i] and a[2i+2](if  exists).</p><p>For example, 111, 132, 893, 7 are “Mountain Number” while 123, 10, 76889 are not “Mountain Number”.</p><p>Now you are given L and R, how many “Mountain Number” can be found between L and R (inclusive) ?</p><p><strong>Input</strong></p><p>The first line of the input contains an integer T (T≤100), indicating the number of test cases.</p><p>Then T cases, for any case, only two integers L and R (1≤L≤R≤1,000,000,000).</p><p><strong>Output</strong></p><p>For each test case, output the number of “Mountain Number” between L and R in a single line.</p><p><strong>Sample Input</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">10</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">100</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">1000</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>Sample Output</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">9</span></span><br><span class="line">&gt; <span class="number">54</span></span><br><span class="line">&gt; <span class="number">384</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>题目大概意思就是定义一个 “ 山型数 ” ，它里面的奇数位不小于偶数位（最高位为第 0 位），求区间 [ l , r ] 里面山型数的个数。</p><p>算是数位dp的裸题吧。</p><p>这是下午提交的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> wei[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swdp</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> p,<span class="keyword">int</span> pre,<span class="keyword">bool</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!limit &amp;&amp; dp[pos][pre]&gt;=<span class="number">0</span>) <span class="keyword">return</span> dp[pos][pre];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxx=limit?wei[pos]:<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxx;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; pre&gt;i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; pre&lt;i) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">cnt+=swdp(pos<span class="number">-1</span>,p+<span class="number">1</span>,i,limit &amp;&amp; i==maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!limit) dp[pos][pre]=cnt;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">wei[sum++]=x%<span class="number">10</span>;</span><br><span class="line">x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> swdp(sum<span class="number">-1</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="comment">//printf("%d %d\n",solve(r),solve(l-1));</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(r)-solve(l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交的时候就感觉这个代码和正常的数位dp有一点不同。一般情况下 memset 应该在主函数里面，只需要初始化一次就可以了，但是下午在调试的时候发现只有每次都更新才能计算出正确结果。</p><p>经过长时间的调试，发现了我在数位dp上的漏洞。数位dp保存下来的值<strong>应该具有后效性</strong>，但是我的代码忽略的<strong>位</strong>的区别，当前位可能是奇数位，也可能是偶数位，奇偶性不同，结果也不同。因此不能使用二维的数组来储存，应该再多加一维，用来区分位的奇偶性。</p><p>修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>][<span class="number">2</span>];<span class="comment">//当前位置，前一位数，当前位置奇偶性 </span></span><br><span class="line"><span class="keyword">int</span> wei[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,<span class="keyword">int</span> bit,<span class="keyword">bool</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!limit &amp;&amp; dp[pos][pre][bit&amp;<span class="number">1</span>]&gt;=<span class="number">0</span>) <span class="keyword">return</span> dp[pos][pre][bit&amp;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxx=limit?wei[pos]:<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxx;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(bit%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; pre&lt;i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(bit%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; pre&gt;i) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">cnt+=DP(pos<span class="number">-1</span>,i,bit+<span class="number">1</span>,limit &amp;&amp; i==maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!limit) dp[pos][pre][bit&amp;<span class="number">1</span>]=cnt;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">wei[sum++]=x%<span class="number">10</span>;</span><br><span class="line">x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DP(sum<span class="number">-1</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(r)-solve(l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>温故而知新。</p><p>这也给了我一次重新认识数位dp的机会，对数位dp有了更深刻的了解。</p><p>以此共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵学到的数位dp终于派上了用场。&lt;/p&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="数位dp" scheme="https://boctorio.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"/>
    
  </entry>
  
  <entry>
    <title>第九届河南理工大学算法程序设计竞赛</title>
    <link href="https://boctorio.github.io/2019/03/31/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E6%B2%B3%E5%8D%97%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/"/>
    <id>https://boctorio.github.io/2019/03/31/第九届河南理工大学算法程序设计竞赛/</id>
    <published>2019-03-31T12:07:34.000Z</published>
    <updated>2019-04-04T09:46:40.226Z</updated>
    
    <content type="html"><![CDATA[<p>人外有人，外校的强者还是多。</p><a id="more"></a><h4 id="A-Asia区域赛"><a href="#A-Asia区域赛" class="headerlink" title="A.Asia区域赛"></a>A.Asia区域赛</h4><p>感谢组委会给我们学校举办区域赛的机会！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">29</span>+<span class="number">58</span>+<span class="number">87</span>+<span class="number">11</span>+<span class="number">1</span>+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-Asia区域制"><a href="#B-Asia区域制" class="headerlink" title="B.Asia区域制"></a>B.Asia区域制</h4><p>二进制转16进制，<strong>四位二进制相当于一位16进制</strong>，直接按照定义模拟就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1000000</span>+<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> num[<span class="number">100</span>]=<span class="string">"0123456789abcdef"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pos+<span class="number">4</span>;i++)&#123;</span><br><span class="line">res=res*<span class="number">2</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,num[res]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cal(pos<span class="number">-4</span>);</span><br><span class="line">res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;pos+<span class="number">4</span>;i++)&#123;</span><br><span class="line">res=res*<span class="number">2</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,num[res]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">cal(len<span class="number">-4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-Asia区域宫"><a href="#C-Asia区域宫" class="headerlink" title="C.Asia区域宫"></a>C.Asia区域宫</h4><p>题目有句话很重要：<strong>障碍物在迷宫中不能同行且不能同列</strong>，因此只要不是从左下角连到右上角（不一定非得是角落）把地图分成两份，那么就可以走到，并且不用走多余的步数。</p><p>所以我们只要统计每一斜线上的格子是否被填满，当  x1+y1=x2+y2时，这两个格子在同一斜线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,x,y,n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">x--,y--;</span><br><span class="line">a[n+x+y]++;</span><br><span class="line"><span class="keyword">if</span>(x+y&lt;n)&#123;</span><br><span class="line"><span class="keyword">if</span>( a[n+x+y] == x+y+<span class="number">1</span> ) flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a[n+x+y]==n*<span class="number">2</span><span class="number">-1</span>-x-y) flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Yes %d\n"</span>,n*<span class="number">2</span><span class="number">-2</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D-Asia区域阵"><a href="#D-Asia区域阵" class="headerlink" title="D.Asia区域阵"></a>D.Asia区域阵</h4><p>确认过眼神，不是我的题。</p><p>这个题数据范围不大，但是复杂度较高。</p><p>我们枚举所有的起点（异矩阵的左上角），然后枚举异矩阵的行列大小。然后就可以慢慢求解。</p><p>我们在枚举异矩阵的列的时候，如果遇到了重复的字符，那么就直接结束，并且此时我们知道了列的最大值，因此我们可以<strong>更新列的范围</strong>。（当时应该就是因为这个超时了）</p><blockquote><p>对于 6 * 6 的矩阵</p><p>如果（红色为选中的异矩阵，黑色为重复字符）：</p><p><img src="/2019/03/31/第九届河南理工大学算法程序设计竞赛/1.png" alt=""></p><p>那么我们接下来最多就只能进行到：</p><p><img src="/2019/03/31/第九届河南理工大学算法程序设计竞赛/2.png" alt=""></p><p>列数是越来越小，不可能比之前的还大了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;mpl[<span class="number">30</span>],mpr[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">26</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">26</span>,k+i&lt;n;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;length;l++)&#123;</span><br><span class="line"><span class="keyword">if</span>( mpl[k][ str[i+k][j+l] ] &gt; <span class="number">0</span> || mpr[l][ str[i+k][j+l] ] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">length=min(length,l);<span class="comment">//减小length的范围 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mpl[k][ str[i+k][j+l] ]++;</span><br><span class="line">mpr[l][ str[i+k][j+l] ]++;</span><br><span class="line">res=max(res,(k+<span class="number">1</span>)*(l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="E-Mo的游戏"><a href="#E-Mo的游戏" class="headerlink" title="E.Mo的游戏"></a>E.Mo的游戏</h4><p>也是模拟，注意一下每个字符第一次出现的情况就行了。</p><p>保存这个字符上一次出现的位置，然后根据现在这个位置和保存的上个位置的差值来进行求解。如果之前没有出现过这个字符，那么就跳过，不用计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> res[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(pos,<span class="number">-1</span>,<span class="keyword">sizeof</span>(pos));</span><br><span class="line"><span class="built_in">memset</span>(res,INF,<span class="keyword">sizeof</span>(res));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">mp[str[i]]++;</span><br><span class="line"><span class="keyword">if</span>(pos[str[i]]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">res[str[i]]=min(i-pos[str[i]],res[str[i]]);</span><br><span class="line">&#125;</span><br><span class="line">pos[str[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="string">'a'</span>;i&lt;=<span class="string">'z'</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mp[i])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c:"</span>,i);</span><br><span class="line"><span class="keyword">if</span>(res[i]!=INF) <span class="built_in">printf</span>(<span class="string">"%d"</span>,len-res[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="string">'A'</span>;i&lt;=<span class="string">'Z'</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mp[i])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c:"</span>,i);</span><br><span class="line"><span class="keyword">if</span>(res[i]!=INF) <span class="built_in">printf</span>(<span class="string">"%d"</span>,len-res[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="F-Mo的极限"><a href="#F-Mo的极限" class="headerlink" title="F.Mo的极限"></a>F.Mo的极限</h4><p>炒鸡大模拟，简直了。。。</p><p>因为多项式的格式为 kx^y ,所以我们找 k 和 y 时可以直接根据它们的相对位置来求解。</p><p>首先当然是确认k的正负，根据 k 前面的 + - 字符判断，然后再运算符之后就是 k 的值。</p><p>计算出 k 的值之后，k 和 y 之间相差了一个 x^ 因此把位置向后挪两位，就可以直接开始求 y 的值。</p><blockquote><p>坑1：每个项可能会抵消，所以要用数组存每个项的系数。</p><p>坑2：最后输出不能有1/-2这种情况，必须是-1/2。（我因为这个多wa了两次QAQ）</p><p>坑3：应该是没其他太大的坑了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str1[maxn],str2[maxn];</span><br><span class="line"><span class="keyword">int</span> xishu1[maxn],xishu2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> y?gcd(y,x%y):x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum,x,y,flag;</span><br><span class="line"><span class="keyword">int</span> max_xishu1=<span class="number">-1</span>,max_xishu2=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> max_mi1=<span class="number">-1</span>,max_mi2=<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,str1,str2);</span><br><span class="line"><span class="keyword">int</span> len1=<span class="built_in">strlen</span>(str1);</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">x=y=<span class="number">0</span>;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str1[i]==<span class="string">'-'</span>) flag=<span class="number">-1</span>,i++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str1[i]==<span class="string">'+'</span>) flag=<span class="number">1</span>,i++;</span><br><span class="line"><span class="keyword">if</span>(str1[i]&gt;=<span class="string">'0'</span> &amp;&amp; str1[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(str1[i]&gt;=<span class="string">'0'</span> &amp;&amp; str1[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">x=x*<span class="number">10</span>+str1[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">x*=flag;</span><br><span class="line">i+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(str1[i<span class="number">-1</span>]==<span class="string">'^'</span> &amp;&amp; str1[i]&gt;=<span class="string">'0'</span> &amp;&amp; str1[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(str1[i]&gt;=<span class="string">'0'</span> &amp;&amp; str1[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">y=y*<span class="number">10</span>+str1[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">xishu1[y]+=x;</span><br><span class="line">&#125;</span><br><span class="line">x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=len1<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10000</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(xishu1[i])&#123;</span><br><span class="line">max_mi1=i;</span><br><span class="line">max_xishu1=xishu1[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len2=<span class="built_in">strlen</span>(str2);</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">x=y=<span class="number">0</span>;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str2[i]==<span class="string">'-'</span>) flag=<span class="number">-1</span>,i++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str2[i]==<span class="string">'+'</span>) flag=<span class="number">1</span>,i++;</span><br><span class="line"><span class="keyword">if</span>(str2[i]&gt;=<span class="string">'0'</span> &amp;&amp; str2[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(str2[i]&gt;=<span class="string">'0'</span> &amp;&amp; str2[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">x=x*<span class="number">10</span>+str2[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">x*=flag;</span><br><span class="line">i+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(str2[i<span class="number">-1</span>]==<span class="string">'^'</span> &amp;&amp; str2[i]&gt;=<span class="string">'0'</span> &amp;&amp; str2[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(str2[i]&gt;=<span class="string">'0'</span> &amp;&amp; str2[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">y=y*<span class="number">10</span>+str2[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">xishu2[y]+=x;</span><br><span class="line">&#125;</span><br><span class="line">x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=len2<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10000</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(xishu2[i])&#123;</span><br><span class="line">max_mi2=i;</span><br><span class="line">max_xishu2=xishu2[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(max_mi1==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(max_mi1&gt;max_mi2) <span class="built_in">printf</span>(<span class="string">"oo\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(max_mi1&lt;max_mi2) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(max_xishu1%max_xishu2==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max_xishu1/max_xishu2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> g=gcd(max_xishu1,max_xishu2);</span><br><span class="line"><span class="keyword">if</span>(max_xishu2/g&lt;<span class="number">0</span>)&#123;</span><br><span class="line">max_xishu1*=<span class="number">-1</span>;</span><br><span class="line">max_xishu2*=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d/%d"</span>,max_xishu1/g,max_xishu2/g);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="G-Mo的数学"><a href="#G-Mo的数学" class="headerlink" title="G.Mo的数学"></a>G.Mo的数学</h4><p>容斥定理+逆元。</p><p>这个如果直接用循环就会超时。</p><p>我们先预处理 1 ~ n 的阶乘，可以省下不少时间。</p><p>思路是：<strong>找出 n ! （n的阶乘）,然后除以不符合条件的数（不互质的数）。</strong></p><p>然后我们对 m 的因子进行处理，可以知道的是，如果m的质因子 a ，那么 a * x（x&gt;=0） 必然与 m 不互质，而且在 [ 1 , n ] 的范围内 a 的倍数相乘结果为$ f(a)=a^{n/a}*(n/a)! $  ，因为区间内 a 的倍数只有 n / a 个，然后就是<strong>容斥定理</strong>（容斥定理详见我之前的博客（<a href="https://boctorio.com/2019/01/09/%E7%AE%97%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86-%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86/" target="_blank" rel="noopener">算数基本定理+容斥定理</a>））。</p><p>但是在除以 f(a) 时，可能会出现除不尽的情况，因此需要用逆元来处理一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000000</span>+<span class="number">7</span>;</span><br><span class="line">ll mul[maxn];</span><br><span class="line">ll yinzi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mul[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">mul[i]=mul[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mulpow</span><span class="params">(ll x,ll b)</span></span>&#123;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">x=x*x%mod;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">init();</span><br><span class="line">ll n,m,i,j;</span><br><span class="line">ll res,sum,s,x;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">res=mul[n];</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(m%i==<span class="number">0</span>)&#123;</span><br><span class="line">yinzi[sum++]=i;</span><br><span class="line"><span class="keyword">while</span>(m%i==<span class="number">0</span>) m/=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m!=<span class="number">1</span>) yinzi[sum++]=m;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=(<span class="number">1</span>&lt;&lt;sum)<span class="number">-1</span>;i++)&#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;sum;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">s++;</span><br><span class="line">x*=yinzi[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;n) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(s&amp;<span class="number">1</span>)&#123;</span><br><span class="line">res=res*mulpow(mulpow(x,n/x),mod<span class="number">-2</span>)%mod;</span><br><span class="line">res=res*mulpow(mul[n/x],mod<span class="number">-2</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">res=res*mulpow(x,n/x)%mod;</span><br><span class="line">res=res*mul[n/x]%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="H-Mo的面积"><a href="#H-Mo的面积" class="headerlink" title="H.Mo的面积"></a>H.Mo的面积</h4><p>做了第三遍了…详见之前的博客<a href="https://boctorio.com/2019/03/22/%E7%9F%A9%E9%98%B5%E9%9D%A2%E7%A7%AF%E5%B9%B6/" target="_blank" rel="noopener">矩阵面积并</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r=min(max(a[<span class="number">1</span>],a[<span class="number">3</span>]),max(a[<span class="number">5</span>],a[<span class="number">7</span>]));</span><br><span class="line"><span class="keyword">int</span> l=max(min(a[<span class="number">1</span>],a[<span class="number">3</span>]),min(a[<span class="number">5</span>],a[<span class="number">7</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u=min(max(a[<span class="number">2</span>],a[<span class="number">4</span>]),max(a[<span class="number">6</span>],a[<span class="number">8</span>]));</span><br><span class="line"><span class="keyword">int</span> d=max(min(a[<span class="number">2</span>],a[<span class="number">4</span>]),min(a[<span class="number">6</span>],a[<span class="number">8</span>]));</span><br><span class="line"><span class="keyword">int</span> bing;</span><br><span class="line"><span class="keyword">if</span>(r-l&lt;<span class="number">0</span> || u-d&lt;<span class="number">0</span>) bing=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> bing=(r-l)*(u-d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(a[<span class="number">3</span>]-a[<span class="number">1</span>])*(a[<span class="number">4</span>]-a[<span class="number">2</span>])+(a[<span class="number">7</span>]-a[<span class="number">5</span>])*(a[<span class="number">8</span>]-a[<span class="number">6</span>])-bing);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="I-安全距离"><a href="#I-安全距离" class="headerlink" title="I.安全距离"></a>I.安全距离</h4><p>防AK题果然毒瘤。</p><p>二分适用于单调性的区间，由于这个题目球面是个弧线，并不是直线，因此需要用三分来求解。</p><p>然后我们就用三分的思想来求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y, z;</span><br><span class="line">P() &#123;&#125;</span><br><span class="line">P(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y, <span class="keyword">double</span> _z) &#123;</span><br><span class="line">x = _x;</span><br><span class="line">y = _y;</span><br><span class="line">z = _z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> P &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x * b.x + y * b.y + z * b.z; &#125;</span><br><span class="line">P <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">double</span> &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> P(x * b, y * b, z * b); &#125;</span><br><span class="line">P <span class="keyword">operator</span>-(<span class="keyword">const</span> P &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> P(x - b.x, y - b.y, z - b.z); &#125;</span><br><span class="line">P <span class="keyword">operator</span>+(<span class="keyword">const</span> P &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> P(x + b.x, y + b.y, z + b.z); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">const</span> P &amp;b)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>((*<span class="keyword">this</span> - b) * (*<span class="keyword">this</span> - b)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> P &amp;a, <span class="keyword">const</span> P &amp;b, <span class="keyword">const</span> P &amp;o, <span class="keyword">const</span> <span class="keyword">double</span> &amp;t)</span> </span>&#123;</span><br><span class="line">P p = a + ((b - a) * t);</span><br><span class="line"><span class="keyword">return</span> p.dis(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> P &amp;s, <span class="keyword">const</span> P &amp;t, <span class="keyword">const</span> P &amp;o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> low = <span class="number">0.0</span>, top = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">double</span> m = (top - low) / <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">double</span> l = low + m;</span><br><span class="line"><span class="keyword">double</span> r = top - m;</span><br><span class="line"><span class="keyword">if</span> (f(s, t, o, l) &gt;= f(s, t, o, r))</span><br><span class="line">low = l;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">top = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f(s, t, o, low);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DIS</span><span class="params">(P s, P b, P c, P o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> low = <span class="number">0.0</span>, top = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">double</span> m = (top - low) / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> l = low + m;</span><br><span class="line"><span class="keyword">double</span> r = top - m;</span><br><span class="line"><span class="keyword">if</span> (g(s, b + (c - b) * l, o) &gt;= g(s, b + (c - b) * r, o))</span><br><span class="line">low = l;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">top = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> g(s, b + ((c - b) * low), o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">P s, b, c, o;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s.x &gt;&gt; s.y &gt;&gt; s.z &gt;&gt; b.x &gt;&gt; b.y &gt;&gt; b.z &gt;&gt; c.x &gt;&gt; c.y &gt;&gt; c.z &gt;&gt; o.x &gt;&gt; o.y &gt;&gt;</span><br><span class="line">    o.z &gt;&gt; r;</span><br><span class="line"><span class="keyword">double</span> dis = min(min(DIS(b, s, c, o), DIS(s, b, c, o)), DIS(c, s, b, o));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, max(<span class="number">0.0</span>, dis - r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="J-简单递归"><a href="#J-简单递归" class="headerlink" title="J.简单递归"></a>J.简单递归</h4><p>直接抄就完事了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line">ll res[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">res[<span class="number">0</span>]=res[<span class="number">1</span>]=res[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">res[i]=((res[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>)%mod+(res[i<span class="number">-2</span>]&gt;&gt;<span class="number">1</span>)%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="K-高度期望"><a href="#K-高度期望" class="headerlink" title="K.高度期望"></a>K.高度期望</h4><p>贪心一发，能多加尽量多加。</p><p>选取尽量低的树，这样加的高度就更多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">sum+=a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;=m*n) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">res++;</span><br><span class="line">sum+=(<span class="number">1000</span>-a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="L-最优规划"><a href="#L-最优规划" class="headerlink" title="L.最优规划"></a>L.最优规划</h4><p>最小生成树裸题。</p><p>前m个路径长度不用管，直接把城镇相连。</p><p>之后s个用结构体保存，排序之后选择，然后并查集莽一发就过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">100010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;qwe[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node c,node d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c.val&lt;d.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> father[c]==c?c:father[c]=find(father[c]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x1=find(c);</span><br><span class="line"><span class="keyword">int</span> x2=find(d);</span><br><span class="line"><span class="keyword">if</span>(x1!=x2)</span><br><span class="line">&#123;</span><br><span class="line">father[x2]=x1;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) father[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;val);</span><br><span class="line">join(a,b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;qwe[i].x,&amp;qwe[i].y,&amp;qwe[i].val);</span><br><span class="line">&#125;</span><br><span class="line">sort(qwe,qwe+s,cmp);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(join(qwe[i].x,qwe[i].y))</span><br><span class="line">&#123;</span><br><span class="line">sum+=qwe[i].val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(father[i]!=i) t++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Concubines can't do it.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是把代码贴上吧。</p><p>代码太丑，仅供参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人外有人，外校的强者还是多。&lt;/p&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>菜鸡的天梯赛一日游</title>
    <link href="https://boctorio.github.io/2019/03/30/%E8%8F%9C%E9%B8%A1%E7%9A%84%E5%A4%A9%E6%A2%AF%E8%B5%9B%E4%B8%80%E6%97%A5%E6%B8%B8/"/>
    <id>https://boctorio.github.io/2019/03/30/菜鸡的天梯赛一日游/</id>
    <published>2019-03-30T10:01:05.000Z</published>
    <updated>2019-04-14T03:16:55.873Z</updated>
    
    <content type="html"><![CDATA[<p>省二，就这样吧。</p><p>毕竟不可控因素太多了，还是自己实力不够。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;省二，就这样吧。&lt;/p&gt;
&lt;p&gt;毕竟不可控因素太多了，还是自己实力不够。&lt;/p&gt;

      
    
    </summary>
    
      <category term="游记" scheme="https://boctorio.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="游记" scheme="https://boctorio.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>四大dp系列--区间dp</title>
    <link href="https://boctorio.github.io/2019/03/27/%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E5%8C%BA%E9%97%B4dp/"/>
    <id>https://boctorio.github.io/2019/03/27/四大dp系列-区间dp/</id>
    <published>2019-03-27T00:22:38.000Z</published>
    <updated>2019-03-27T03:31:19.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h3><p>区间dp有点道家的思想：一生二，二生三，三生万物。</p><p>区间dp的思想就是化繁为简，将大的区间化成两个小的区间，然后递推求解。</p><a id="more"></a><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p><a href="http://www.51nod.com/Challenge/Problem.html#!#problemId=1021" target="_blank" rel="noopener">石子归并</a></p><blockquote><p>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。</p><p>例如： 1 2 3 4，有不少合并方法</p><p>1 2 3 4 =&gt; 3 3 4(3) =&gt; 6 4(9) =&gt; 10(19)</p><p>1 2 3 4 =&gt; 1 5 4(5) =&gt; 1 9(14) =&gt; 10(24)</p><p>1 2 3 4 =&gt; 1 2 7(7) =&gt; 3 7(10) =&gt; 10(20)</p><p>括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。</p><p><strong>输入</strong></p><p>第1行：N（2 &lt;= N &lt;= 100)<br>第2 - N + 1：N堆石子的数量（1 &lt;= A[i] &lt;= 10000)</p><p><strong>输出</strong></p><p>输出最小合并代价</p><p><strong>输入样例</strong></p><p>4</p><p>1 2 3 4</p><p><strong>输出样例</strong></p><p>19</p></blockquote><p>这个是最经典的区间dp问题。</p><p>对于区间 [ i , j ] ，我们可以把它分成两个区间 [ i , k ] 和 [ k+1 , j ]，那么我们就可以通过这两个小区间的值来计算出大区间的值。</p><p>这是归并的过程（1,2,3,4为编号）：</p><blockquote><p><img src="/2019/03/27/四大dp系列-区间dp/1.png" alt=""></p><p><img src="/2019/03/27/四大dp系列-区间dp/2.png" alt=""></p><p><img src="/2019/03/27/四大dp系列-区间dp/3.png" alt=""></p><p><img src="/2019/03/27/四大dp系列-区间dp/4.png" alt=""></p></blockquote><p>可以发现的是，每次合并都是<strong>两个小区间合并成一个大区间</strong>，因此，我们只要计算出每个小区间所需要的最小花费，就能计算出合并后的大区间的最小花费。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];<span class="comment">//表示合并区间[i,j]的最小花费</span></span><br><span class="line"><span class="keyword">int</span> sum[maxn];<span class="comment">//从 1 ~ i 的和 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;<span class="comment">//计算长为len的区间的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="comment">//区间长为len,起点为i，终点为i+len-1</span></span><br><span class="line"><span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(j&gt;n) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;<span class="comment">//枚举所有的小区间 </span></span><br><span class="line">dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);<span class="comment">//sum[j]-sum[i-1]表示合并大区间[i,j]所需要添加的花费</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码的时间复杂度为O($n^3$)，当n比较大时就没办法在规定时间内求解。</p><p>这是我们就可以用<strong>四边形不等式</strong>（别问，问就是百度）来优化。当我们求解dp[ i , j - 1 ]时，我们可以记录最小花费的 k 的位置，即s[ i ][ j-1 ]=$k_1$。同样的，求解dp[ i + 1 ][ j ]时，我们也可以求出s[ i + 1 s][ j ] =$k_2$。</p><blockquote><p><strong>四边形不等式</strong></p><p>如果对于任意的a1≤a2&lt;b1≤b2，有m[ a1 , b1 ]+m[ a2 , b2 ]≤m[ a1 , b2 ]+m[ a2 , b1 ]，那么m[ i , j ]满足四边形不等式。</p><p>写成符合这篇博客的形式为：</p><p>如果对于任意的 i ≤ i + 1 &lt; j - 1 ≤ j ，有dp[ i , j-1 ]+dp[ i+1 , j ]≤dp[ i , j ]+dp[ i + 1 , j - 1 ]，那么m[ i , j ]满足四边形不等式。</p><p><a href="https://blog.csdn.net/noiau/article/details/72514812" target="_blank" rel="noopener">某聚的四边形不等式详细讲解</a></p></blockquote><p>从这个定理，我们可以推出区间 [ i ][ j ]所对应的 k 值在s[ i ][ j - 1 ] 和s[ i + 1 ][ j ] 之间，然后，我们又可以计算出s[ i ][ j ]，依次递推。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][i]=<span class="number">0</span>;</span><br><span class="line">s[i][i]=i;<span class="comment">//初始化 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(j&gt;n) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=s[i][j<span class="number">-1</span>];k&lt;=s[i+<span class="number">1</span>][j];k++)&#123;</span><br><span class="line"><span class="keyword">if</span>( dp[i][j] &gt; dp[i][k] + dp[k+<span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>])&#123;</span><br><span class="line">dp[i][j] = dp[i][k] + dp[k+<span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>];</span><br><span class="line">s[i][j]=k;<span class="comment">//记录最小花费对应的k值 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能把复杂度从O($ n^3 $)减少到O($ n^2 $)。</p><h4 id="Monkey-Party"><a href="#Monkey-Party" class="headerlink" title="Monkey Party"></a>Monkey Party</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3506" target="_blank" rel="noopener">HDU3506</a></p><p>这道题和石子归并相似，只是把线变成了环。我们只要把输入复制一遍放在第一次输入的后面就可以把环变成线来求解。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line"><span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>] + a[i-n];</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">    dp[i][i] = <span class="number">0</span>;</span><br><span class="line">    s[i][i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;n*<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=s[i][j<span class="number">-1</span>];k&lt;=s[i+<span class="number">1</span>][j];k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( dp[i][j] &gt; dp[i][k] + dp[k+<span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i][k] + dp[k+<span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>];</span><br><span class="line">                s[i][j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    ans = min( ans , dp[i][i+n<span class="number">-1</span>] );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;区间dp&quot;&gt;&lt;a href=&quot;#区间dp&quot; class=&quot;headerlink&quot; title=&quot;区间dp&quot;&gt;&lt;/a&gt;区间dp&lt;/h3&gt;&lt;p&gt;区间dp有点道家的思想：一生二，二生三，三生万物。&lt;/p&gt;
&lt;p&gt;区间dp的思想就是化繁为简，将大的区间化成两个小的区间，然后递推求解。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="https://boctorio.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>第十届蓝桥杯--C++-B组</title>
    <link href="https://boctorio.github.io/2019/03/24/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF-C-B%E7%BB%84/"/>
    <id>https://boctorio.github.io/2019/03/24/第十届蓝桥杯-C-B组/</id>
    <published>2019-03-24T13:27:25.000Z</published>
    <updated>2019-03-29T05:10:03.858Z</updated>
    
    <content type="html"><![CDATA[<p>能力一般，水平有限。请多见谅。</p><p><strong>喜提河南省一等奖一枚！</strong></p><h4 id="A-组队"><a href="#A-组队" class="headerlink" title="A:组队"></a>A:组队</h4><blockquote><p>本题总分：5 分</p><p>​     作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员， 组成球队的首发阵容。 每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1 号位至 5 号位的评分之和最大可能是多少？<a id="more"></a></p><p><img src="/2019/03/24/第十届蓝桥杯-C-B组/A.jpg" alt=""></p></blockquote><p>暴力解决一切！</p><p>答案：490。</p><h4 id="B-年号字串"><a href="#B-年号字串" class="headerlink" title="B:年号字串"></a>B:年号字串</h4><blockquote><p>本题总分：5 分<br>     小明用字母 A 对应数字 1，B 对应 2，以此类推，用 Z 对应 26。对于 27 以上的数字，小明用两位或更长位的字符串来对应，例如 AA 对应 27，AB 对 应 28，AZ 对应 52，LQ 对应 329。 请问 2019 对应的字符串是什么？</p></blockquote><p>不得不说，这个题遇见26居然还不进位！比赛最后我不得不手算……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">26</span>!=<span class="number">0</span>)&#123;<span class="comment">//所有位不能为0 </span></span><br><span class="line">out(n/<span class="number">26</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,n%<span class="number">26</span>+<span class="string">'A'</span><span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//如果为零，必须从高位借一位 </span></span><br><span class="line">out((n<span class="number">-26</span>)/<span class="number">26</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Z"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">2019</span>;</span><br><span class="line">out(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：BYQ。（算出BY的时候还激动了一下）</p><h4 id="C-数列求值"><a href="#C-数列求值" class="headerlink" title="C: 数列求值"></a>C: 数列求值</h4><blockquote><p>本题总分：10 分<br>    给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求 第 20190324 项的最后 4 位数字。</p></blockquote><p>一个 for 循环解决一切！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>,c=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=<span class="number">20190324</span>;i++)&#123;</span><br><span class="line">d=(a+b+c)%<span class="number">10000</span>;</span><br><span class="line">a=b;</span><br><span class="line">b=c;</span><br><span class="line">c=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：4659</p><h4 id="D-数的分解"><a href="#D-数的分解" class="headerlink" title="D: 数的分解"></a>D: 数的分解</h4><blockquote><p>本题总分：10 分<br>     把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包 含数字 2 和 4，一共有多少种不同的分解方法？ 注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。</p></blockquote><p>暴力杯名不虚传。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">10</span>==<span class="number">2</span> || x%<span class="number">10</span>==<span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2019</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="number">2019</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2019</span>-i-j&lt;=j) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(cal(i) &amp;&amp; cal(j) &amp;&amp; cal(<span class="number">2019</span>-i-j))&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案： 40785。</p><h4 id="E-迷宫"><a href="#E-迷宫" class="headerlink" title="E: 迷宫"></a>E: 迷宫</h4><blockquote><p>本题总分：15 分<br>    下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。</p><p>010000<br>000100<br>001001<br>110000</p><p>​    迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。 对于上面的迷宫，从入口开始，可以按 DRRURRDDDR 的顺序通过迷宫， 一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式， 其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。 请注意在字典序中D&lt;L&lt;R&lt;U。</p><p>01010101001011001001010110010110100100001000101010 00001000100000101010010000100000001001100110100101 01111011010010001000001101001011100011000000010000 01000000001010100011010000101000001010101011001011 00011111000000101000010010100010100000101100000000 11001000110101000010101100011010011010101011110111 00011011010101001001001010000001000101001110000000<br>10100000101000100110101010111110011000010000111010 00111000001010100001100010000001000101001100001001 11000110100001110010001001010101010101010001101000 00010000100100000101001010101110100010101010000101 11100100101001001000010000010101010100100100010100 00000010000000101011001111010001100000101010100011 10101010011100001000011000010110011110110100001000 10101010100001101010100101000010100000111011101001 10000000101100010000101100101101001011100000000100 10101001000000010100100001000100000100011110101001 00101001010101101001010100011010101101110000110101 11001010000100001100000010100101000001000111000010 00001000110000110101101000000100101001001000011101 10100101000101000000001110110010110101101010100001 00101000010000110101010000100010001001000100010101 10100001000110010001000010101001010101011111010010 00000100101000000110010100101001000001000000000010 11010000001001110111001001000011101001011011101000 00000110100010001000100000001000011101000000110011 10101000101000100010001111100010101001010000001000 10000010100101001010110000000100101010001011101000 00111100001000010000000110111000000001000000001011 10000001100111010111010001000110111010101101111000</p></blockquote><p>BFS+路径记忆，算是前面几道题唯一涉及算法的题目了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">30</span>,m=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> step[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//1：D 2:L 3: R 4: U </span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">vis[x][y]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;pi&gt;que;</span><br><span class="line">que.push(pi(x,y));</span><br><span class="line"><span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">x=que.front().first;</span><br><span class="line">y=que.front().second;</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> xx=x+d[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> yy=y+d[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(mp[xx][yy]==<span class="string">'0'</span> &amp;&amp; !vis[xx][yy] &amp;&amp; xx&gt;=<span class="number">0</span> &amp;&amp; xx&lt;n &amp;&amp; yy&gt;=<span class="number">0</span> &amp;&amp; yy&lt;m)&#123;</span><br><span class="line">vis[xx][yy]=<span class="number">1</span>;</span><br><span class="line">step[xx][yy]=i+<span class="number">1</span>;</span><br><span class="line">que.push(pi(xx,yy));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span> &amp;&amp; y==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(step[x][y]==<span class="number">1</span>)&#123;</span><br><span class="line">out(x<span class="number">-1</span>,y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"D"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(step[x][y]==<span class="number">2</span>)&#123;</span><br><span class="line">out(x,y+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"L"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(step[x][y]==<span class="number">3</span>)&#123;</span><br><span class="line">out(x,y<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"R"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">out(x+<span class="number">1</span>,y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"U"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]);</span><br><span class="line">&#125;</span><br><span class="line">bfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">out(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR</span><br></pre></td></tr></table></figure><h4 id="F-特别数的和"><a href="#F-特别数的和" class="headerlink" title="F: 特别数的和"></a>F: 特别数的和</h4><blockquote><p> 时间限制: 1.0s       内存限制: 256.0MB        本题总分：15 分</p><p>​    小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。 请问，在 1 到 n 中，所有这样的数的和是多少？<br>【输入格式】<br>​    输入一行包含一个整数 n。<br>【输出格式】<br>​    输出一行，包含一个整数，表示满足条件的数的和。<br>【样例输入】 </p><p>​    40<br>【样例输出】 </p><p>​    574<br>【评测用例规模与约定】 </p><p>​    对于 20% 的评测用例，1≤n≤10。 </p><p>​    对于 50% 的评测用例，1≤n≤100。 </p><p>​    对于 80% 的评测用例，1≤n≤1000。 </p><p>​    对于所有评测用例，1≤n≤10000。</p></blockquote><p>直接模拟就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">10</span>==<span class="number">2</span> || x%<span class="number">10</span>==<span class="number">0</span> || x%<span class="number">10</span>==<span class="number">1</span> || x%<span class="number">10</span>==<span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cal(i)) sum+=i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="G-完全二叉树的权值"><a href="#G-完全二叉树的权值" class="headerlink" title="G: 完全二叉树的权值"></a>G: 完全二叉树的权值</h4><blockquote><p>时间限制: 1.0s     内存限制: 256.0MB     本题总分：20 分<br>    给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从 上到下、从左到右的顺序依次是 A1, A2, ··· AN，如下图所示：</p><p><img src="/2019/03/24/第十届蓝桥杯-C-B组/G.png" alt=""></p><p>​    现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点 权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。 注：<strong>根的深度是 1</strong>。</p><p>【输入格式】<br>    第一行包含一个整数 N。 第二行包含 N 个整数 A1, A2, ··· AN 。<br>【输出格式】<br>    输出一个整数代表答案。</p><p>【样例输入】 </p><p>​    7 </p><p>​    1 6 5 4 3 2 1<br>【样例输出】 </p><p>​    2<br>【评测用例规模与约定】 </p><p>​    对于所有评测用例，1≤ N ≤100000，−100000≤ Ai ≤100000。</p></blockquote><p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。（来自百度百科）。</p><p>完全二叉树不是满二叉树，最后一层不一定全有节点，所以判断层数的时候要注意一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">ll a[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dep=<span class="number">1</span>;</span><br><span class="line">ll maxx=-INF;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&gt;=n) <span class="keyword">break</span>;<span class="comment">//上一次把所有数计算完毕</span></span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;<span class="comment">//每次加i个数,如果最后一层不满，+-0对结果不产生影响。 </span></span><br><span class="line">sum+=a[pos++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxx&lt;sum)&#123;</span><br><span class="line">maxx=sum;</span><br><span class="line">res=dep;</span><br><span class="line">&#125;</span><br><span class="line">i*=<span class="number">2</span>;</span><br><span class="line">dep++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="H-等差数列"><a href="#H-等差数列" class="headerlink" title="H: 等差数列"></a>H: 等差数列</h4><blockquote><p>时间限制: 1.0s     内存限制: 256.0MB     本题总分：20 分</p><p>​    数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一 部分的数列，只记得其中 N 个整数。 现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有 几项？</p><p>【输入格式】</p><p>​    输入的第一行包含一个整数 N。 第二行包含 N 个整数 A1,A2,··· ,AN。(注意 A1 ∼ AN 并不一定是按等差数 列中的顺序给出)</p><p>【输出格式】</p><p>​    输出一个整数表示答案。</p><p>【样例输入】 </p><p>​    5 </p><p>​    2 6 4 10 20</p><p>【样例输出】 </p><p>​    10</p><p>【样例说明】 </p><p>​    包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、 18、20。</p><p>【评测用例规模与约定】 </p><p>​    对于所有评测用例，2≤ N ≤100000，0≤ Ai ≤109。</p></blockquote><p>如果是等差数列，那么任意两个数的差值一定是公差的整数倍，因此我们只要找到最大的公差（GCD）就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> y?gcd(y,x%y):x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line"><span class="keyword">int</span> g=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">g=gcd(g,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(a[n<span class="number">-1</span>]-a[<span class="number">0</span>])/g+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="I-后缀表达式"><a href="#I-后缀表达式" class="headerlink" title="I: 后缀表达式"></a>I: 后缀表达式</h4><blockquote><p>时间限制: 1.0s     内存限制: 256.0MB     本题总分：25 分<br>    给定 N 个加号、M 个减号以及 N + M + 1 个整数 A1,A2,··· ,AN+M+1，小 明想知道在所有由这 N 个加号、M 个减号以及 N + M +1 个整数凑出的合法的 后缀表达式中，结果最大的是哪一个？<br>    请你输出这个最大的结果。 例如使用1 2 3 + -，则 “2 3 + 1 -” 这个后缀表达式结果是 4，是最大的。<br>【输入格式】<br>    第一行包含两个整数 N 和 M。 第二行包含 N + M + 1 个整数 A1,A2,··· ,AN+M+1。<br>【输出格式】<br>    输出一个整数，代表答案。<br>【样例输入】 </p><p>​    1 1 </p><p>​    1 2 3<br>【样例输出】 </p><p>​    4<br>【评测用例规模与约定】 </p><p>​    对于所有评测用例，0≤ N,M ≤100000，−109 ≤ Ai ≤109。</p></blockquote><p>待补充 ……</p><h4 id="J-灵能传输"><a href="#J-灵能传输" class="headerlink" title="J: 灵能传输"></a>J: 灵能传输</h4><blockquote><p>时间限制: 1.0s     内存限制: 256.0MB     本题总分：25 分<br>【题目背景】 </p><p>​    在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在 游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对 一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的 刺蛇飞龙等低血量单位。<br>【问题描述】 </p><p>​    你控制着 n 名高阶圣堂武士，方便起见标为 1,2,··· ,n。每名高阶圣堂武士 需要一定的灵能来战斗，每个人有一个灵能值 ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai 点灵能，ai 为负则表示这 名高阶圣堂武士还需要 −ai 点灵能才能到达最佳战斗状态）。现在系统赋予了 你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i ∈ [2,n−1]，若 ai ≥ 0 则其两旁的高阶圣堂武士，也就是 i−1、i + 1 这两名高阶圣堂武士会从 i 这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai &lt; 0 则其两旁的高阶圣堂武士， 也就是 i−1,i+1 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能。形 式化来讲就是 ai−1+ = ai,ai+1+ = ai,ai−= 2ai。 灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂 武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 maxn i=1|ai|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武 士的不稳定度最小。<br>【输入格式】<br>​    本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。 接下来依次输入每一组询问。 每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。 接下来一行包含 n 个数 a1,a2,··· ,an。<br>【输出格式】<br>​    输出 T 行。每行一个整数依次表示每组询问的答案。<br>【样例输入】 </p><p>3<br>3<br>5 -2 3<br>4<br>0 0 0 0<br>3<br>1 2 3</p><p>【样例输出】 </p><p>3<br>0<br>3</p><p>【样例说明】<br>    对于第一组询问： 对 2 号高阶圣堂武士进行传输操作后 a1 = 3，a2 = 2，a3 = 1。答案为 3。 </p><p>​    对于第二组询问： 这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。<br>【样例输入】</p><p>3<br>4<br>-1 -2 -3 7<br>4<br>2 3 4 -8<br>5<br>-1 -1 6 -1 -1</p><p>【样例输出】</p><p>5<br>7<br>4</p><p>【数据规模与约定】 </p><p>​    对于所有评测用例，T ≤3，3≤n≤300000，|ai|≤1e9。 评测时将使用 25 个评测用例测试你的程序，每个评测用例的限制如下：</p><p><img src="/2019/03/24/第十届蓝桥杯-C-B组/J.png" alt=""></p><p>注意：本题输入量较大请使用快速的读入方式。</p></blockquote><p>待补充 ……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;能力一般，水平有限。请多见谅。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;喜提河南省一等奖一枚！&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;A-组队&quot;&gt;&lt;a href=&quot;#A-组队&quot; class=&quot;headerlink&quot; title=&quot;A:组队&quot;&gt;&lt;/a&gt;A:组队&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本题总分：5 分&lt;/p&gt;
&lt;p&gt;​     作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员， 组成球队的首发阵容。 每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1 号位至 5 号位的评分之和最大可能是多少？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="蓝桥杯" scheme="https://boctorio.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>矩形面积并</title>
    <link href="https://boctorio.github.io/2019/03/22/%E7%9F%A9%E9%98%B5%E9%9D%A2%E7%A7%AF%E5%B9%B6/"/>
    <id>https://boctorio.github.io/2019/03/22/矩阵面积并/</id>
    <published>2019-03-22T00:14:15.000Z</published>
    <updated>2019-03-26T06:22:46.456Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：</p><blockquote><p>题目描述</p><p>平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。<a id="more"></a></p><p>输入</p><p>输入仅包含两行，每行描述一个矩形。 </p><p> 在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。</p><p>输出</p><p>输出仅包含一个实数，为交的面积，保留到小数后两位。 </p><p>样例输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">3</span> </span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>样例输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.00</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>两个矩形相交的情况总共有以下几种（可能有部分遗漏）：</p><p><img src="/2019/03/22/矩阵面积并/矩阵相交.png" alt=""></p><p>如果我们对所有的情况都进行分类讨论，那么代码写上百行是没问题的。</p><p>通过观察发现，每个相交的小矩形的四条边一定为两个大矩形的八条边中的四条。</p><p>再仔细观察的话，小矩形的每个方向的边都是两个大矩形同一个方向的两条边中的一条。</p><p>继续观察，小矩形每条边都是两个大矩形更靠近中心的两条边中的一条。</p><p>至此，我们就能够计算出小矩形的面积了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> l,r,u,d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">l=max( min(a[<span class="number">1</span>],a[<span class="number">3</span>]) , min(a[<span class="number">5</span>],a[<span class="number">7</span>]) );</span><br><span class="line">r=min( max(a[<span class="number">1</span>],a[<span class="number">3</span>]) , max(a[<span class="number">5</span>],a[<span class="number">7</span>]) );</span><br><span class="line"></span><br><span class="line">d=max( min(a[<span class="number">2</span>],a[<span class="number">4</span>]) , min(a[<span class="number">6</span>],a[<span class="number">8</span>]) );</span><br><span class="line">u=min( max(a[<span class="number">2</span>],a[<span class="number">4</span>]) , max(a[<span class="number">6</span>],a[<span class="number">8</span>]) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( r - l &lt;= <span class="number">0</span> || u - d &lt;= <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">"0.00\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,(r-l)*(u-d));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;p&gt;平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>四大dp系列--数位dp</title>
    <link href="https://boctorio.github.io/2019/03/21/%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E6%95%B0%E4%BD%8Ddp/"/>
    <id>https://boctorio.github.io/2019/03/21/四大dp系列-数位dp/</id>
    <published>2019-03-21T04:55:48.000Z</published>
    <updated>2019-04-17T03:49:18.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><p>(本文参考于 <a href="https://www.cnblogs.com/zbtrs/p/6106783.html" target="_blank" rel="noopener">大佬博客</a>)</p><p>数位dp是一种高速求解给定区间内符合一定条件的数的个数的算法。其基本思想为记忆化搜索。</p><p>数位dp一般应用于：<a id="more"></a></p><blockquote><ol><li><p>求出在给定区间[A,B]内，符合条件P(i)的数i的个数.</p></li><li><p>条件P(i)一般与数的大小无关，而与 <strong>数的组成</strong> 有关 </p></li></ol></blockquote><p>求解的基本步骤如下：</p><blockquote><ol><li><p>当我们求 [ 0 , 100000 ] 和 [ 100001 , 200000 ]中符合条件的数的个数时，我们只需要求出前一个区间符合条件的数的个数，后面的区间只需要使用前面计算出来的值就可以了。</p></li><li><p>以下面的 <strong>不含49</strong> 为例，当我们在求[ 49001 , 50000 ]符合条件的数的个数时，会有不符合条件的情况存在，因此我们需要对其值进行判断，即将这一部分的值省略掉，当把这部分去掉之后，我们再求出来[ 0 , 100000 ]中符合条件的数的个数。</p></li><li><p>如果 b 为 123456 ，如果我们仍然求解[100001,200000]的话就会出错，我们只能先求解[100000,120000]，然后再求解[120001,123000]，因此，我们还需要判断当前是否是数的上限。</p></li></ol></blockquote><h4 id="不含49"><a href="#不含49" class="headerlink" title="不含49"></a>不含49</h4><blockquote><p>求[ a , b ]中不包含49的数的个数。</p><p>1&lt;=a&lt;=b&lt;=1e9</p></blockquote><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">20</span>];<span class="comment">//储存每一位的值 </span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20</span>][<span class="number">2</span>];<span class="comment">//储存长度为length时符合条件的数的数量，两个数组分别表示 是4时 和 不是4时 的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> length,<span class="keyword">bool</span> is_4,<span class="keyword">bool</span> is_max)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果计算到最后一位，那么直接返回</span></span><br><span class="line"><span class="keyword">if</span>(length==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果不是数的上限并且之前计算过，这步就是记忆化最关键的一步</span></span><br><span class="line">    <span class="keyword">if</span>(!is_max &amp;&amp; dp[length][is_4]) <span class="keyword">return</span> dp[length][is_4];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,maxx=(is_max ? num[length]:<span class="number">9</span>);<span class="comment">//判断是否是上限，即判断当前位所能取到的值的范围</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxx;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(is_4 &amp;&amp; i==<span class="number">9</span>) <span class="keyword">continue</span>;<span class="comment">//上一位是4，这一位是9，那么就直接跳过</span></span><br><span class="line">cnt+=dfs(length<span class="number">-1</span>,i==<span class="number">4</span>,is_max &amp;&amp; i==maxx);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是上限，那么不能保存，因为dp保存的是[100000,200000]这样的值，并不能储存[100000,120000]的值</span></span><br><span class="line"><span class="keyword">return</span> is_max?cnt:dp[length][is_4]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">num[length++]=x%<span class="number">10</span>;</span><br><span class="line">x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dfs(length<span class="number">-1</span>,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(b)-solve(a<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是数位dp最基本的模板。</p><h4 id="不要62"><a href="#不要62" class="headerlink" title="不要62"></a>不要62</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2089" target="_blank" rel="noopener">不要62</a></p><p>题意很简单，求区间内不含 4 和 62 的数的个数。</p><p>这个代码和上面的代码几乎一样，只是中间加了一步判断 4 的步骤</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> length,<span class="keyword">int</span> is_6,<span class="keyword">bool</span> is_max)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!is_max &amp;&amp; dp[length][is_6]) <span class="keyword">return</span> dp[length][is_6];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxx=is_max?a[length]:<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxx;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(is_6 &amp;&amp; i==<span class="number">2</span>) <span class="keyword">continue</span>;<span class="comment">//不要62</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">4</span>) <span class="keyword">continue</span>; <span class="comment">//不要4</span></span><br><span class="line"></span><br><span class="line">cnt+=dfs(length<span class="number">-1</span>,i==<span class="number">6</span>,is_max &amp;&amp; i==maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!is_max) dp[length][is_6]=cnt;</span><br><span class="line"><span class="keyword">return</span> cnt; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">a[length++]=x%<span class="number">10</span>;</span><br><span class="line">x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dfs(length<span class="number">-1</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b) &amp;&amp; a+b)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(b)-solve(a<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只要13"><a href="#只要13" class="headerlink" title="只要13"></a>只要13</h4><blockquote><p>找出1~n范围内含有13并且能被13整除的数字的个数.</p></blockquote><p>这个题目条件比前两个复杂一点，我们需要计算出这个数字是否是13的倍数，并且是否包含13，所以，我们需要用两个变量来判断。</p><p>一个变量用来判断是否是13的倍数；另一个变量用来判断是否包含13。而判断13时有三种情况：</p><blockquote><ol><li>上一位不是 1 </li><li>上一位是 1 但这一位不是 3 </li><li>上一位是 1 且这一位是 3 </li></ol></blockquote><p>因此不能用 bool 类型数据判断是否包含13。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20</span>][<span class="number">20</span>][<span class="number">10</span>];<span class="comment">//三维表示：长度为 length ，模数为 mod , 是否包含 13</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> length,<span class="keyword">int</span> mod,<span class="keyword">int</span> have_13,<span class="keyword">bool</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length==<span class="number">-1</span>) <span class="keyword">return</span> mod==<span class="number">0</span> &amp;&amp; have_13==<span class="number">2</span>;<span class="comment">// 是 13 的倍数并且包含 13 </span></span><br><span class="line"><span class="keyword">if</span>(!limit &amp;&amp; dp[length][mod][have_13]) <span class="keyword">return</span> dp[length][mod][have_13];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxx=limit?a[length]:<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxx;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> next=have_13;</span><br><span class="line"><span class="comment">//这是为了寻找数是否包含13，当have_13==2,即找到13后，就不会进行下列判断 </span></span><br><span class="line"><span class="keyword">if</span>(have_13!=<span class="number">2</span> &amp;&amp; i!=<span class="number">1</span>) next=<span class="number">0</span>;<span class="comment">//没有特殊情况（尾数不是 1 或 13 ） </span></span><br><span class="line"><span class="keyword">if</span>(have_13!=<span class="number">2</span> &amp;&amp; i==<span class="number">1</span>) next=<span class="number">1</span>;<span class="comment">//尾数为1</span></span><br><span class="line"><span class="keyword">if</span>(have_13==<span class="number">1</span> &amp;&amp; i==<span class="number">3</span>) next=<span class="number">2</span>;<span class="comment">//后两位尾数为13</span></span><br><span class="line"></span><br><span class="line">cnt+=dfs(length<span class="number">-1</span>,(mod*<span class="number">10</span>+i)%<span class="number">13</span>,next,limit&amp;i==maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!limit) dp[length][mod][have_13]=cnt;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">a[length++]=n%<span class="number">10</span>;</span><br><span class="line">n/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dfs(length<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">solve(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面几个例题我们就可以看出，求解基本的数位dp的核心就是处理所需要判断的条件，上面三个代码大体框架都一样，只是在判断<strong>是否继续向下求解</strong>时有所不同，因此我们只要处理好需要判断的条件就能够做简单的数位dp问题。</p><p>部分数位dp题目以及题解：</p><p><a href="https://boctorio.com/2019/04/07/Mountain-Number-%E6%95%B0%E4%BD%8Ddp/" target="_blank" rel="noopener">Mountain Number</a></p><p><a href="https://boctorio.com/2019/04/12/Seven-Segment-Display/" target="_blank" rel="noopener">Seven Segment Display</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数位dp&quot;&gt;&lt;a href=&quot;#数位dp&quot; class=&quot;headerlink&quot; title=&quot;数位dp&quot;&gt;&lt;/a&gt;数位dp&lt;/h3&gt;&lt;p&gt;(本文参考于 &lt;a href=&quot;https://www.cnblogs.com/zbtrs/p/6106783.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;大佬博客&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;数位dp是一种高速求解给定区间内符合一定条件的数的个数的算法。其基本思想为记忆化搜索。&lt;/p&gt;
&lt;p&gt;数位dp一般应用于：&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="https://boctorio.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>四大dp系列--状压dp</title>
    <link href="https://boctorio.github.io/2019/03/19/%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E7%8A%B6%E5%8E%8Bdp/"/>
    <id>https://boctorio.github.io/2019/03/19/四大dp系列-状压dp/</id>
    <published>2019-03-19T02:51:57.000Z</published>
    <updated>2019-03-27T03:32:33.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h3><p>状态压缩dp，是一种将复杂的状态压缩成二进制数字的算法。</p><a id="more"></a><h4 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h4><p>我们来看一个经典的旅行商问题：</p><blockquote><p>给定一个n个顶点组成的带权有向图的距离矩阵d(i,j)(INF表示没有边)。要求从顶点0出发，经过每个顶点恰好一次后再回到顶点0。问所经过的边的总权重的最小值是多少？（来源于《挑战程序设计竞赛》）。</p><p>限制条件：</p><p>2&lt;=n&lt;=15</p><p>0&lt;=d(i,j)&lt;=1000</p></blockquote><p>所有可能的路线会有 (n-1)! 种结果，因此我们不能够使用暴力的方法求解，那么我们需要用高效的方法来求解。</p><p>假如我们对每个顶点编号。我们可以用一个数的二进制来表示走过的集合 <strong>S</strong> ：</p><blockquote><p>当n=5时，00000表示所有顶点均未走过，00001表示经过编号为0的顶点，10001表示经过第0和第4个顶点。11111表示经过所有的顶点。</p><p><strong>这样，我们就能使用2^n次方个数来表示出所有的状态。</strong></p><p>定义dp[S][v]：<strong>从v出发，访问剩余未访问过的节点所需要的最小花费</strong>。特别的，当S=2^n-1，v=0时,dp[S][v]=0。</p></blockquote><p>从dp[S][v]的定义，我们也可以看出如下递推式：<br>$$<br>dp[S][v]=min(dp[S∪{u}][u]+d[v][u]  | u∉S)<br>$$<br>其中u表示从v出发到达的下一个顶点。 S ∪ { u } 表示现在经过的所有顶点，由于是从 v 到 u ，所以当前的出发点也为u。d[v][u]表示从顶点 v 到顶点 u 的花费。</p><p>找出了递推式，我们就可以使用记忆化搜索的方式找出最小花费：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];<span class="comment">//储存地图信息，初始化为 INF </span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;maxn][maxn];<span class="comment">//记忆化搜索使用的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> S,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//当前走过的节点集合 S，出发顶点v </span></span><br><span class="line"><span class="keyword">if</span>(dp[S][v]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> dp[S][v];<span class="comment">//由于我们使用的是递归的方法，所以如果有解，储存的一定是最优的解 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(S==(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span> &amp;&amp; v==<span class="number">0</span>)&#123;<span class="comment">//访问过所有定点，并且回到最初起点0，那么在这个状态之后的花费一定是0，即不需要再有其他的花费 </span></span><br><span class="line"><span class="keyword">return</span> dp[S][v]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(S&gt;&gt;u&amp;<span class="number">1</span>))&#123;<span class="comment">//第u个节点未被访问 </span></span><br><span class="line">res=min(res,rec(S|<span class="number">1</span>&lt;&lt;u,u)+d[v][u]);<span class="comment">//递归 S|1&lt;&lt;u表示走过u之后的节点集合，因为是走到u，所以新的出发点也是u</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[S][v]=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));<span class="comment">//-1表示未被访问过 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rec(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于状压dp的特性，我们只能求解n比较小的情况，否则内存就会超限。</p><p>思考上述代码后，我们可以发现，每一个比较小的节点集合都是由比较大的节点集合计算出来的。即对于两个集合S( i ) ∈ S( j ) ，有 i &lt;= j 。我们在求S( i )时，需要先求出来S( j )的值。因此，我们也可以用循环的方法求解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">0</span>;S&lt;<span class="number">1</span>&lt;&lt;n;S++)&#123;</span><br><span class="line">fill(dp[S],dp[S]+n,INF);</span><br><span class="line">&#125;</span><br><span class="line">dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S=(<span class="number">1</span>&lt;&lt;n)<span class="number">-2</span>;S&gt;=<span class="number">0</span>;S--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(S&gt;&gt;u&amp;<span class="number">1</span>))&#123;</span><br><span class="line">dp[S][v]=min(dp[S][v],dp[S|<span class="number">1</span>&lt;&lt;u][u]+d[v][u]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是最基础的状压dp问题。</p><p>（内容持续更新……）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;状压dp&quot;&gt;&lt;a href=&quot;#状压dp&quot; class=&quot;headerlink&quot; title=&quot;状压dp&quot;&gt;&lt;/a&gt;状压dp&lt;/h3&gt;&lt;p&gt;状态压缩dp，是一种将复杂的状态压缩成二进制数字的算法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="https://boctorio.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>线段树基础模板</title>
    <link href="https://boctorio.github.io/2019/03/15/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"/>
    <id>https://boctorio.github.io/2019/03/15/线段树基础模板/</id>
    <published>2019-03-15T04:32:51.000Z</published>
    <updated>2019-03-28T07:42:03.627Z</updated>
    
    <content type="html"><![CDATA[<p>三个基本的线段树操作模板。</p><a id="more"></a><h4 id="线段树单点更新-查询区间最大值"><a href="#线段树单点更新-查询区间最大值" class="headerlink" title="线段树单点更新+查询区间最大值"></a>线段树单点更新+查询区间最大值</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="noopener">HDU1754</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> dat[maxn],n;</span><br><span class="line"><span class="keyword">int</span> m,a,b;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&lt;x) n*=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">dat[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">k+=n<span class="number">-1</span>;</span><br><span class="line">dat[k]=a;</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">k=(k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">dat[k]=max(dat[k*<span class="number">2</span>+<span class="number">1</span>],dat[k*<span class="number">2</span>+<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r&lt;a || b&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) <span class="keyword">return</span> dat[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> vl=query(a,b,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> vr=query(a,b,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">return</span> max(vl,vr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n_;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">n_=n;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n_;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dat[i+n<span class="number">-1</span>]);</span><br><span class="line">update(i,dat[i+n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c %d %d"</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(a<span class="number">-1</span>,b<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'U'</span>) update(a<span class="number">-1</span>,b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树区间更新"><a href="#线段树区间更新" class="headerlink" title="线段树区间更新"></a>线段树区间更新</h4><p><a href="http://acm.fzu.edu.cn/problem.php?pid=1608" target="_blank" rel="noopener">FZU1608</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,dat[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&lt;x) n*=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">dat[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&lt;l || r&lt;a) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) dat[k]=max(x,dat[k]);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> mmax)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> max(mmax,dat[k]);</span><br><span class="line">dat[k]=max(mmax,dat[k]);</span><br><span class="line"><span class="keyword">int</span> vl=query(l,(l+r)/<span class="number">2</span>,k*<span class="number">2</span>+<span class="number">1</span>,dat[k]);</span><br><span class="line"><span class="keyword">int</span> vr=query((l+r)/<span class="number">2</span>+<span class="number">1</span>,r,k*<span class="number">2</span>+<span class="number">2</span>,dat[k]);</span><br><span class="line"><span class="keyword">return</span> vl+vr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,x;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;x);</span><br><span class="line">update(a,b<span class="number">-1</span>,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树区间更新-区间求和"><a href="#线段树区间更新-区间求和" class="headerlink" title="线段树区间更新+区间求和"></a>线段树区间更新+区间求和</h4><p><a href="http://poj.org/problem?id=3468" target="_blank" rel="noopener">POJ3468</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll maxn=<span class="number">1000000</span>;</span><br><span class="line">ll dat[maxn],sum[maxn],n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll a,ll b,ll x,ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b)&#123;</span><br><span class="line">dat[k]+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l&lt;=b &amp;&amp; a&lt;=r)&#123;</span><br><span class="line">sum[k]+=(min(b,r)-max(a,l)+<span class="number">1</span>)*x;</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll a,ll b,ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&lt;l || r&lt;a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) <span class="keyword">return</span> dat[k]*(r-l+<span class="number">1</span>)+sum[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ll res=(min(b,r)-max(a,l)+<span class="number">1</span>)*dat[k];</span><br><span class="line">res+=query(a,b,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">res+=query(a,b,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll a,b,x;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">update(i,i,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'Q'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(a<span class="number">-1</span>,b<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;a,&amp;b,&amp;x);</span><br><span class="line">update(a<span class="number">-1</span>,b<span class="number">-1</span>,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三个基本的线段树操作模板。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="线段树" scheme="https://boctorio.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Boctorio&#39;s Blog</title>
  
  <subtitle>欢迎访问我校OJ   https://www.hpuoj.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://boctorio.github.io/"/>
  <updated>2019-04-01T02:23:30.049Z</updated>
  <id>https://boctorio.github.io/</id>
  
  <author>
    <name>Boctorio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第九届河南理工大学算法程序设计竞赛</title>
    <link href="https://boctorio.github.io/2019/03/31/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E6%B2%B3%E5%8D%97%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/"/>
    <id>https://boctorio.github.io/2019/03/31/第九届河南理工大学算法程序设计竞赛/</id>
    <published>2019-03-31T12:07:34.000Z</published>
    <updated>2019-04-01T02:23:30.049Z</updated>
    
    <content type="html"><![CDATA[<p>人外有人，外校的强者还是多。</p><a id="more"></a><h4 id="A-Asia区域赛"><a href="#A-Asia区域赛" class="headerlink" title="A.Asia区域赛"></a>A.Asia区域赛</h4><p>感谢组委会给我们学校举办区域赛的机会！</p><h4 id="B-Asia区域制"><a href="#B-Asia区域制" class="headerlink" title="B.Asia区域制"></a>B.Asia区域制</h4><p>二进制转16进制，<strong>四位二进制相当于一位16进制</strong>，直接按照定义模拟就可以了。</p><h4 id="C-Asia区域宫"><a href="#C-Asia区域宫" class="headerlink" title="C.Asia区域宫"></a>C.Asia区域宫</h4><p>题目有句话很重要：<strong>障碍物在迷宫中不能同行且不能同列</strong>，因此只要不是从左下角连到右上角（不一定非得是角落）把地图分成两份，那么就可以走到，并且不用走多余的步数。</p><p>所以我们只要统计每一斜线上的格子是否被填满，当  x1+y1=x2+y2时，这两个格子在同一斜线。</p><h4 id="D-Asia区域阵"><a href="#D-Asia区域阵" class="headerlink" title="D.Asia区域阵"></a>D.Asia区域阵</h4><p>确认过眼神，不是我的题。</p><p>这个题数据范围不大，但是复杂度较高。</p><p>我们枚举所有的起点（异矩阵的左上角），然后枚举异矩阵的行列大小。然后就可以慢慢求解。</p><p>我们在枚举异矩阵的列的时候，如果遇到了重复的字符，那么就直接结束，并且此时我们知道了列的最大值，因此我们可以<strong>更新列的范围</strong>。（当时应该就是因为这个超时了）</p><blockquote><p>对于 6 * 6 的矩阵</p><p>如果（红色为选中的异矩阵，黑色为重复字符）：</p><p><img src="/2019/03/31/第九届河南理工大学算法程序设计竞赛/1.png" alt=""></p><p>那么我们接下来最多就只能进行到：</p><p><img src="/2019/03/31/第九届河南理工大学算法程序设计竞赛/2.png" alt=""></p><p>列数是越来越小，不可能比之前的还大了。</p></blockquote><h4 id="E-Mo的游戏"><a href="#E-Mo的游戏" class="headerlink" title="E.Mo的游戏"></a>E.Mo的游戏</h4><p>也是模拟，注意一下每个字符第一次出现的情况就行了。</p><p>保存这个字符上一次出现的位置，然后根据现在这个位置和保存的上个位置的差值来进行求解。如果之前没有出现过这个字符，那么就跳过，不用计算。</p><h4 id="F-Mo的极限"><a href="#F-Mo的极限" class="headerlink" title="F.Mo的极限"></a>F.Mo的极限</h4><p>炒鸡大模拟，简直了。。。</p><p>因为多项式的格式为 kx^y ,所以我们找 k 和 y 时可以直接根据它们的相对位置来求解。</p><p>首先当然是确认k的正负，根据 k 前面的 + - 字符判断，然后再运算符之后就是 k 的值。</p><p>计算出 k 的值之后，k 和 y 之间相差了一个 x^ 因此把位置向后挪两位，就可以直接开始求 y 的值。</p><blockquote><p>坑1：每个项可能会抵消，所以要用数组存每个项的系数。</p><p>坑2：最后输出不能有1/-2这种情况，必须是-1/2。（我因为这个多wa了两次QAQ）</p><p>坑3：应该是没其他太大的坑了。</p></blockquote><h4 id="G-Mo的数学"><a href="#G-Mo的数学" class="headerlink" title="G.Mo的数学"></a>G.Mo的数学</h4><p>容斥定理+逆元。</p><p>这个如果直接用循环就会超时。</p><p>我们先预处理 1 ~ n 的阶乘，可以省下不少时间。</p><p>思路是：<strong>找出 n ! （n的阶乘）,然后除以不符合条件的数（不互质的数）。</strong></p><p>然后我们对 m 的因子进行处理，可以知道的是，如果m的质因子 a ，那么 a * x（x&gt;=0） 必然与 m 不互质，而且在 [ 1 , n ] 的范围内 a 的倍数相乘结果为$ f(a)=a^{n/a}*(n/a)! $  ，因为区间内 a 的倍数只有 n / a 个，然后就是<strong>容斥定理</strong>（容斥定理详见我之前的博客（<a href="https://boctorio.com/2019/01/09/%E7%AE%97%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86-%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86/" target="_blank" rel="noopener">算数基本定理+容斥定理</a>））。</p><p>但是在除以 f(a) 时，可能会出现除不尽的情况，因此需要用逆元来处理一下。</p><h4 id="H-Mo的面积"><a href="#H-Mo的面积" class="headerlink" title="H.Mo的面积"></a>H.Mo的面积</h4><p>做了第三遍了…详见之前的博客<a href="https://boctorio.com/2019/03/22/%E7%9F%A9%E9%98%B5%E9%9D%A2%E7%A7%AF%E5%B9%B6/" target="_blank" rel="noopener">矩阵面积并</a>。</p><h4 id="I-安全距离"><a href="#I-安全距离" class="headerlink" title="I.安全距离"></a>I.安全距离</h4><p>防AK题果然毒瘤。</p><p>二分适用于单调性的区间，由于这个题目球面是个弧线，并不是直线，因此需要用三分来求解。</p><p>然后我们就用三分的思想来求解。</p><h4 id="J-简单递归"><a href="#J-简单递归" class="headerlink" title="J.简单递归"></a>J.简单递归</h4><p>直接抄就完事了。</p><h4 id="K-高度期望"><a href="#K-高度期望" class="headerlink" title="K.高度期望"></a>K.高度期望</h4><p>贪心一发，能多加尽量多加。</p><p>选取尽量低的树，这样加的高度就更多。</p><h4 id="L-最优规划"><a href="#L-最优规划" class="headerlink" title="L.最优规划"></a>L.最优规划</h4><p>最小生成树裸题。</p><p>前m个路径长度不用管，直接把城镇相连。</p><p>之后s个用结构体保存，排序之后选择，然后并查集莽一发就过了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人外有人，外校的强者还是多。&lt;/p&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>菜鸡的天梯赛一日游</title>
    <link href="https://boctorio.github.io/2019/03/30/%E8%8F%9C%E9%B8%A1%E7%9A%84%E5%A4%A9%E6%A2%AF%E8%B5%9B%E4%B8%80%E6%97%A5%E6%B8%B8/"/>
    <id>https://boctorio.github.io/2019/03/30/菜鸡的天梯赛一日游/</id>
    <published>2019-03-30T10:01:05.000Z</published>
    <updated>2019-03-30T10:49:25.283Z</updated>
    
    <content type="html"><![CDATA[<p>省二，就这样吧。</p><p>毕竟不可控因素太多了，还是自己实力不够。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;省二，就这样吧。&lt;/p&gt;
&lt;p&gt;毕竟不可控因素太多了，还是自己实力不够。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>四大dp系列--区间dp</title>
    <link href="https://boctorio.github.io/2019/03/27/%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E5%8C%BA%E9%97%B4dp/"/>
    <id>https://boctorio.github.io/2019/03/27/四大dp系列-区间dp/</id>
    <published>2019-03-27T00:22:38.000Z</published>
    <updated>2019-03-27T03:31:19.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h3><p>区间dp有点道家的思想：一生二，二生三，三生万物。</p><p>区间dp的思想就是化繁为简，将大的区间化成两个小的区间，然后递推求解。</p><a id="more"></a><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p><a href="http://www.51nod.com/Challenge/Problem.html#!#problemId=1021" target="_blank" rel="noopener">石子归并</a></p><blockquote><p>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。</p><p>例如： 1 2 3 4，有不少合并方法</p><p>1 2 3 4 =&gt; 3 3 4(3) =&gt; 6 4(9) =&gt; 10(19)</p><p>1 2 3 4 =&gt; 1 5 4(5) =&gt; 1 9(14) =&gt; 10(24)</p><p>1 2 3 4 =&gt; 1 2 7(7) =&gt; 3 7(10) =&gt; 10(20)</p><p>括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。</p><p><strong>输入</strong></p><p>第1行：N（2 &lt;= N &lt;= 100)<br>第2 - N + 1：N堆石子的数量（1 &lt;= A[i] &lt;= 10000)</p><p><strong>输出</strong></p><p>输出最小合并代价</p><p><strong>输入样例</strong></p><p>4</p><p>1 2 3 4</p><p><strong>输出样例</strong></p><p>19</p></blockquote><p>这个是最经典的区间dp问题。</p><p>对于区间 [ i , j ] ，我们可以把它分成两个区间 [ i , k ] 和 [ k+1 , j ]，那么我们就可以通过这两个小区间的值来计算出大区间的值。</p><p>这是归并的过程（1,2,3,4为编号）：</p><blockquote><p><img src="/2019/03/27/四大dp系列-区间dp/1.png" alt=""></p><p><img src="/2019/03/27/四大dp系列-区间dp/2.png" alt=""></p><p><img src="/2019/03/27/四大dp系列-区间dp/3.png" alt=""></p><p><img src="/2019/03/27/四大dp系列-区间dp/4.png" alt=""></p></blockquote><p>可以发现的是，每次合并都是<strong>两个小区间合并成一个大区间</strong>，因此，我们只要计算出每个小区间所需要的最小花费，就能计算出合并后的大区间的最小花费。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];<span class="comment">//表示合并区间[i,j]的最小花费</span></span><br><span class="line"><span class="keyword">int</span> sum[maxn];<span class="comment">//从 1 ~ i 的和 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;<span class="comment">//计算长为len的区间的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="comment">//区间长为len,起点为i，终点为i+len-1</span></span><br><span class="line"><span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(j&gt;n) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;<span class="comment">//枚举所有的小区间 </span></span><br><span class="line">dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);<span class="comment">//sum[j]-sum[i-1]表示合并大区间[i,j]所需要添加的花费</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码的时间复杂度为O($n^3$)，当n比较大时就没办法在规定时间内求解。</p><p>这是我们就可以用<strong>四边形不等式</strong>（别问，问就是百度）来优化。当我们求解dp[ i , j - 1 ]时，我们可以记录最小花费的 k 的位置，即s[ i ][ j-1 ]=$k_1$。同样的，求解dp[ i + 1 ][ j ]时，我们也可以求出s[ i + 1 s][ j ] =$k_2$。</p><blockquote><p><strong>四边形不等式</strong></p><p>如果对于任意的a1≤a2&lt;b1≤b2，有m[ a1 , b1 ]+m[ a2 , b2 ]≤m[ a1 , b2 ]+m[ a2 , b1 ]，那么m[ i , j ]满足四边形不等式。</p><p>写成符合这篇博客的形式为：</p><p>如果对于任意的 i ≤ i + 1 &lt; j - 1 ≤ j ，有dp[ i , j-1 ]+dp[ i+1 , j ]≤dp[ i , j ]+dp[ i + 1 , j - 1 ]，那么m[ i , j ]满足四边形不等式。</p><p><a href="https://blog.csdn.net/noiau/article/details/72514812" target="_blank" rel="noopener">某聚的四边形不等式详细讲解</a></p></blockquote><p>从这个定理，我们可以推出区间 [ i ][ j ]所对应的 k 值在s[ i ][ j - 1 ] 和s[ i + 1 ][ j ] 之间，然后，我们又可以计算出s[ i ][ j ]，依次递推。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][i]=<span class="number">0</span>;</span><br><span class="line">s[i][i]=i;<span class="comment">//初始化 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(j&gt;n) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=s[i][j<span class="number">-1</span>];k&lt;=s[i+<span class="number">1</span>][j];k++)&#123;</span><br><span class="line"><span class="keyword">if</span>( dp[i][j] &gt; dp[i][k] + dp[k+<span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>])&#123;</span><br><span class="line">dp[i][j] = dp[i][k] + dp[k+<span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>];</span><br><span class="line">s[i][j]=k;<span class="comment">//记录最小花费对应的k值 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能把复杂度从O($ n^3 $)减少到O($ n^2 $)。</p><h4 id="Monkey-Party"><a href="#Monkey-Party" class="headerlink" title="Monkey Party"></a>Monkey Party</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3506" target="_blank" rel="noopener">HDU3506</a></p><p>这道题和石子归并相似，只是把线变成了环。我们只要把输入复制一遍放在第一次输入的后面就可以把环变成线来求解。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line"><span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>] + a[i-n];</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">    dp[i][i] = <span class="number">0</span>;</span><br><span class="line">    s[i][i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;n*<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=s[i][j<span class="number">-1</span>];k&lt;=s[i+<span class="number">1</span>][j];k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( dp[i][j] &gt; dp[i][k] + dp[k+<span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i][k] + dp[k+<span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>];</span><br><span class="line">                s[i][j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    ans = min( ans , dp[i][i+n<span class="number">-1</span>] );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;区间dp&quot;&gt;&lt;a href=&quot;#区间dp&quot; class=&quot;headerlink&quot; title=&quot;区间dp&quot;&gt;&lt;/a&gt;区间dp&lt;/h3&gt;&lt;p&gt;区间dp有点道家的思想：一生二，二生三，三生万物。&lt;/p&gt;
&lt;p&gt;区间dp的思想就是化繁为简，将大的区间化成两个小的区间，然后递推求解。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="https://boctorio.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>第十届蓝桥杯--C++-B组</title>
    <link href="https://boctorio.github.io/2019/03/24/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF-C-B%E7%BB%84/"/>
    <id>https://boctorio.github.io/2019/03/24/第十届蓝桥杯-C-B组/</id>
    <published>2019-03-24T13:27:25.000Z</published>
    <updated>2019-03-29T05:10:03.858Z</updated>
    
    <content type="html"><![CDATA[<p>能力一般，水平有限。请多见谅。</p><p><strong>喜提河南省一等奖一枚！</strong></p><h4 id="A-组队"><a href="#A-组队" class="headerlink" title="A:组队"></a>A:组队</h4><blockquote><p>本题总分：5 分</p><p>​     作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员， 组成球队的首发阵容。 每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1 号位至 5 号位的评分之和最大可能是多少？<a id="more"></a></p><p><img src="/2019/03/24/第十届蓝桥杯-C-B组/A.jpg" alt=""></p></blockquote><p>暴力解决一切！</p><p>答案：490。</p><h4 id="B-年号字串"><a href="#B-年号字串" class="headerlink" title="B:年号字串"></a>B:年号字串</h4><blockquote><p>本题总分：5 分<br>     小明用字母 A 对应数字 1，B 对应 2，以此类推，用 Z 对应 26。对于 27 以上的数字，小明用两位或更长位的字符串来对应，例如 AA 对应 27，AB 对 应 28，AZ 对应 52，LQ 对应 329。 请问 2019 对应的字符串是什么？</p></blockquote><p>不得不说，这个题遇见26居然还不进位！比赛最后我不得不手算……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">26</span>!=<span class="number">0</span>)&#123;<span class="comment">//所有位不能为0 </span></span><br><span class="line">out(n/<span class="number">26</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,n%<span class="number">26</span>+<span class="string">'A'</span><span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//如果为零，必须从高位借一位 </span></span><br><span class="line">out((n<span class="number">-26</span>)/<span class="number">26</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Z"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">2019</span>;</span><br><span class="line">out(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：BYQ。（算出BY的时候还激动了一下）</p><h4 id="C-数列求值"><a href="#C-数列求值" class="headerlink" title="C: 数列求值"></a>C: 数列求值</h4><blockquote><p>本题总分：10 分<br>    给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求 第 20190324 项的最后 4 位数字。</p></blockquote><p>一个 for 循环解决一切！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>,c=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=<span class="number">20190324</span>;i++)&#123;</span><br><span class="line">d=(a+b+c)%<span class="number">10000</span>;</span><br><span class="line">a=b;</span><br><span class="line">b=c;</span><br><span class="line">c=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：4659</p><h4 id="D-数的分解"><a href="#D-数的分解" class="headerlink" title="D: 数的分解"></a>D: 数的分解</h4><blockquote><p>本题总分：10 分<br>     把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包 含数字 2 和 4，一共有多少种不同的分解方法？ 注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。</p></blockquote><p>暴力杯名不虚传。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">10</span>==<span class="number">2</span> || x%<span class="number">10</span>==<span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2019</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="number">2019</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2019</span>-i-j&lt;=j) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(cal(i) &amp;&amp; cal(j) &amp;&amp; cal(<span class="number">2019</span>-i-j))&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案： 40785。</p><h4 id="E-迷宫"><a href="#E-迷宫" class="headerlink" title="E: 迷宫"></a>E: 迷宫</h4><blockquote><p>本题总分：15 分<br>    下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。</p><p>010000<br>000100<br>001001<br>110000</p><p>​    迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。 对于上面的迷宫，从入口开始，可以按 DRRURRDDDR 的顺序通过迷宫， 一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式， 其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。 请注意在字典序中D&lt;L&lt;R&lt;U。</p><p>01010101001011001001010110010110100100001000101010 00001000100000101010010000100000001001100110100101 01111011010010001000001101001011100011000000010000 01000000001010100011010000101000001010101011001011 00011111000000101000010010100010100000101100000000 11001000110101000010101100011010011010101011110111 00011011010101001001001010000001000101001110000000<br>10100000101000100110101010111110011000010000111010 00111000001010100001100010000001000101001100001001 11000110100001110010001001010101010101010001101000 00010000100100000101001010101110100010101010000101 11100100101001001000010000010101010100100100010100 00000010000000101011001111010001100000101010100011 10101010011100001000011000010110011110110100001000 10101010100001101010100101000010100000111011101001 10000000101100010000101100101101001011100000000100 10101001000000010100100001000100000100011110101001 00101001010101101001010100011010101101110000110101 11001010000100001100000010100101000001000111000010 00001000110000110101101000000100101001001000011101 10100101000101000000001110110010110101101010100001 00101000010000110101010000100010001001000100010101 10100001000110010001000010101001010101011111010010 00000100101000000110010100101001000001000000000010 11010000001001110111001001000011101001011011101000 00000110100010001000100000001000011101000000110011 10101000101000100010001111100010101001010000001000 10000010100101001010110000000100101010001011101000 00111100001000010000000110111000000001000000001011 10000001100111010111010001000110111010101101111000</p></blockquote><p>BFS+路径记忆，算是前面几道题唯一涉及算法的题目了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">30</span>,m=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> step[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//1：D 2:L 3: R 4: U </span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">vis[x][y]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;pi&gt;que;</span><br><span class="line">que.push(pi(x,y));</span><br><span class="line"><span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">x=que.front().first;</span><br><span class="line">y=que.front().second;</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> xx=x+d[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> yy=y+d[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(mp[xx][yy]==<span class="string">'0'</span> &amp;&amp; !vis[xx][yy] &amp;&amp; xx&gt;=<span class="number">0</span> &amp;&amp; xx&lt;n &amp;&amp; yy&gt;=<span class="number">0</span> &amp;&amp; yy&lt;m)&#123;</span><br><span class="line">vis[xx][yy]=<span class="number">1</span>;</span><br><span class="line">step[xx][yy]=i+<span class="number">1</span>;</span><br><span class="line">que.push(pi(xx,yy));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span> &amp;&amp; y==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(step[x][y]==<span class="number">1</span>)&#123;</span><br><span class="line">out(x<span class="number">-1</span>,y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"D"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(step[x][y]==<span class="number">2</span>)&#123;</span><br><span class="line">out(x,y+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"L"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(step[x][y]==<span class="number">3</span>)&#123;</span><br><span class="line">out(x,y<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"R"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">out(x+<span class="number">1</span>,y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"U"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]);</span><br><span class="line">&#125;</span><br><span class="line">bfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">out(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR</span><br></pre></td></tr></table></figure><h4 id="F-特别数的和"><a href="#F-特别数的和" class="headerlink" title="F: 特别数的和"></a>F: 特别数的和</h4><blockquote><p> 时间限制: 1.0s       内存限制: 256.0MB        本题总分：15 分</p><p>​    小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。 请问，在 1 到 n 中，所有这样的数的和是多少？<br>【输入格式】<br>​    输入一行包含一个整数 n。<br>【输出格式】<br>​    输出一行，包含一个整数，表示满足条件的数的和。<br>【样例输入】 </p><p>​    40<br>【样例输出】 </p><p>​    574<br>【评测用例规模与约定】 </p><p>​    对于 20% 的评测用例，1≤n≤10。 </p><p>​    对于 50% 的评测用例，1≤n≤100。 </p><p>​    对于 80% 的评测用例，1≤n≤1000。 </p><p>​    对于所有评测用例，1≤n≤10000。</p></blockquote><p>直接模拟就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">10</span>==<span class="number">2</span> || x%<span class="number">10</span>==<span class="number">0</span> || x%<span class="number">10</span>==<span class="number">1</span> || x%<span class="number">10</span>==<span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cal(i)) sum+=i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="G-完全二叉树的权值"><a href="#G-完全二叉树的权值" class="headerlink" title="G: 完全二叉树的权值"></a>G: 完全二叉树的权值</h4><blockquote><p>时间限制: 1.0s     内存限制: 256.0MB     本题总分：20 分<br>    给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从 上到下、从左到右的顺序依次是 A1, A2, ··· AN，如下图所示：</p><p><img src="/2019/03/24/第十届蓝桥杯-C-B组/G.png" alt=""></p><p>​    现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点 权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。 注：<strong>根的深度是 1</strong>。</p><p>【输入格式】<br>    第一行包含一个整数 N。 第二行包含 N 个整数 A1, A2, ··· AN 。<br>【输出格式】<br>    输出一个整数代表答案。</p><p>【样例输入】 </p><p>​    7 </p><p>​    1 6 5 4 3 2 1<br>【样例输出】 </p><p>​    2<br>【评测用例规模与约定】 </p><p>​    对于所有评测用例，1≤ N ≤100000，−100000≤ Ai ≤100000。</p></blockquote><p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。（来自百度百科）。</p><p>完全二叉树不是满二叉树，最后一层不一定全有节点，所以判断层数的时候要注意一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">ll a[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dep=<span class="number">1</span>;</span><br><span class="line">ll maxx=-INF;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&gt;=n) <span class="keyword">break</span>;<span class="comment">//上一次把所有数计算完毕</span></span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;<span class="comment">//每次加i个数,如果最后一层不满，+-0对结果不产生影响。 </span></span><br><span class="line">sum+=a[pos++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxx&lt;sum)&#123;</span><br><span class="line">maxx=sum;</span><br><span class="line">res=dep;</span><br><span class="line">&#125;</span><br><span class="line">i*=<span class="number">2</span>;</span><br><span class="line">dep++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="H-等差数列"><a href="#H-等差数列" class="headerlink" title="H: 等差数列"></a>H: 等差数列</h4><blockquote><p>时间限制: 1.0s     内存限制: 256.0MB     本题总分：20 分</p><p>​    数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一 部分的数列，只记得其中 N 个整数。 现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有 几项？</p><p>【输入格式】</p><p>​    输入的第一行包含一个整数 N。 第二行包含 N 个整数 A1,A2,··· ,AN。(注意 A1 ∼ AN 并不一定是按等差数 列中的顺序给出)</p><p>【输出格式】</p><p>​    输出一个整数表示答案。</p><p>【样例输入】 </p><p>​    5 </p><p>​    2 6 4 10 20</p><p>【样例输出】 </p><p>​    10</p><p>【样例说明】 </p><p>​    包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、 18、20。</p><p>【评测用例规模与约定】 </p><p>​    对于所有评测用例，2≤ N ≤100000，0≤ Ai ≤109。</p></blockquote><p>如果是等差数列，那么任意两个数的差值一定是公差的整数倍，因此我们只要找到最大的公差（GCD）就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> y?gcd(y,x%y):x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line"><span class="keyword">int</span> g=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">g=gcd(g,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(a[n<span class="number">-1</span>]-a[<span class="number">0</span>])/g+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="I-后缀表达式"><a href="#I-后缀表达式" class="headerlink" title="I: 后缀表达式"></a>I: 后缀表达式</h4><blockquote><p>时间限制: 1.0s     内存限制: 256.0MB     本题总分：25 分<br>    给定 N 个加号、M 个减号以及 N + M + 1 个整数 A1,A2,··· ,AN+M+1，小 明想知道在所有由这 N 个加号、M 个减号以及 N + M +1 个整数凑出的合法的 后缀表达式中，结果最大的是哪一个？<br>    请你输出这个最大的结果。 例如使用1 2 3 + -，则 “2 3 + 1 -” 这个后缀表达式结果是 4，是最大的。<br>【输入格式】<br>    第一行包含两个整数 N 和 M。 第二行包含 N + M + 1 个整数 A1,A2,··· ,AN+M+1。<br>【输出格式】<br>    输出一个整数，代表答案。<br>【样例输入】 </p><p>​    1 1 </p><p>​    1 2 3<br>【样例输出】 </p><p>​    4<br>【评测用例规模与约定】 </p><p>​    对于所有评测用例，0≤ N,M ≤100000，−109 ≤ Ai ≤109。</p></blockquote><p>待补充 ……</p><h4 id="J-灵能传输"><a href="#J-灵能传输" class="headerlink" title="J: 灵能传输"></a>J: 灵能传输</h4><blockquote><p>时间限制: 1.0s     内存限制: 256.0MB     本题总分：25 分<br>【题目背景】 </p><p>​    在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在 游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对 一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的 刺蛇飞龙等低血量单位。<br>【问题描述】 </p><p>​    你控制着 n 名高阶圣堂武士，方便起见标为 1,2,··· ,n。每名高阶圣堂武士 需要一定的灵能来战斗，每个人有一个灵能值 ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai 点灵能，ai 为负则表示这 名高阶圣堂武士还需要 −ai 点灵能才能到达最佳战斗状态）。现在系统赋予了 你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i ∈ [2,n−1]，若 ai ≥ 0 则其两旁的高阶圣堂武士，也就是 i−1、i + 1 这两名高阶圣堂武士会从 i 这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai &lt; 0 则其两旁的高阶圣堂武士， 也就是 i−1,i+1 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能。形 式化来讲就是 ai−1+ = ai,ai+1+ = ai,ai−= 2ai。 灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂 武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 maxn i=1|ai|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武 士的不稳定度最小。<br>【输入格式】<br>​    本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。 接下来依次输入每一组询问。 每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。 接下来一行包含 n 个数 a1,a2,··· ,an。<br>【输出格式】<br>​    输出 T 行。每行一个整数依次表示每组询问的答案。<br>【样例输入】 </p><p>3<br>3<br>5 -2 3<br>4<br>0 0 0 0<br>3<br>1 2 3</p><p>【样例输出】 </p><p>3<br>0<br>3</p><p>【样例说明】<br>    对于第一组询问： 对 2 号高阶圣堂武士进行传输操作后 a1 = 3，a2 = 2，a3 = 1。答案为 3。 </p><p>​    对于第二组询问： 这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。<br>【样例输入】</p><p>3<br>4<br>-1 -2 -3 7<br>4<br>2 3 4 -8<br>5<br>-1 -1 6 -1 -1</p><p>【样例输出】</p><p>5<br>7<br>4</p><p>【数据规模与约定】 </p><p>​    对于所有评测用例，T ≤3，3≤n≤300000，|ai|≤1e9。 评测时将使用 25 个评测用例测试你的程序，每个评测用例的限制如下：</p><p><img src="/2019/03/24/第十届蓝桥杯-C-B组/J.png" alt=""></p><p>注意：本题输入量较大请使用快速的读入方式。</p></blockquote><p>待补充 ……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;能力一般，水平有限。请多见谅。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;喜提河南省一等奖一枚！&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;A-组队&quot;&gt;&lt;a href=&quot;#A-组队&quot; class=&quot;headerlink&quot; title=&quot;A:组队&quot;&gt;&lt;/a&gt;A:组队&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本题总分：5 分&lt;/p&gt;
&lt;p&gt;​     作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员， 组成球队的首发阵容。 每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1 号位至 5 号位的评分之和最大可能是多少？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="蓝桥杯" scheme="https://boctorio.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>矩形面积并</title>
    <link href="https://boctorio.github.io/2019/03/22/%E7%9F%A9%E9%98%B5%E9%9D%A2%E7%A7%AF%E5%B9%B6/"/>
    <id>https://boctorio.github.io/2019/03/22/矩阵面积并/</id>
    <published>2019-03-22T00:14:15.000Z</published>
    <updated>2019-03-26T06:22:46.456Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：</p><blockquote><p>题目描述</p><p>平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。<a id="more"></a></p><p>输入</p><p>输入仅包含两行，每行描述一个矩形。 </p><p> 在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。</p><p>输出</p><p>输出仅包含一个实数，为交的面积，保留到小数后两位。 </p><p>样例输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">3</span> </span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>样例输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.00</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>两个矩形相交的情况总共有以下几种（可能有部分遗漏）：</p><p><img src="/2019/03/22/矩阵面积并/矩阵相交.png" alt=""></p><p>如果我们对所有的情况都进行分类讨论，那么代码写上百行是没问题的。</p><p>通过观察发现，每个相交的小矩形的四条边一定为两个大矩形的八条边中的四条。</p><p>再仔细观察的话，小矩形的每个方向的边都是两个大矩形同一个方向的两条边中的一条。</p><p>继续观察，小矩形每条边都是两个大矩形更靠近中心的两条边中的一条。</p><p>至此，我们就能够计算出小矩形的面积了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> l,r,u,d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">l=max( min(a[<span class="number">1</span>],a[<span class="number">3</span>]) , min(a[<span class="number">5</span>],a[<span class="number">7</span>]) );</span><br><span class="line">r=min( max(a[<span class="number">1</span>],a[<span class="number">3</span>]) , max(a[<span class="number">5</span>],a[<span class="number">7</span>]) );</span><br><span class="line"></span><br><span class="line">d=max( min(a[<span class="number">2</span>],a[<span class="number">4</span>]) , min(a[<span class="number">6</span>],a[<span class="number">8</span>]) );</span><br><span class="line">u=min( max(a[<span class="number">2</span>],a[<span class="number">4</span>]) , max(a[<span class="number">6</span>],a[<span class="number">8</span>]) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( r - l &lt;= <span class="number">0</span> || u - d &lt;= <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">"0.00\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,(r-l)*(u-d));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;p&gt;平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>四大dp系列--数位dp</title>
    <link href="https://boctorio.github.io/2019/03/21/%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E6%95%B0%E4%BD%8Ddp/"/>
    <id>https://boctorio.github.io/2019/03/21/四大dp系列-数位dp/</id>
    <published>2019-03-21T04:55:48.000Z</published>
    <updated>2019-03-27T03:31:29.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><p>(本文参考于 <a href="https://www.cnblogs.com/zbtrs/p/6106783.html" target="_blank" rel="noopener">大佬博客</a>)</p><p>数位dp是一种高速求解给定区间内符合一定条件的数的个数的算法。其基本思想为记忆化搜索。</p><p>数位dp一般应用于：<a id="more"></a></p><blockquote><ol><li><p>求出在给定区间[A,B]内，符合条件P(i)的数i的个数.</p></li><li><p>条件P(i)一般与数的大小无关，而与 <strong>数的组成</strong> 有关 </p></li></ol></blockquote><p>求解的基本步骤如下：</p><blockquote><ol><li><p>当我们求 [ 0 , 100000 ] 和 [ 100001 , 200000 ]中符合条件的数的个数时，我们只需要求出前一个区间符合条件的数的个数，后面的区间只需要使用前面计算出来的值就可以了。</p></li><li><p>以下面的 <strong>不含49</strong> 为例，当我们在求[ 49001 , 50000 ]符合条件的数的个数时，会有不符合条件的情况存在，因此我们需要对其值进行判断，即将这一部分的值省略掉，当把这部分去掉之后，我们再求出来[ 0 , 100000 ]中符合条件的数的个数。</p></li><li><p>如果 b 为 123456 ，如果我们仍然求解[100001,200000]的话就会出错，我们只能先求解[100000,120000]，然后再求解[120001,123000]，因此，我们还需要判断当前是否是数的上限。</p></li></ol></blockquote><h4 id="不含49"><a href="#不含49" class="headerlink" title="不含49"></a>不含49</h4><blockquote><p>求[ a , b ]中不包含49的数的个数。</p><p>1&lt;=a&lt;=b&lt;=1e9</p></blockquote><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">20</span>];<span class="comment">//储存每一位的值 </span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20</span>][<span class="number">2</span>];<span class="comment">//储存长度为length时符合条件的数的数量，两个数组分别表示 是4时 和 不是4时 的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> length,<span class="keyword">bool</span> is_4,<span class="keyword">bool</span> is_max)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果计算到最后一位，那么直接返回</span></span><br><span class="line"><span class="keyword">if</span>(length==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果不是数的上限并且之前计算过，这步就是记忆化最关键的一步</span></span><br><span class="line">    <span class="keyword">if</span>(!is_max &amp;&amp; dp[length][is_4]) <span class="keyword">return</span> dp[length][is_4];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,maxx=(is_max ? num[length]:<span class="number">9</span>);<span class="comment">//判断是否是上限，即判断当前位所能取到的值的范围</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxx;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(is_4 &amp;&amp; i==<span class="number">9</span>) <span class="keyword">continue</span>;<span class="comment">//上一位是4，这一位是9，那么就直接跳过</span></span><br><span class="line">cnt+=dfs(length<span class="number">-1</span>,i==<span class="number">4</span>,is_max &amp;&amp; i==maxx);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是上限，那么不能保存，因为dp保存的是[100000,200000]这样的值，并不能储存[100000,120000]的值</span></span><br><span class="line"><span class="keyword">return</span> is_max?cnt:dp[length][is_4]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">num[length++]=x%<span class="number">10</span>;</span><br><span class="line">x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dfs(length<span class="number">-1</span>,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(b)-solve(a<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是数位dp最基本的模板。</p><h4 id="不要62"><a href="#不要62" class="headerlink" title="不要62"></a>不要62</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2089" target="_blank" rel="noopener">不要62</a></p><p>题意很简单，求区间内不含 4 和 62 的数的个数。</p><p>这个代码和上面的代码几乎一样，只是中间加了一步判断 4 的步骤</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> length,<span class="keyword">int</span> is_6,<span class="keyword">bool</span> is_max)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!is_max &amp;&amp; dp[length][is_6]) <span class="keyword">return</span> dp[length][is_6];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxx=is_max?a[length]:<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxx;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(is_6 &amp;&amp; i==<span class="number">2</span>) <span class="keyword">continue</span>;<span class="comment">//不要62</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">4</span>) <span class="keyword">continue</span>; <span class="comment">//不要4</span></span><br><span class="line"></span><br><span class="line">cnt+=dfs(length<span class="number">-1</span>,i==<span class="number">6</span>,is_max &amp;&amp; i==maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!is_max) dp[length][is_6]=cnt;</span><br><span class="line"><span class="keyword">return</span> cnt; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">a[length++]=x%<span class="number">10</span>;</span><br><span class="line">x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dfs(length<span class="number">-1</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b) &amp;&amp; a+b)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(b)-solve(a<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只要13"><a href="#只要13" class="headerlink" title="只要13"></a>只要13</h4><blockquote><p>找出1~n范围内含有13并且能被13整除的数字的个数.</p></blockquote><p>这个题目条件比前两个复杂一点，我们需要计算出这个数字是否是13的倍数，并且是否包含13，所以，我们需要用两个变量来判断。</p><p>一个变量用来判断是否是13的倍数；另一个变量用来判断是否包含13。而判断13时有三种情况：</p><blockquote><ol><li>上一位不是 1 </li><li>上一位是 1 但这一位不是 3 </li><li>上一位是 1 且这一位是 3 </li></ol></blockquote><p>因此不能用 bool 类型数据判断是否包含13。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20</span>][<span class="number">20</span>][<span class="number">10</span>];<span class="comment">//三维表示：长度为 length ，模数为 mod , 是否包含 13</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> length,<span class="keyword">int</span> mod,<span class="keyword">int</span> have_13,<span class="keyword">bool</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length==<span class="number">-1</span>) <span class="keyword">return</span> mod==<span class="number">0</span> &amp;&amp; have_13==<span class="number">2</span>;<span class="comment">// 是 13 的倍数并且包含 13 </span></span><br><span class="line"><span class="keyword">if</span>(!limit &amp;&amp; dp[length][mod][have_13]) <span class="keyword">return</span> dp[length][mod][have_13];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxx=limit?a[length]:<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxx;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> next=have_13;</span><br><span class="line"><span class="comment">//这是为了寻找数是否包含13，当have_13==2,即找到13后，就不会进行下列判断 </span></span><br><span class="line"><span class="keyword">if</span>(have_13!=<span class="number">2</span> &amp;&amp; i!=<span class="number">1</span>) next=<span class="number">0</span>;<span class="comment">//没有特殊情况（尾数不是 1 或 13 ） </span></span><br><span class="line"><span class="keyword">if</span>(have_13!=<span class="number">2</span> &amp;&amp; i==<span class="number">1</span>) next=<span class="number">1</span>;<span class="comment">//尾数为1</span></span><br><span class="line"><span class="keyword">if</span>(have_13==<span class="number">1</span> &amp;&amp; i==<span class="number">3</span>) next=<span class="number">2</span>;<span class="comment">//后两位尾数为13</span></span><br><span class="line"></span><br><span class="line">cnt+=dfs(length<span class="number">-1</span>,(mod*<span class="number">10</span>+i)%<span class="number">13</span>,next,limit&amp;i==maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!limit) dp[length][mod][have_13]=cnt;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">a[length++]=n%<span class="number">10</span>;</span><br><span class="line">n/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dfs(length<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">solve(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面几个例题我们就可以看出，求解基本的数位dp的核心就是处理所需要判断的条件，上面三个代码大体框架都一样，只是在判断<strong>是否继续向下求解</strong>时有所不同，因此我们只要处理好需要判断的条件就能够做简单的数位dp问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数位dp&quot;&gt;&lt;a href=&quot;#数位dp&quot; class=&quot;headerlink&quot; title=&quot;数位dp&quot;&gt;&lt;/a&gt;数位dp&lt;/h3&gt;&lt;p&gt;(本文参考于 &lt;a href=&quot;https://www.cnblogs.com/zbtrs/p/6106783.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;大佬博客&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;数位dp是一种高速求解给定区间内符合一定条件的数的个数的算法。其基本思想为记忆化搜索。&lt;/p&gt;
&lt;p&gt;数位dp一般应用于：&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="https://boctorio.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>四大dp系列--状压dp</title>
    <link href="https://boctorio.github.io/2019/03/19/%E5%9B%9B%E5%A4%A7dp%E7%B3%BB%E5%88%97-%E7%8A%B6%E5%8E%8Bdp/"/>
    <id>https://boctorio.github.io/2019/03/19/四大dp系列-状压dp/</id>
    <published>2019-03-19T02:51:57.000Z</published>
    <updated>2019-03-27T03:32:33.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h3><p>状态压缩dp，是一种将复杂的状态压缩成二进制数字的算法。</p><a id="more"></a><h4 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h4><p>我们来看一个经典的旅行商问题：</p><blockquote><p>给定一个n个顶点组成的带权有向图的距离矩阵d(i,j)(INF表示没有边)。要求从顶点0出发，经过每个顶点恰好一次后再回到顶点0。问所经过的边的总权重的最小值是多少？（来源于《挑战程序设计竞赛》）。</p><p>限制条件：</p><p>2&lt;=n&lt;=15</p><p>0&lt;=d(i,j)&lt;=1000</p></blockquote><p>所有可能的路线会有 (n-1)! 种结果，因此我们不能够使用暴力的方法求解，那么我们需要用高效的方法来求解。</p><p>假如我们对每个顶点编号。我们可以用一个数的二进制来表示走过的集合 <strong>S</strong> ：</p><blockquote><p>当n=5时，00000表示所有顶点均未走过，00001表示经过编号为0的顶点，10001表示经过第0和第4个顶点。11111表示经过所有的顶点。</p><p><strong>这样，我们就能使用2^n次方个数来表示出所有的状态。</strong></p><p>定义dp[S][v]：<strong>从v出发，访问剩余未访问过的节点所需要的最小花费</strong>。特别的，当S=2^n-1，v=0时,dp[S][v]=0。</p></blockquote><p>从dp[S][v]的定义，我们也可以看出如下递推式：<br>$$<br>dp[S][v]=min(dp[S∪{u}][u]+d[v][u]  | u∉S)<br>$$<br>其中u表示从v出发到达的下一个顶点。 S ∪ { u } 表示现在经过的所有顶点，由于是从 v 到 u ，所以当前的出发点也为u。d[v][u]表示从顶点 v 到顶点 u 的花费。</p><p>找出了递推式，我们就可以使用记忆化搜索的方式找出最小花费：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];<span class="comment">//储存地图信息，初始化为 INF </span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;maxn][maxn];<span class="comment">//记忆化搜索使用的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> S,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//当前走过的节点集合 S，出发顶点v </span></span><br><span class="line"><span class="keyword">if</span>(dp[S][v]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> dp[S][v];<span class="comment">//由于我们使用的是递归的方法，所以如果有解，储存的一定是最优的解 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(S==(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span> &amp;&amp; v==<span class="number">0</span>)&#123;<span class="comment">//访问过所有定点，并且回到最初起点0，那么在这个状态之后的花费一定是0，即不需要再有其他的花费 </span></span><br><span class="line"><span class="keyword">return</span> dp[S][v]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(S&gt;&gt;u&amp;<span class="number">1</span>))&#123;<span class="comment">//第u个节点未被访问 </span></span><br><span class="line">res=min(res,rec(S|<span class="number">1</span>&lt;&lt;u,u)+d[v][u]);<span class="comment">//递归 S|1&lt;&lt;u表示走过u之后的节点集合，因为是走到u，所以新的出发点也是u</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[S][v]=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));<span class="comment">//-1表示未被访问过 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rec(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于状压dp的特性，我们只能求解n比较小的情况，否则内存就会超限。</p><p>思考上述代码后，我们可以发现，每一个比较小的节点集合都是由比较大的节点集合计算出来的。即对于两个集合S( i ) ∈ S( j ) ，有 i &lt;= j 。我们在求S( i )时，需要先求出来S( j )的值。因此，我们也可以用循环的方法求解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">0</span>;S&lt;<span class="number">1</span>&lt;&lt;n;S++)&#123;</span><br><span class="line">fill(dp[S],dp[S]+n,INF);</span><br><span class="line">&#125;</span><br><span class="line">dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S=(<span class="number">1</span>&lt;&lt;n)<span class="number">-2</span>;S&gt;=<span class="number">0</span>;S--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(S&gt;&gt;u&amp;<span class="number">1</span>))&#123;</span><br><span class="line">dp[S][v]=min(dp[S][v],dp[S|<span class="number">1</span>&lt;&lt;u][u]+d[v][u]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是最基础的状压dp问题。</p><p>（内容持续更新……）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;状压dp&quot;&gt;&lt;a href=&quot;#状压dp&quot; class=&quot;headerlink&quot; title=&quot;状压dp&quot;&gt;&lt;/a&gt;状压dp&lt;/h3&gt;&lt;p&gt;状态压缩dp，是一种将复杂的状态压缩成二进制数字的算法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="https://boctorio.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>线段树基础模板</title>
    <link href="https://boctorio.github.io/2019/03/15/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"/>
    <id>https://boctorio.github.io/2019/03/15/线段树基础模板/</id>
    <published>2019-03-15T04:32:51.000Z</published>
    <updated>2019-03-28T07:42:03.627Z</updated>
    
    <content type="html"><![CDATA[<p>三个基本的线段树操作模板。</p><a id="more"></a><h4 id="线段树单点更新-查询区间最大值"><a href="#线段树单点更新-查询区间最大值" class="headerlink" title="线段树单点更新+查询区间最大值"></a>线段树单点更新+查询区间最大值</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="noopener">HDU1754</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> dat[maxn],n;</span><br><span class="line"><span class="keyword">int</span> m,a,b;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&lt;x) n*=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">dat[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">k+=n<span class="number">-1</span>;</span><br><span class="line">dat[k]=a;</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">k=(k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">dat[k]=max(dat[k*<span class="number">2</span>+<span class="number">1</span>],dat[k*<span class="number">2</span>+<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r&lt;a || b&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) <span class="keyword">return</span> dat[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> vl=query(a,b,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> vr=query(a,b,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">return</span> max(vl,vr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n_;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">n_=n;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n_;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dat[i+n<span class="number">-1</span>]);</span><br><span class="line">update(i,dat[i+n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c %d %d"</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(a<span class="number">-1</span>,b<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'U'</span>) update(a<span class="number">-1</span>,b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树区间更新"><a href="#线段树区间更新" class="headerlink" title="线段树区间更新"></a>线段树区间更新</h4><p><a href="http://acm.fzu.edu.cn/problem.php?pid=1608" target="_blank" rel="noopener">FZU1608</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,dat[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&lt;x) n*=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">dat[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&lt;l || r&lt;a) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) dat[k]=max(x,dat[k]);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> mmax)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> max(mmax,dat[k]);</span><br><span class="line">dat[k]=max(mmax,dat[k]);</span><br><span class="line"><span class="keyword">int</span> vl=query(l,(l+r)/<span class="number">2</span>,k*<span class="number">2</span>+<span class="number">1</span>,dat[k]);</span><br><span class="line"><span class="keyword">int</span> vr=query((l+r)/<span class="number">2</span>+<span class="number">1</span>,r,k*<span class="number">2</span>+<span class="number">2</span>,dat[k]);</span><br><span class="line"><span class="keyword">return</span> vl+vr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,x;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;x);</span><br><span class="line">update(a,b<span class="number">-1</span>,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树区间更新-区间求和"><a href="#线段树区间更新-区间求和" class="headerlink" title="线段树区间更新+区间求和"></a>线段树区间更新+区间求和</h4><p><a href="http://poj.org/problem?id=3468" target="_blank" rel="noopener">POJ3468</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll maxn=<span class="number">1000000</span>;</span><br><span class="line">ll dat[maxn],sum[maxn],n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll a,ll b,ll x,ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b)&#123;</span><br><span class="line">dat[k]+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l&lt;=b &amp;&amp; a&lt;=r)&#123;</span><br><span class="line">sum[k]+=(min(b,r)-max(a,l)+<span class="number">1</span>)*x;</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">update(a,b,x,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll a,ll b,ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&lt;l || r&lt;a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a&lt;=l &amp;&amp; r&lt;=b) <span class="keyword">return</span> dat[k]*(r-l+<span class="number">1</span>)+sum[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ll res=(min(b,r)-max(a,l)+<span class="number">1</span>)*dat[k];</span><br><span class="line">res+=query(a,b,k*<span class="number">2</span>+<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">res+=query(a,b,k*<span class="number">2</span>+<span class="number">2</span>,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll a,b,x;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">update(i,i,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'Q'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(a<span class="number">-1</span>,b<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;a,&amp;b,&amp;x);</span><br><span class="line">update(a<span class="number">-1</span>,b<span class="number">-1</span>,x,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三个基本的线段树操作模板。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="线段树" scheme="https://boctorio.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第六届Code+程序设计网络挑战赛-COORDINATE</title>
    <link href="https://boctorio.github.io/2019/03/12/%E7%AC%AC%E5%85%AD%E5%B1%8ACode-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BD%91%E7%BB%9C%E6%8C%91%E6%88%98%E8%B5%9B-COORDINATE/"/>
    <id>https://boctorio.github.io/2019/03/12/第六届Code-程序设计网络挑战赛-COORDINATE/</id>
    <published>2019-03-12T01:54:20.000Z</published>
    <updated>2019-03-26T06:25:23.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><strong>题目描述</strong></p><p>在视频编码中，往往需要将一帧画面分块。</p><p>为了简化问题，我们考虑将一幅图片看作 $2^n ​$ * $ 2^n ​$的网格。为了对图片进行处理，编码器往往会遍历每个格子，但遍历格子的方式在不同的应用中是不同的。</p><a id="more"></a><p>其中一种方式叫做光栅遍历，就是按照从左到右，从上到下的顺序依次进行标号。下图是一个 8×8 的例子：</p><p><img src="/2019/03/12/第六届Code-程序设计网络挑战赛-COORDINATE/R.jpeg" alt=""></p><p>  另一种方式叫做 Z 字型遍历。先看一个 8×8 的例子：</p><p><img src="/2019/03/12/第六届Code-程序设计网络挑战赛-COORDINATE/z.jpg" alt=""></p><p>可以构造性的给出描述：</p><p>1.对于$2^0 $ * $ 2^0 ​$的网格，直接遍历</p><p>2.对于$2^k $ * $ 2^k $ (k&gt;0)的网格，将其横着从中间、竖着从中间各分成两半，形成4个$2^{k-1} $ * $ 2^{k-1} ​$的方格，这四个方格按照左上、右上、左下、右下的顺序依次遍历。</p><p><strong>输入格式</strong></p><p>输入的第一行为两个整数 <em>n</em>,<em>m</em> ,$2^n​$ 为矩形的边长，<em>m</em> 为询问次数。</p><p>接下来 <em>m</em> 行，每行是一个询问，询每个询问给出一个方格，方式有两种，如下：</p><ul><li>Z <em>x</em> 给出 Z 字形遍历中标号是 <em>x</em> 的方格。</li><li>R <em>x</em> 给出光栅遍历中标号是 <em>x</em> 的方格。</li></ul><p>保证存在标号为x的方格。</p><p><strong>输出格式</strong></p><p>对于每种询问，请输出一行一个正整数，表示在另一种遍历方式中，给出格子的标号。</p><p><strong>样例输入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">Z 37</span><br><span class="line">R 37</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">35</span><br><span class="line">49</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>从题意可知，我们需要找到与输入的排列方格序号位置对应的另一张排列方格位置序号。</p><p>我们先从输入R出发进行计算</p><h4 id="输入-R-x"><a href="#输入-R-x" class="headerlink" title="输入 R x"></a>输入 R x</h4><p>比如样例R 37，我们可以从题面的图片看出，它所对应的位置为第 4 行第 5 列（初始为第0行第0列，，以下缩写为（x,y））。</p><p>我们观察Z遍历可发现，如果我们把方格分成四个小方格，每个方格大小一样，每个位置所对应的值的差是一个值的整数倍。比如对于 49 和 33 ，33 和 17 ，17 和 1 ，他们在小方格中位置相同，差值均为小方格的大小（$ 2^n $ * $ 2^n $ / 4），<strong>因此，我们可以根据每个数字所在的方格位置，判断它所在的方格，从而算出它对应的值</strong>。</p><p>比如，对于（ 4 , 5 ），我们可以看出他所在的方块为第四块（小方块按遍历顺序编号1234），因此我们可以知道在Z中它的值 n &gt;=（$ 2^n $ * $ 2^n $ / 4）* 3 ,<strong>所以我们先保存这一部分值，然后将其对应到第一个方格所对应的位置（即行和列均减去边长的一半）</strong>，因为我们已经将它放在了第一个方格，其他三个方格已经没有作用了，因此我们可以将边长减小为现在的一半。然后重复此步操作。</p><p>一次操作后，大方格的已经变成了</p><p><img src="/2019/03/12/第六届Code-程序设计网络挑战赛-COORDINATE/小方格-4.jpg" alt=""></p><p>而( 4 , 5 )现在所对应的位置为（ 0 ，1），再分成四个小方格后在第一个方格，因此对行和列不操作，边长再减小一半。</p><p>现在，他的所对应的位置依然为（ 0 , 1 ）现在的大方格为</p><p><img src="/2019/03/12/第六届Code-程序设计网络挑战赛-COORDINATE/小方格-2.jpg" alt=""></p><p>所在小方格编号为2，因此列数减去当前边长的一半，保存当前面积（$ 2^1 $ * $ 2^1 ​$ / 4 * 1）。此时，它的坐标已经变成了（0 ，0），计算结束。</p><p>上面进行了三次操作，其大致顺序为：</p><blockquote><p>1.找到坐标对应的小方格编号。</p><p>2.把当前坐标移动到第一个小方格，记录移动所改变的值。</p><p>3.重复步骤1,2，直到坐标变为（0 , 0）。</p><p>4.输出总的改变的值。</p></blockquote><p>比如上面的（ 4 , 5 ），我们三次操作保存的值为$ 2^3 $ * $ 2^3 $ / 4 * 3 = 48 ；0 ； $2^1 $ * $ 2^1 $ / 4 * 1 = 1。加起来的值为49，即最终答案。</p><p>这就是输入为R时的计算方法。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ll i=x/line; <span class="comment">//当前所在行</span></span><br><span class="line">ll j=x%line; <span class="comment">//当前所在列</span></span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line">ll l=line*line/<span class="number">4</span>; <span class="comment">//line为边长，l为一个小方格的面积</span></span><br><span class="line">ll fen=line/<span class="number">2</span>; <span class="comment">//fen为每个小方格的边长</span></span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span> || j&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=fen &amp;&amp; i&lt;fen)&#123; <span class="comment">//表示在第二个小方格</span></span><br><span class="line">j-=fen; <span class="comment">//</span></span><br><span class="line">res+=l; <span class="comment">//储存当前操作所改变的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=fen &amp;&amp; j&lt;fen)&#123; <span class="comment">//表示在第三个小方格</span></span><br><span class="line">i-=fen;</span><br><span class="line">res+=l*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=fen &amp;&amp; j&gt;=fen)&#123; <span class="comment">//表示在第四个小方格</span></span><br><span class="line">i-=fen;</span><br><span class="line">j-=fen;</span><br><span class="line">res+=l*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">fen/=<span class="number">2</span>;<span class="comment">//将方块边长缩为原来的1/2,面积缩为原来的1/4</span></span><br><span class="line">l/=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br></pre></td></tr></table></figure><h4 id="输入Z-x"><a href="#输入Z-x" class="headerlink" title="输入Z x"></a>输入Z x</h4><p>输入R时是根据行和列判断最终值，而输入Z时正好相反，<strong>根据x的值判断所在行和列</strong>。</p><p>我们如果知道x的大小，就可以判断它所在的小方格编号，因此也可以层层求出行和列的值。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ll sumx=<span class="number">0</span>,sumy=<span class="number">0</span>; <span class="comment">//储存行和列</span></span><br><span class="line">l=line*line/<span class="number">4</span>; <span class="comment">//同上</span></span><br><span class="line">ll fen=line/<span class="number">2</span>; <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(x/l==<span class="number">1</span>)&#123;<span class="comment">//根据值可判断出所在的小方格，从而判断出行和列应该加的值</span></span><br><span class="line">sumy+=fen;</span><br><span class="line">x-=l;<span class="comment">//减去对应的值，即上面的将坐标移动到第一个小方格</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x/l==<span class="number">2</span>)&#123;</span><br><span class="line">sumx+=fen;</span><br><span class="line">x-=l*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x/l==<span class="number">3</span>)&#123;</span><br><span class="line">sumx+=fen;</span><br><span class="line">sumy+=fen;</span><br><span class="line">x-=l*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">fen/=<span class="number">2</span>; <span class="comment">//同上</span></span><br><span class="line">l/=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以求出所有的值了。</p><p>完整代码如下（做题时提交代码）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n,m;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line">ll x;</span><br><span class="line">ll i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;m);</span><br><span class="line">ll line=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) line*=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//printf("%lld %lld",line,(ll)pow(2,n));</span></span><br><span class="line"><span class="comment">//  当时使用pow()提交wa了一次，改后ac了，可能精度有问题 </span></span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">ll l;</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c %lld"</span>,&amp;op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'Z'</span>)&#123;</span><br><span class="line">ll sumx=<span class="number">0</span>,sumy=<span class="number">0</span>;</span><br><span class="line">l=line*line/<span class="number">4</span>;</span><br><span class="line">ll fen=line/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(x/l==<span class="number">1</span>)&#123;</span><br><span class="line">sumy+=fen;</span><br><span class="line">x-=l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x/l==<span class="number">2</span>)&#123;</span><br><span class="line">sumx+=fen;</span><br><span class="line">x-=l*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x/l==<span class="number">3</span>)&#123;</span><br><span class="line">sumx+=fen;</span><br><span class="line">sumy+=fen;</span><br><span class="line">x-=l*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">fen/=<span class="number">2</span>;</span><br><span class="line">l/=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sumx*line+sumy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'R'</span>)&#123;</span><br><span class="line">i=x/line;</span><br><span class="line">j=x%line;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line">l=line*line/<span class="number">4</span>;</span><br><span class="line">ll fen=line/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span> || j&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=fen &amp;&amp; i&lt;fen)&#123;</span><br><span class="line">j-=fen;</span><br><span class="line">res+=l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=fen &amp;&amp; j&lt;fen)&#123;</span><br><span class="line">i-=fen;</span><br><span class="line">res+=l*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=fen &amp;&amp; j&gt;=fen)&#123;</span><br><span class="line">i-=fen;</span><br><span class="line">j-=fen;</span><br><span class="line">res+=l*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">fen/=<span class="number">2</span>;</span><br><span class="line">l/=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在视频编码中，往往需要将一帧画面分块。&lt;/p&gt;
&lt;p&gt;为了简化问题，我们考虑将一幅图片看作 $2^n ​$ * $ 2^n ​$的网格。为了对图片进行处理，编码器往往会遍历每个格子，但遍历格子的方式在不同的应用中是不同的。&lt;/p&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>C++常见STL</title>
    <link href="https://boctorio.github.io/2019/03/04/C-%E5%B8%B8%E8%A7%81STL/"/>
    <id>https://boctorio.github.io/2019/03/04/C-常见STL/</id>
    <published>2019-03-04T11:54:44.000Z</published>
    <updated>2019-03-26T06:29:07.110Z</updated>
    
    <content type="html"><![CDATA[<p>学识浅薄，下面写的只是一小部分STL比较浅显的使用方法，不对其内部运行规则进行讨论，只对平时做题可能用到的功能进行讲解。</p><a id="more"></a><h3 id="using-namespace-std"><a href="#using-namespace-std" class="headerlink" title="using namespace std"></a>using namespace std</h3><p>namespace是指标识符的各种可见范围。命名空间用关键字namespace 来定义。命名空间是C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;......&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;......&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;......&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//一般写在标准函数库后面</span></span><br></pre></td></tr></table></figure><p>std是一个命名空间，使用这句的主要原因是处理程序中的命名冲突。</p><blockquote><p>命名空间是用来组织和重用代码的。如同名字一样的意思，NameSpace（名字空间），之所以出来这样一个东西，是因为人类可用的单词数太少，并且不同的人写的程序不可能所有的变量都没有重名现象，对于库来说，这个问题尤其严重，如果两个人写的库文件中出现同名的变量或函数(不可避免)，使用起来就有问题了。为了解决这个问题，引入了名字空间这个概念，通过使用 namespace xxx；你所使用的库函数或变量就是在该名字空间中定义的，这样一来就不会引起不必要的冲突了。</p></blockquote><p>通俗来说，我们使用的scanf()，printf()是来自于&lt;stdio.h&gt;函数库,pow()是来自&lt;math.h&gt;函数库等等。函数库是开发人员写的，但是我们在调用函数时可能会遇到两个函数库里面有名字重复了，因此我们使用了命名空间开区分重复的变量名称的所在空间。</p><p>比如接下来要讲的vector,英文释义为“矢量”（显而易见一个非常容易用到的词）。这个词会有很多开发人员使用，我们现在使用vector是在std命名空间内的，因此如果不在前面写using namespace std的话，那我们就得这样使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个会报错:[Error] 'vector' does not name a type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;<span class="comment">//这个形式前半部分为数据类型，后半部分为定义的变量。相当于平时用的 int n;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然而下面这个就不会报错</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec;<span class="comment">//这是不用写using namespace std;的写法。使用std的方式，但其长度明显变长，可读性明显下降。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在程序开头写上using namespace std;是最好的选择，接下来讲的<strong>STL(Standard Template Library, 标准模板库)</strong>也是基于其基础上。</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>头文件：#include\<vector></vector></p><p>vector 与数组相比最大的优点是可以根据需要动态的分配内存。对于<strong>图的储存</strong>（有向图，无向图）有非常大的作用。在一般题目中，图的顶点数大约为$$10^5​$$左右，所有边总共有$$n*(n-1)/2​$$个，因此如果用二维数组储存边，那么一定会内存超限。</p><p>而vector就没有这个缺点，vector根据输入的边的数量可以动态的分配内存（一般题目输入边的数量也在$$10^6​$$以下），这样，就可以很容易的储存图。而且在查找时，还会节约许多时间。</p><h4 id="vector的存储方式"><a href="#vector的存储方式" class="headerlink" title="vector的存储方式"></a>vector的存储方式</h4><p>接下来看二维数组和vector的对比：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec[maxn];<span class="comment">//定义一维vector数组</span></span><br><span class="line"><span class="keyword">int</span> m[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> u,v,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//二维数组直接分配maxn*maxn的内存，在输入时不需要再分配内存。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">a[u][v]=<span class="number">1</span>;<span class="comment">//表示两个顶点之间有一条边 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//一维vector数组输入时动态分配内存，内存大小最大只为m,要远远小于maxn*maxn</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">vec[u].push_back(v);<span class="comment">//表示u连接向v </span></span><br><span class="line">vec[v].push_back(u);<span class="comment">//根据有向图和无向图选择是否添加这一句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在一般情况下，使用vector存图是非常节省内存的方法。</p><h4 id="vector的使用"><a href="#vector的使用" class="headerlink" title="vector的使用"></a>vector的使用</h4><p>输入之后，边以数组的形式保存，使用时可以这样操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec[x].size();i++)&#123;<span class="comment">//x为节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,vec[x][i]);<span class="comment">//这段代码作用为输出与节点x相连的所有节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相同作用下二维数组的操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[x][i]==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);<span class="comment">//对所有节点进行判断，如果相连则输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的vec[x].size()表示输入时保存的与x相连的节点的数量。这个相比二维数组优点在于可以不用遍历那些没有边连接的节点，节省了大量的时间。</p><p>因此不管是在时间还是空间上，vector都优于二维数组。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>头文件：#include\<map></map></p><p>map 是一种容器，用来存储若干元素，这些元素都是由<strong>关键值和映射值 </strong> 配对组成的。</p><p>简而言之，map里面的元素都有一定的映射关系。</p><p>map的基本应用形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;<span class="comment">//一个整数对应一个整数</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;<span class="comment">//一个字符对应一个整数</span></span><br></pre></td></tr></table></figure><h4 id="map的存储方式"><a href="#map的存储方式" class="headerlink" title="map的存储方式"></a>map的存储方式</h4><p>接下来看它们的存储方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//输入n个数，每个数出现的次数进行统计 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">mp[x]++;<span class="comment">//mp[x]中， x代表上面的第一个int;mp[x]的值即为第二个int，初始值为0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;mp2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//输入n个字符，每个字符出现的次数进行统计</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;s);</span><br><span class="line">mp2[s]++;<span class="comment">//mp2[s]中， s代表上面的第一个char;mp2[x]的值即为第二个int，初始值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map的使用"><a href="#map的使用" class="headerlink" title="map的使用"></a>map的使用</h4><p>使用就是直接使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,mp[a]);<span class="comment">//输出数字a出现的次数</span></span><br></pre></td></tr></table></figure><p>因此，map主要作用就是<strong>计数（数字的个数、字符的个数、字符串的个数都可以计算）</strong>，map&lt;…,…&gt;中，前面是记的元素，就像是数学函数f(x)中的x，后面一个数据类型，就是函数f(x)中的f(x)。</p><p>接下来看一个示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入n,m。表示输入n个数</span></span><br><span class="line"><span class="comment">接下来m次询问，每次输入一个数，输出这个数出现的次数 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">int</span> n,m,x,a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">mp[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mp[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于map中其他元素的计数方式可以下去自行进行探索。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set的内部结构和map类似，set的主要作用是对输入的元素进行<strong>去重和排序</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;se;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">se.insert(x);<span class="comment">//向se中插入x</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=se.begin();it!=se.end();it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">iterator是STL中的迭代器，其主要功能为遍历形如vector ,map,set等数据结构的所有元素 </span></span><br><span class="line"><span class="comment">迭代器是一种检查容器内元素并遍历元素的数据类型。C++更趋向于使用迭代器而不是下标操作，</span></span><br><span class="line"><span class="comment">因为标准库为每一种标准容器（如vector）定义了一种迭代器类型，而只用少数容器（如vector）支持下标操作访问容器元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个输出就是输入的元素<strong>去重过后的升序序列</strong>。</p><p>接下来说几个set中常用操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面几个使用比较多，需要掌握</span></span><br><span class="line">se.insert()<span class="comment">//插入操作</span></span><br><span class="line">se.begin()<span class="comment">//返回指向第一个元素的迭代器</span></span><br><span class="line">se.end()<span class="comment">//返回指向最后一个元素的迭代器</span></span><br><span class="line">se.empty()<span class="comment">//检查se是否为空，空的话返回true，非空的话返回false</span></span><br><span class="line">se.clear()<span class="comment">//清空所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这些用的不多，可以了解了解</span></span><br><span class="line">se.count() 返回某个值元素的个数</span><br><span class="line">se.erase() 删除集合中的元素</span><br><span class="line">se.find() 返回一个指向被查找到元素的迭代器</span><br><span class="line">se.max_size() 返回集合能容纳的元素的最大限值</span><br><span class="line">se.size() 集合中元素的数目</span><br><span class="line">se.swap() 交换两个集合变</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学识浅薄，下面写的只是一小部分STL比较浅显的使用方法，不对其内部运行规则进行讨论，只对平时做题可能用到的功能进行讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>时间复杂度的计算及其他补充知识</title>
    <link href="https://boctorio.github.io/2019/03/03/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%8F%8A%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
    <id>https://boctorio.github.io/2019/03/03/时间复杂度的计算及其他补充知识/</id>
    <published>2019-03-03T04:51:18.000Z</published>
    <updated>2019-03-26T06:13:02.844Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。<br>计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。<strong>时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数</strong>。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。（来自百度百科）</p><a id="more"></a><p>时间复杂度最重要的一句话也就是上面加粗的这一句。</p><p>我们学习算法的目的就是使用算法使解决问题的时间复杂度尽量的小，就对于排序算法来说，排序有许多种方法，对于初学者来说，最简单的就是冒泡排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> temp,n;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> - j; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看出，两层循环的情况下，里面的 if()语句总共运行了n*(n-1)/2次。展开最高项次数为2,因此时间复杂度为O(n^2)。</p><p>再看一个判断质数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="comment">//时间复杂度O(n) 从定义出发：因子只有1和其本身，因此循环判断是否有其他因子</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==n) <span class="built_in">printf</span>(<span class="string">"is prime\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"isn't prime\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度O(√n) 从因子的角度出发，如果在√n之前没有其他因子，那么之后也不会再有了</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==n) <span class="built_in">printf</span>(<span class="string">"is prime\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"isn't prime\n"</span>);</span><br></pre></td></tr></table></figure><p>上面就是两个判断质数的时间复杂度的区别。</p><p><strong>注意：上述循环中的结束条件( i &lt; n , i * i &lt;=n ) 均与 n 的值有关，在计算复杂度时，我们一般只考虑输入的值对代码时间的影响，</strong>比如如下面几个代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个代码的时间复杂度均为O(1)，<strong>因为不管输入为任何值，对这一部分代码的运算不会有任何影响。</strong></p><p>所以当我们考虑时间复杂度时，只考虑与输入相关的部分，<strong>但在做题时，要考虑这一部分代码对整体时间使用的影响。</strong></p><p>然后看接下来的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算n的二进制位数</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    n/=<span class="number">2</span>;</span><br><span class="line">    sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br></pre></td></tr></table></figure><p>这个代码的复杂度为O( log(n) )，其中log的底数一般不写，这是在做题时可能遇到的比较低时间复杂度。</p><p>接下来看这个代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,n*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码的时间复杂度为O(1)，因为我们前面说过忽略常数的影响，在OJ系统中，如果说多组输入，那么我们在计算复杂度时只需要考虑单组的时间复杂度。</p><p>但是这个代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码的时间复杂度为O( t )，因为 t 是一个<strong>输入的变量</strong>，是可以改变的变量，所以我们在计算时间复杂度是需要计算上 t 对代码的影响。</p><p>虽然有些代码时间复杂度并不高，但在做题时，如果常数比较大，那么在写代码时仍要注意常数给代码带来的影响。</p><p>一般情况下，OJ评测机的每秒运算次数大概为 1e8~1e9 次。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度和时间复杂度是相对应的，空间复杂度为输入的变量对空间的要求，一维数组为O( n ) ，二维数组为O(n^2)或O(n*m)等多种形式，一般情况下，代码的数组大小最好在1e8之下，否则，内存就会超限，导致虽然代码正确，但是并不通过的情况发生。</p><h3 id="OJ常见评测结果"><a href="#OJ常见评测结果" class="headerlink" title="OJ常见评测结果"></a>OJ常见评测结果</h3><h4 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h4><p>答案正确！多么完美的返回结果！</p><p>#### </p><h4 id="Wrong-Answer"><a href="#Wrong-Answer" class="headerlink" title="Wrong Answer"></a>Wrong Answer</h4><p>答案错误！一定是评测机坏了！本地对了就是对了，OJ上错误说明OJ肯定有问题！</p><h4 id="Compile-Error"><a href="#Compile-Error" class="headerlink" title="Compile Error"></a>Compile Error</h4><p>编译错误。语言不小心选错了？哦，少复制了一点代码。 此处顺便@某过气OJ。</p><h4 id="Time-Limit-Exceed"><a href="#Time-Limit-Exceed" class="headerlink" title="Time Limit Exceed"></a>Time Limit Exceed</h4><p>时间超限。一定是评测机太慢了！</p><h4 id="Memory-Limit-Exceed"><a href="#Memory-Limit-Exceed" class="headerlink" title="Memory Limit Exceed"></a>Memory Limit Exceed</h4><p>内存超限。扣死了，内存都不会弄多点，这点内存都不舍得给我！</p><h4 id="Presentation-Error"><a href="#Presentation-Error" class="headerlink" title="Presentation Error"></a>Presentation Error</h4><p>格式错误。不就多个空格，多个换行吗，又看不见那些字符，真是小心眼！</p><h4 id="System-Error"><a href="#System-Error" class="headerlink" title="System Error"></a>System Error</h4><p>系统错误。辣鸡评测机，辣鸡OJ！</p><h4 id="Output-Limit-Exceed"><a href="#Output-Limit-Exceed" class="headerlink" title="Output Limit Exceed"></a>Output Limit Exceed</h4><p>输出超限。我不是怕你看不懂吗，多输出点给你解释一下我的答案嘛！</p><h4 id="Runtime-Error"><a href="#Runtime-Error" class="headerlink" title="Runtime Error"></a>Runtime Error</h4><p>运行错误。不就不小心除以零了嘛，就当我又创造了一门数学嘛！啊？数组下标越界了？我就是放这个变量出去数组外面玩了一会嘛。</p><p>在刷题的足够多之后，一些超限问题或者运行错误等就会减少，剩下的就只有（听取）WA（声一片）了。哈哈哈哈哈。</p><h3 id="常见刷题OJ"><a href="#常见刷题OJ" class="headerlink" title="常见刷题OJ"></a>常见刷题OJ</h3><p>杭州电子科技大学 ( 杭电 ) OJ : acm.hdu.edu.cn ( 第11页之后有大量中文题目 )</p><p>codeforces :  codeforces.com  (一起来肝cf啊！)</p><p>洛谷：luogu.org</p><p>vj : vjudge.net  (Virtual Judge，可以在这里创建比赛) </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h3&gt;&lt;p&gt;时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。&lt;br&gt;计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。&lt;strong&gt;时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数&lt;/strong&gt;。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。（来自百度百科）&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>尺取+二分</title>
    <link href="https://boctorio.github.io/2019/03/03/%E5%B0%BA%E5%8F%96/"/>
    <id>https://boctorio.github.io/2019/03/03/尺取/</id>
    <published>2019-03-03T00:35:24.000Z</published>
    <updated>2019-03-26T06:26:08.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="尺取-问题引入"><a href="#尺取-问题引入" class="headerlink" title="尺取-问题引入"></a>尺取-问题引入</h3><p>尺取，顾名思义，就是像尺子一样取一段区间，来快速高效地找到你想要的区间。</p><p>接下来看一个题目：</p><blockquote><p>给定一个长度为n的数列a1,a2,…,an及整数S,求不小于S的连续子序列的和的最小值</p></blockquote><p>通俗一点来讲，求 min ( 区间和 ) 且 区间和 &gt;= S。</p><a id="more"></a><p>暴力的情况下，总共有n*(n+1)/2个非零区间，如果我们对每一个区间都进行计算，那么时间复杂度为O（n^2）。对于n比较大的情况，暴力肯定会超时。（事实上，几乎所有的此类题目n都在 1e5~1e6左右）</p><p>因此我们就需要更高效的算法来进行求解。</p><p>接下来我们进行一下思考：</p><blockquote><p>假如区间 [ l , r ]（l &lt;= r） 的和小于S，那么对于区间[ l + i , r ] ( l + i &lt;= r )肯定也小于S，也就是说，假如一个区间不符合题意，那么它的子区间肯定也不符合题意。因此，我们就可以在这个基础上减少许多的多余的计算。</p></blockquote><p>看懂了上面的思考部分，我们就可以开始尺取的讲解了。</p><h3 id="尺取"><a href="#尺取" class="headerlink" title="尺取"></a>尺取</h3><ol><li><p>我们设置两个变量 l , r ，表示当前我们所计算的区间 [ l , r )，初始 l = r = 0（我的数列第一个存储下标为0）。</p></li><li><p>然后我们开始移动 r , 使 r 逐渐变大，直到区间 [ l , r )的和不小于S（这里就用到了上面思考部分的知识，如果区间 [ l , r )的和小于S，那么其子区间就完全没有了计算的必要）。</p></li><li><p>当 [ l , r )不小于S时，我们开始移动 l ，使区间慢慢变小，然后继续计算当前区间的值。直到区间和又一次小于S</p><blockquote><p>这里又用到了之前思考部分的知识，在运行第三步时，我们已知 [ l , r - 1 )不符合要求，那么所有的 [ l+i , r-j )（l <strong>&lt;=</strong> l + i <strong>&lt;=</strong> r - j <strong>&lt;</strong> r）均不符合要求，也就是说，如果我们这个时候缩了一下 r 的值，那么肯定是不符合要求的，但是， [ l + i , r )却是可能符合要求的，因为[ l + i , r )并不在我们的否定区间内，所以我们要继续对它进行计算判断。</p></blockquote></li><li><p>当 r = n 时，结束运算。</p></li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,s;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,sum=<span class="number">0</span>;<span class="comment">//sum为当前区间和</span></span><br><span class="line"><span class="keyword">int</span> res=INF;</span><br><span class="line"><span class="keyword">while</span>(r&lt;n)&#123;</span><br><span class="line">sum+=a[r];<span class="comment">//扩大区间</span></span><br><span class="line">r++;</span><br><span class="line">        <span class="comment">/*这个while是代码的核心，题目上给的约束条件就是用while进行判断，</span></span><br><span class="line"><span class="comment">        因此只要确定了while里面的内容，就可以轻易地求解尺取的相关问题</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="keyword">while</span>(sum&gt;=s)&#123;<span class="comment">//这一步原本应为先判断sum是否&gt;=s,但由于while的特性，可以直接省略</span></span><br><span class="line">res=min(res,sum);<span class="comment">//求出当前区间和是否更接近s</span></span><br><span class="line">sum-=a[l];<span class="comment">//缩小区间</span></span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以把时间复杂度缩小到O(n)了。</p><p>这是尺取最基本的一类解决问题，其他形式的尺取问题也基本依靠于这个主要思想。</p><h3 id="二分-问题引入"><a href="#二分-问题引入" class="headerlink" title="二分-问题引入"></a>二分-问题引入</h3><p>二分，顾名思义，就是用二分的方法找出答案。</p><p>接下来看一个题目：</p><blockquote><p>农夫 John 建造了一座很长的畜栏，它包括N (2 &lt;= N &lt;= 100,000)个隔间，这些小隔间依次编号为x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000). 但是，John的C (2 &lt;= C &lt;= N)头牛们并不喜欢这种布局，而且几头牛放在一个隔间里，他们就要发生争斗。为了不让牛互相伤害。John决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是什么呢？</p><p>Input</p><p>有多组测试数据，以EOF结束。 第一行：空格分隔的两个整数N和C 第二行——第N+1行：分别指出了xi的位置</p><p>Output</p><p>每组测试数据输出一个整数，满足题意的最大的最小值，注意换行。</p></blockquote><p>这个题就是经典的二分题目，暴力的做法就是直接 for 循环找到满足条件的最小的值。但是肯定是要超时的。</p><p>那么我们怎么就需要更高效的方法了。</p><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><blockquote><p>我们可以看出来，假设一个值 x（x是牛的距离） 不能使c头牛完全分配（即在距离为x的情况下隔间内放不下c头牛），那么比 x 大的值更不可以了；相反的，如果 x 能使c头牛完全分配（可行解，非最优解），那么比 x 大的值也可能使c头牛完全分配，从而最小距离也会变得更大。</p></blockquote><p>理解了上面的方法，就可以像尺取一样找到可能的答案了。</p><p><strong>这里说一句，对于二分题而言假设答案可能的取值区间为 [ 1 , x ] ,那么对于区间里面的每一个值是否是可行解一定是{可行，可行，…..，可行，不可行，……，不可行，不可行}这样的值规律（不排除全部可行或全部不可行的情况）。如果题目不是这样的规律，那么就无法使用二分的方法求解。</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;<span class="comment">//这个用到了贪心的思想 </span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">1</span>;<span class="comment">//初始一个隔间为a[0]，不进行计算 </span></span><br><span class="line"><span class="keyword">int</span> pos=x[<span class="number">0</span>];<span class="comment">//pos是用来记录当前可行的最近的隔间的位置 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x[i]-pos&gt;=s)&#123;<span class="comment">//这里判断当前隔间距离上一个隔间的距离是否不小于s </span></span><br><span class="line">pos=x[i];<span class="comment">//当前位置可以放置牛，因此就把pos的值更新为当前隔间的位置 </span></span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;=c) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(x,x+n);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=(x[n<span class="number">-1</span>]-x[<span class="number">0</span>])/(c<span class="number">-1</span>);<span class="comment">//由于需要放c头牛,最大距离为(x[n-1]-x[0),因此每头牛之间的距离最大就为(x[n-1]-x[0])/(c-1) 向下取整。</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid))&#123;<span class="comment">//当前为可行解</span></span><br><span class="line">l=mid+<span class="number">1</span>;<span class="comment">//由于为可行解，因此即使mid+1不为可行解，l的值也不会再改变，因此最后l的值为第一个不可行解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;尺取-问题引入&quot;&gt;&lt;a href=&quot;#尺取-问题引入&quot; class=&quot;headerlink&quot; title=&quot;尺取-问题引入&quot;&gt;&lt;/a&gt;尺取-问题引入&lt;/h3&gt;&lt;p&gt;尺取，顾名思义，就是像尺子一样取一段区间，来快速高效地找到你想要的区间。&lt;/p&gt;
&lt;p&gt;接下来看一个题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个长度为n的数列a1,a2,…,an及整数S,求不小于S的连续子序列的和的最小值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗一点来讲，求 min ( 区间和 ) 且 区间和 &amp;gt;= S。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="尺取" scheme="https://boctorio.github.io/tags/%E5%B0%BA%E5%8F%96/"/>
    
      <category term="算法" scheme="https://boctorio.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速幂+矩阵快速幂</title>
    <link href="https://boctorio.github.io/2019/03/02/%E5%BF%AB%E9%80%9F%E5%B9%82-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://boctorio.github.io/2019/03/02/快速幂-矩阵快速幂/</id>
    <published>2019-03-02T11:03:53.000Z</published>
    <updated>2019-03-26T06:21:51.309Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>顾名思义，快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)， 与朴素的O(N)相比效率有了极大的提高。</p><p>以a^b为例，假设b=11，则<br>$$<br>a^{11}=a^{2^{0}+2^{1}+2^{3}}<br>$$<br>因为11的二进制为1011，11=2^0 +2^1+2^3,所以可得上式。</p><a id="more"></a><p>所以我们只要判断幂的二进制的值，就可以计算在log()级别的时间求解出答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mulpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//求a^n</span></span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=res*a%mod;<span class="comment">//如果当前位为1，则进行计算</span></span><br><span class="line">a=a*a%mod;<span class="comment">//a^(2^i),i为循环次数</span></span><br><span class="line">n/=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中间的运算数可能超过int的范围，所以当我们使用时要注意数据范围而选取适当的数据类型(int,long long)。</p><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>矩阵快速幂思想和快速幂一样，只不过由单纯的数字运算变成了矩阵运算（这里需要了解矩阵的运算方法）。</p><p>使用矩阵快速幂的场合一般为知道递推式，求解相应的第n项的值。</p><p>下面以这个式子为样例，来进行矩阵快速幂的讲解。<br>$$<br>a_{n}=2*a_{n-1}+1<br>$$<br>我们用这个式子构造一个矩阵：<br>$$<br>\left[<br> \begin{matrix}<br> a_n \\<br> 1<br> \end{matrix}<br>\right]<br>=<br>\left[<br> \begin{matrix}<br>   2 &amp; 1 \\<br>   0 &amp; 1<br>  \end{matrix}<br>  \right]<br>  *<br>\left[<br> \begin{matrix}<br> a_{n-1}\\<br> 1<br> \end{matrix}<br>\right]<br>$$<br>如果没学过矩阵运算的相关知识，可以去百度进行学习。</p><p>然后我们继续递推：<br>$$<br>\left[<br> \begin{matrix}<br> a_{n-1} \\<br> 1<br> \end{matrix}<br>\right]<br>=<br>\left[<br> \begin{matrix}<br>   2 &amp; 1 \\<br>   0 &amp; 1<br>  \end{matrix}<br>  \right]<br>  *<br>\left[<br> \begin{matrix}<br> a_{n-2}\\<br> 1<br> \end{matrix}<br>\right]<br>$$</p><p>$$<br>…<br>$$</p><p>$$<br>\left[<br> \begin{matrix}<br> a_2 \\<br> 1<br> \end{matrix}<br>\right]<br>=<br>\left[<br> \begin{matrix}<br>   2 &amp; 1 \\<br>   0 &amp; 1<br>  \end{matrix}<br>  \right]<br>  *<br>\left[<br> \begin{matrix}<br> a_{1} \\<br> 1<br> \end{matrix}<br>\right]<br>$$</p><p>所以<br>$$<br>\left[<br> \begin{matrix}<br> a_n \\<br> 1<br> \end{matrix}<br>\right]<br>=<br>{\left[<br> \begin{matrix}<br>   2 &amp; 1 \\<br>   0 &amp; 1<br>  \end{matrix}<br>  \right]}^{n-1}<br>  *<br>\left[<br> \begin{matrix}<br> a_{1}\\<br> 1<br> \end{matrix}<br>\right]<br>$$<br>所以我们只需要求出中间的矩阵的结果就可以求出答案。</p><p>其大致步骤和快速幂一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">5</span>][<span class="number">5</span>];<span class="comment">//一般构造的矩阵大小不会超过5，大小根据情况而定 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod,n,a1;</span><br><span class="line"><span class="function">node <span class="title">ope</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//注意函数返回类型为 node,下面的 mulpow()函数返回类型同样是 node; </span></span><br><span class="line">node r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">r.x[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;<span class="comment">//这里是矩阵乘法的运算方法</span></span><br><span class="line">r.x[i][j]+=a.x[i][k]*b.x[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">mulpow</span><span class="params">(node a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//这里用到了一个知识，一个矩阵乘以单位矩阵结果仍为原矩阵，所以这一步相当于快速幂里面的 res=1，具体详见百度百科 单位矩阵 </span></span><br><span class="line">node res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line"><span class="keyword">if</span>(i==j) res.x[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> res.x[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=ope(res,a);</span><br><span class="line">a=ope(a,a);</span><br><span class="line">n/=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//构造需要求幂的初始矩阵 </span></span><br><span class="line">node a;</span><br><span class="line">a.x[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">a.x[<span class="number">0</span>][<span class="number">1</span>]=a.x[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">a.x[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">node s=mulpow(a,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一步矩阵乘法,参考前面最后展示的一个的矩阵</span></span><br><span class="line"><span class="keyword">int</span> res = s.x[<span class="number">0</span>][<span class="number">0</span>] * a1 + s.x[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矩阵乘法也几乎是模板，其难点在于矩阵的构造，给你一个递推式，你必须推出相应的矩阵才可以进行运算，因此需要多学习一些矩阵的知识。</p><p>接下来展示一个Fibonacci的递推矩阵：</p><p>Fibonacci的定义式：<br>$$<br>F(1)=f(2)=1\<br>F(n)=F(n-1)+F(n-2) (n&gt;2)<br>$$</p><p>递推矩阵：<br>$$<br>\left[<br>\begin{matrix}<br> F(n)\\<br> F(n-1)<br>\end{matrix}<br>\right]<br>=<br>\left[<br>\begin{matrix}<br> 1 &amp; 1\\<br> 1 &amp; 0<br>\end{matrix}<br>\right]<br>*<br>\left[<br>\begin{matrix}<br>F(n-1)\\<br>F(n-2)<br>\end{matrix}<br>\right]<br>$$<br>虽然这这个矩阵的第二个运算式子 F( n - 1 )=F( n - 1 ) 看起来是废话，但我们构造矩阵的目的是<strong>合理性</strong>，只要矩阵符合条件，就可以进行计算。</p><p>计算这个式子时需要注意矩阵快速幂的指数。</p><p>相关题目可以百度进行搜索。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;快速幂&quot;&gt;&lt;a href=&quot;#快速幂&quot; class=&quot;headerlink&quot; title=&quot;快速幂&quot;&gt;&lt;/a&gt;快速幂&lt;/h3&gt;&lt;p&gt;顾名思义，快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)， 与朴素的O(N)相比效率有了极大的提高。&lt;/p&gt;
&lt;p&gt;以a^b为例，假设b=11，则&lt;br&gt;$$&lt;br&gt;a^{11}=a^{2^{0}+2^{1}+2^{3}}&lt;br&gt;$$&lt;br&gt;因为11的二进制为1011，11=2^0 +2^1+2^3,所以可得上式。&lt;/p&gt;
    
    </summary>
    
      <category term="数论" scheme="https://boctorio.github.io/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="https://boctorio.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="快速幂" scheme="https://boctorio.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://boctorio.github.io/2019/03/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://boctorio.github.io/2019/03/02/并查集/</id>
    <published>2019-03-02T03:15:44.000Z</published>
    <updated>2019-03-26T06:26:26.082Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。</p><p>简而言之，并查集就是将一些具有一定关系的元素进行合并，以此来减少查询的时间。</p><p>并查集是基于树形结构的数据而使用的。</p><a id="more"></a><h4 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h4><p>接下来看一个题目：</p><blockquote><p>   某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ </p><p>Input</p><p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。  </p><p>Output</p><p>对每个测试用例，在1行里输出最少还需要建设的道路数目。  </p></blockquote><p>这个题就是经典的并查集。可以看出，当两个城镇互相联通（直接或间接）时，这两个城镇之间就不需要再进行任何道路建设。所以我们需要找出有多少个<strong>城镇集合</strong>是互不联通的。</p><p>如何说明和标记两个城镇是否互相联通？解决这个问题，就是我们的最终目的。</p><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>给出一个上面题目的一个样例：</p><blockquote><p>5 2</p><p>1 2</p><p>3 5</p></blockquote><p>它所对应的图形为：</p><p><img src="/2019/03/02/并查集/并查集-1.png" alt=""></p><p>如果仅仅从图片上看，我们很明显的可以看出来答案是2。</p><p>由于所有元素各不相同，对于每个集合，总会有一个最小值，而我们一般把这个最小值作为每个集合的根节点。</p><p>以上图为例，1,2,3,4,5对应的根节点分别为 1,1,3,3,4。总共有3种根节点，因此答案为3-1=2；</p><p>也可以说，总共有3个元素对应的根节点是其本身。</p><p>并查集的作用就是是每个集合里面的元素都找到其对应的根节点。</p><p>当我们合并两个元素时，这两个元素可能并不是自己所在集合的根节点，因此我们需要找到其对应的根节点，然后将两个根节点进行合并。</p><p>网上有一个很形象的比喻：</p><blockquote><p>话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</p><p>我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</p><p>但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,u,v;</span><br><span class="line"><span class="keyword">int</span> dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//刚开始每个节点的根节点都是其本身 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dep[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x!=dep[x])</span><br><span class="line">dep[x]=find(dep[x]);<span class="comment">//这个的作用就是递归找到最后的根节点</span></span><br><span class="line"><span class="keyword">return</span> dep[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//将两个元素进行合并，两个根节点不一样，就将两个根节点进行合并，大的合并到小的根节点上 </span></span><br><span class="line"><span class="keyword">int</span> dx=find(x);</span><br><span class="line"><span class="keyword">int</span> dy=find(y);</span><br><span class="line"><span class="keyword">if</span>(dx&lt;dy) dep[dy]=dx;<span class="comment">//将大的合并到小的上面</span></span><br><span class="line"><span class="keyword">else</span> dep[dx]=dy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="keyword">if</span>(find(u)!=find(v)) Union(u,v);<span class="comment">//如果两个元素根节点不一样，就进行合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//统计总共有多少个根节点，即集合</span></span><br><span class="line"><span class="keyword">if</span>(dep[i]==i) res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的例子，函数init()就是创造一个最初的江湖，find()就是用来找到自己的队长，Union()就是来将两位大侠所在的队伍结盟。对于一个队伍来说，队伍的操作只能由队长来进行，所以我们最后只需要将两个队长串联起来就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。&lt;/p&gt;
&lt;p&gt;简而言之，并查集就是将一些具有一定关系的元素进行合并，以此来减少查询的时间。&lt;/p&gt;
&lt;p&gt;并查集是基于树形结构的数据而使用的。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://boctorio.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="并查集" scheme="https://boctorio.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="https://boctorio.github.io/2019/03/02/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://boctorio.github.io/2019/03/02/背包问题/</id>
    <published>2019-03-02T00:59:21.000Z</published>
    <updated>2019-03-26T06:27:07.747Z</updated>
    
    <content type="html"><![CDATA[<p>背包问题是很经典的dp问题，在许多基础的比赛中都会用到。可以这样说，背包问题就是学习dp的第一步，但是其难度对于初学者来说也并不小。</p><p>这篇文章主要介绍一下基础的01背包和完全背包。</p><a id="more"></a><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>01背包是最简单的背包问题，其大致描述为：</p><blockquote><p>有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p></blockquote><h5 id="二维dp"><a href="#二维dp" class="headerlink" title="二维dp"></a>二维dp</h5><p>这里我们用一个二维数组dp[maxn][maxn] 来求解背包问题。</p><p>其中第一维表示前 i 个物品，第二维表示前 i 个物品在容量为 j 时的最大价值总和。</p><p>这里有一个状态方程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure><p>dp[ i ][ j ]上面说过，表示的是前 i 件物品在容量为 j 时的最大价值，那么得到dp[ i ][ j ]，其中就涉及到了关于第 i 件物品选和不选的问题。</p><p>当我们选择第 i 件物品时，总容量为 j ，我们需要腾出来 w[ i ] 的空间来装第 i 件物品，因此得出当选择第 i 件物品时的最大价值 dp[ i - 1 ][ j - w[ i ] ] + v[ i ]。</p><p>当我们不选择第 i 件物品时，那么之前的容量也必然为 j ，因为没有东西放进去，所以我们可以得到当不选择第 i 件物品时的最大价值 dp[ i - 1 ][ j ]。</p><p>理解了方程的意义，我们就可以写出来解决背包问题的代码了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=V;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&lt;v[i]) dp[i][j]=dp[i<span class="number">-1</span>][j];<span class="comment">//容量太小，装不下第 i 个物品 </span></span><br><span class="line"><span class="keyword">else</span> dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终求出来的dp[N][V]即为答案。</p><p>这是用二维数组来求解最大价值。我们如果在纸上模拟这个过程，会发现在两层 for 循环的情况下，每个位置的值只会变化一次，当第 i 行求解完之后，我们就再也不会改变第 i 行的值了。</p><p>那么这对空间的要求是巨大的，我们是否可以把二维数组压缩成一位数组？答案是可以！</p><h5 id="一维dp"><a href="#一维dp" class="headerlink" title="一维dp"></a>一维dp</h5><p>我们如果在纸上模拟这个过程，会发现在两层 for 循环的情况下，每个位置的值只会变化一次，当第 i 行求解完之后，我们就再也不会改变第 i 行的值了。</p><p>上面的代码过程用图像可以表示为：</p><p><img src="/2019/03/02/背包问题/01背包-1.png" alt=""></p><p>从上面代码和图片中可以看出，影响dp[ i ][ j ]的值为 dp[ i - 1][ j ] 和dp[ i - 1 ][ j - w[ i ] ]，两个数的一维二维坐标均小于等于 i , j ，所以我们第一步先改变一下循环的顺序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=<span class="number">1</span>;j--)&#123;<span class="comment">//这里的循环顺序改变了</span></span><br><span class="line"><span class="keyword">if</span>(j&lt;v[i]) dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">else</span> dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果表示成一维的话，那么过程就变成了：</p><p><img src="/2019/03/02/背包问题/01背包-2.png" alt=""></p><p>可以发现，此时代码中   <strong>if(j&lt;v[i]) dp[i][j]=dp[i-1][j]</strong> 已经失去了原本的作用。</p><p>然后将二维数组压缩成一位数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=w[i];j--)&#123;<span class="comment">//根据上面的代码，这里假如j&lt;w[i]时，dp[j]=dp[j],可以直接省略</span></span><br><span class="line">dp[j]=max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可能有人疑问，为什么循环顺序要变化？</p><p>当我们从前往后改变一维数组的值时，我们可能会改变了后面的数的正确的值，因为后面的数还会用到前面的是，从而导致最终结果偏离正确结果。</p><p>所以我们选用从后往前的方式进行遍历，前面已经说过，影响这个元素的值一维二维坐标均小于当前坐标，所以即使我们改变了后面的数值，也不会对前面的值有影响。</p><p>这样，我们就可以节省大量的空间（还在第二层循环时减少了时间）。</p><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><blockquote><p>有N种物品和一个容量为V的背包。第i种物品的重量是w[i]，价值是v[i]。每种物品都可以无限件使用。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p></blockquote><p>完全背包和01背包最大的区别就是物品件数的改变。完全背包每种物品可以无限次使用，而01背包只是用一次。</p><p>我们再来看一下01背包一维dp时循环顺序的问题。</p><p>上面已经说过，假如第二层for循环的顺序是j++，那么最终结果会偏离正确结果。但是是怎么偏离的呢？我们继续深入探讨一下。</p><blockquote><p>假如dp[ j ]&lt;dp[ j - w[ i ] ] + v[ i ] ，那么dp[ j ]=dp[ j - w[ i ] ] + v[ i ]，</p><p>然后对于 k ( j &lt; k &lt;= V)，如果dp[ j ]影响到了dp[ k ] ，那么影响的结果一定是dp[ k ] = dp[ k - w[ i ] ] + v[ i ],其中 k - w[ i ] = j ( 只考虑直接影响 )，</p><p>所以我们可以继续递推得出dp[ k ] = dp[ j - w[ i ] ] +v[ i ] +v[ i ]=dp[ j - w[ i ] ] + 2 * v[ i ]。</p></blockquote><p>这里我们就发现，v[ i ]被使用了两次，这在01背包中肯定是错误的，但是在完全背包中却没有任何问题，因为每件物品可以无限次使用，因此我们就可以得出完全背包的求解方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=V;j++)&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这和01背包的区别只在于第二层循环的顺序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;背包问题是很经典的dp问题，在许多基础的比赛中都会用到。可以这样说，背包问题就是学习dp的第一步，但是其难度对于初学者来说也并不小。&lt;/p&gt;
&lt;p&gt;这篇文章主要介绍一下基础的01背包和完全背包。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://boctorio.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="背包" scheme="https://boctorio.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>最长单调子序列</title>
    <link href="https://boctorio.github.io/2019/02/08/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://boctorio.github.io/2019/02/08/最长连续子序列/</id>
    <published>2019-02-08T12:49:46.000Z</published>
    <updated>2019-03-26T05:53:19.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长上升子序列（LIS）"><a href="#最长上升子序列（LIS）" class="headerlink" title="最长上升子序列（LIS）"></a>最长上升子序列（LIS）</h3><blockquote><p>问题描述：</p><p>​    给你一个序列，让你求出其中的最长的上升子序列。</p><p>​    比如数组{1,5,3,2,4},其最长递增子序列为{1,3,4}或{1,2,4}。</p></blockquote><a id="more"></a><h4 id="dp求解（小范围数据）"><a href="#dp求解（小范围数据）" class="headerlink" title="dp求解（小范围数据）"></a>dp求解（小范围数据）</h4><p>在长度 n 较小的情况下，我们可以用dp的方式来求解，复杂度为O(n^2) :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[j]) dp[j]=max(dp[j],dp[i]+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果是最长非递减的话，则if(a[i]&lt;=a[j])</span></span><br><span class="line">&#125;</span><br><span class="line">res=max(res,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个理解起来还算容易：当我们求出前m（m&lt;=n）个数的LIS长度时，那么我们就可以求出当前状态下m后面的数的最长长度。</p><p>因为m和m+1之间没有其他的数字，所以我们可以认为我们求出了前m+1个数的LIS长度。</p><p>然后依次递推，就可以求出n个数的LIS。</p><h4 id="dp求解（大范围数据）"><a href="#dp求解（大范围数据）" class="headerlink" title="dp求解（大范围数据）"></a>dp求解（大范围数据）</h4><p>当n比较大时,O(N^2)的时间复杂度明显没办法满足需要，所以我们需要更高效的方法。</p><p>当我们循环遍历时，我们可以把当前的最长的LIS存储下来。</p><p>对于样例{1,5,3,2,4}，我们储存的顺序依次为：</p><blockquote><p>{1}，</p><p>{1,5}</p><p>{1,3}</p><p>{1,2}</p><p>{1,2,,4}</p></blockquote><p>这个刚开始理解起来比较难理解。对于第二步{1,5}来说，当前的LIS长度为2，由LIS的特性可知，我们希望前面的元素尽量的小。</p><p>所以当遍历到第三个元素时，由于{1,5}，{1,3}长度均为2，但我们更希望值小一点，所以我们就用3来代替了5的值。</p><p>第四个元素也一样。</p><p>第五个元素{4}，由于当前我们保存的LIS{1,2}最大值小于4，因此我们就把4放进来，所以最终结果就为3。</p><p><strong>注意：储存的元素并不是LIS的值，这个储存的值只是用来寻找LIS的。</strong></p><p>再来看一个样例：{1,3,5,4,6,2}，存储的顺序依次为：</p><blockquote><p>{1}</p><p>{1,3}</p><p>{1,3,5}</p><p>{1,3,4}</p><p>{1,3,4,6}</p><p>{1,2,4,6}</p></blockquote><p>对于第6步，因为2&lt;6，所以我们一定能找到替换2的元素。而我们希望储存的序列尽可能的小，所以我们需要找到2能替换的最小的元素。因此我们的替换操作为3 -&gt; 2。</p><p>这一步可以理解为：<strong>找到储存的序列中比当前元素大（或者相等）的第一个元素，进行替换</strong>。</p><p>因为我们在储存时保证了储存的元素单调，因此我们在寻找替换位置时可以用高效的二分法，所以这种方法的复杂度为O( n*log(n) )。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>,mid;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[mid]&lt;x)&#123;<span class="comment">//小于的话肯定不是被替换的元素，因此可以+1 </span></span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//大于等于的情况下这个元素可能是被替换的元素，所以我们不能忽略这个元素 </span></span><br><span class="line">r=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">()</span></span>&#123;</span><br><span class="line">fill(dp,dp+n,INF);<span class="comment">//将dp里面的元素全部替换为INF </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> pos=find(a[i]);</span><br><span class="line">dp[pos]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=find(INF);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出LIS的元素"><a href="#输出LIS的元素" class="headerlink" title="输出LIS的元素"></a>输出LIS的元素</h4><p>在前面已经说过，储存的值并不是LIS的元素，那么我们如何来输出LIS呢？</p><p>前面已经说过，我们的操作都是找到储存的序列中第一个比当前元素大（或者相等）的位置，那么这个元素的前面一个元素一定是它左边的那个元素，因此我们需要用一个数组来储存每个元素的前驱。</p><p>因此我们在上面的代码上做一些小修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];<span class="comment">//用来记录每个元素的前驱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//用来输出LIS的元素（可能有多个答案，这里只取其中一种）</span></span><br><span class="line"><span class="keyword">if</span>(pre[x]!=<span class="number">0</span>) output(pre[x]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>,mid;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[mid]&lt;x)&#123;<span class="comment">//小于的话肯定不是被替换的元素，因此可以+1 </span></span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//大于等于的情况下这个元素可能是被替换的元素，所以我们不能忽略这个元素 </span></span><br><span class="line">r=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">()</span></span>&#123;</span><br><span class="line">fill(dp,dp+n,INF);<span class="comment">//将dp里面的元素全部替换为INF </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> pos=find(a[i]);</span><br><span class="line">dp[pos]=a[i];</span><br><span class="line">pre[ dp[pos] ]=dp[pos<span class="number">-1</span>];<span class="comment">//当前元素所对应的前一个元素的值。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=find(INF);</span><br><span class="line">output(dp[res<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以输出LIS的元素了。</p><h3 id="最长下降子序列（LDS"><a href="#最长下降子序列（LDS" class="headerlink" title="最长下降子序列（LDS)"></a>最长下降子序列（LDS)</h3><p>最长下降子序列求解方法和LIS相似，只需要把元素的位置翻一下即可求解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最长上升子序列（LIS）&quot;&gt;&lt;a href=&quot;#最长上升子序列（LIS）&quot; class=&quot;headerlink&quot; title=&quot;最长上升子序列（LIS）&quot;&gt;&lt;/a&gt;最长上升子序列（LIS）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;​    给你一个序列，让你求出其中的最长的上升子序列。&lt;/p&gt;
&lt;p&gt;​    比如数组{1,5,3,2,4},其最长递增子序列为{1,3,4}或{1,2,4}。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://boctorio.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://boctorio.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="子序列" scheme="https://boctorio.github.io/tags/%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>GCD与LCM及其部分性质</title>
    <link href="https://boctorio.github.io/2019/02/01/GCD%E4%B8%8ELCM%E5%8F%8A%E5%85%B6%E9%83%A8%E5%88%86%E6%80%A7%E8%B4%A8/"/>
    <id>https://boctorio.github.io/2019/02/01/GCD与LCM及其部分性质/</id>
    <published>2019-02-01T11:32:38.000Z</published>
    <updated>2019-03-26T06:28:35.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>GCD，即最大公约数，指两个或多个整数共有约数中最大的一个。</p><p>求最大公约数有多种方法，常见的有质因数分解法、短除法、辗转相除法、更相减损法。</p><p>在一般竞赛中，求GCD一般使用辗转相除法。其复杂度约为O(log(max(n,m)))，是一种很高效的算法。而且其代码量也非常少</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? gcd(b,a%b) : a; &#125;</span><br></pre></td></tr></table></figure><h4 id="拓展性质"><a href="#拓展性质" class="headerlink" title="拓展性质"></a>拓展性质</h4><p>如果GCD( n , a ) = 1 , n&gt;a 则GCD( n , n - a ) = 1。</p><p>可以用反证法证明</p><blockquote><p>假设GCD( n , n - a ) = i   ( i &gt; 1 )，设 n = k1 * i，n - a = k2 * i（ k1 &gt; k2 &gt; 0 ），</p><p>则 n -( n -a ) = a = (k1-k2) * i，与GCD( n , a ) = 1 矛盾，所以上述性质成立。</p></blockquote><h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4><p>设a , b为常数，对于一个表达式 a * x + b * y =GCD( a , b ) ，一定存在解（ x , y）使之成立。</p><p>我们就可以通过扩展原来的辗转相除法来求解。</p><p>求解的过程如下（最好自己手推一下）：</p><blockquote><p>初始表达式<br>$$<br>a * x + b * y =GCD( a , b )<br>$$<br>由之前的知识可得<br>$$<br>GCD( a , b ) =GCD( b , a \% b )<br>$$<br>因此<br>$$<br>a*x_1+b*y_1=GCD( a , b ) =GCD( b , a\%b ) =b*x_2+(a\%b)*y_2<br>$$</p><p>$$<br>a\%b=a-[a/b]*b<br>$$</p><p>其中[a/b]表示整除。带入化简可得：<br>$$<br>a*x_1+b*y_1=a*y_2+b*(x_2-[a/b]*y_2)<br>$$<br>由恒等关系可得<br>$$<br>x_1=y_2<br>$$</p><p>$$<br>y_1=x_2-[a/b]*y_2<br>$$</p><p>因此我们只要求出 x2 和 y2 的值就可以求解 x1 和 y1。而 x2 ,  y2 可通过同种方法求解。</p><p>特别的，当 b=0时，表达式为 a * x + b * y = GCD( a , b ) =GCD( a , 0 ) = 0 </p><p>此时,可求得 x = 1 。y 的值对表达式的值没有影响。</p><p>上面就是求解初始表达式的方法。</p></blockquote><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extGcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span><span class="comment">//这里取 x , y的地址 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;<span class="comment">//函数的返回值一直是 gcd(a,b) </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r=exGcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> t=x;</span><br><span class="line">x=y;   <span class="comment">//x1=y2</span></span><br><span class="line">y=t-a/b*y;<span class="comment">//y1=x2-[a/b]*y2</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCM"><a href="#LCM" class="headerlink" title="LCM"></a>LCM</h3><p>LCM，即最小公倍数，指两个或多个整数共有倍数中最小的一个。</p><p>LCM的求法可以基于GCD的基础上：<br>$$<br>LCM(a,b)=a*b/GCD(a,b)<br>$$<br>证明略。</p><p>一般题目求解时使用GCD更多一些，所以LCM相关知识就不多写了。(我也没找到太多关于LCM的相关文献)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h3&gt;&lt;p&gt;GCD，即最大公约数，指两个或多个整数共有约数中最大的一个。&lt;/p&gt;
&lt;p&gt;求最大公约数有多种方法，常见的有质因数分解法、短除法、辗转相除法、更相减损法。&lt;/p&gt;
&lt;p&gt;在一般竞赛中，求GCD一般使用辗转相除法。其复杂度约为O(log(max(n,m)))，是一种很高效的算法。而且其代码量也非常少&lt;/p&gt;
    
    </summary>
    
      <category term="数论" scheme="https://boctorio.github.io/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="GCD" scheme="https://boctorio.github.io/tags/GCD/"/>
    
      <category term="LCM" scheme="https://boctorio.github.io/tags/LCM/"/>
    
      <category term="数论" scheme="https://boctorio.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>欧拉函数及其部分性质</title>
    <link href="https://boctorio.github.io/2019/02/01/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E9%83%A8%E5%88%86%E6%80%A7%E8%B4%A8/"/>
    <id>https://boctorio.github.io/2019/02/01/欧拉函数及其部分性质/</id>
    <published>2019-02-01T09:16:15.000Z</published>
    <updated>2019-03-26T06:40:51.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><h4 id="欧拉函数-1"><a href="#欧拉函数-1" class="headerlink" title="欧拉函数"></a>欧拉函数</h4><p>在数论，<strong>对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）</strong>。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。 从欧拉函数引伸出来在环论方面的事实和拉格朗日定理构成了欧拉定理的证明。</p><p>欧拉函数的适用范围非常大，许多题目中都会用到欧拉函数的性质。</p><a id="more"></a><h5 id="欧拉函数表达式1："><a href="#欧拉函数表达式1：" class="headerlink" title="欧拉函数表达式1："></a>欧拉函数表达式1：</h5><p>欧拉函数的表达为：<br>$$<br>\varphi (x)=x\prod_{i=1}^{n}{(1-\frac{1}{p_i})}<br>$$</p><p>其中p1,p2,…,pn 表示x的所有质因子，x是不为0的整数。</p><h5 id="欧拉函数表达式2："><a href="#欧拉函数表达式2：" class="headerlink" title="欧拉函数表达式2："></a>欧拉函数表达式2：</h5><p>假设<br>$$<br>x= {p_1}^{k_1} * {p_2}^{k_2} * … * {p_n}^{k_n}<br>$$</p><p>p1,p2,…,pn同上，则其另一种表达为：<br>$$<br>\varphi(x)=\prod_{i=1}^{n}{(p_i-1)*p_i^{k_i-1}}<br>$$</p><p>特别的，<br>$$<br>\varphi(1)=1<br>$$</p><h4 id="欧拉函数证明"><a href="#欧拉函数证明" class="headerlink" title="欧拉函数证明"></a>欧拉函数证明</h4><h5 id="容斥定理来证明"><a href="#容斥定理来证明" class="headerlink" title="容斥定理来证明"></a>容斥定理来证明</h5><p>对于正整数 x 而言，假设其质因子为p1,p2,p3,…,pn，则小于等于 x 且与 x 不互质的数字的个数为：<br>$$<br>g(x)=\frac{x}{p_1}+\frac{x}{p_2}+…+\frac{x}{p_n}-\frac{x}{p_1*p_2}-\frac{x}{p_1*p_3}- …<br>$$</p><p>小于 x 且与 x 互质的数字的个数：<br>$$<br>f(x)=x-g(x)=n-\frac{x}{p_1}-\frac{x}{p_2}- … -\frac{x}{p_n}+\frac{x}{p_1*p_2}+\frac{x}{p_1*p_3}+ …<br>$$</p><p>化简即可得表达式1。（具体化简过程我也不会QAQ）</p><h4 id="欧拉函数计算"><a href="#欧拉函数计算" class="headerlink" title="欧拉函数计算"></a>欧拉函数计算</h4><h5 id="单值计算"><a href="#单值计算" class="headerlink" title="单值计算"></a>单值计算</h5><p>在编程时，习惯上，我们经常用<strong>表达式2</strong>计算欧拉函数的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eular</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n%i==0时，i为n的质因子，因为如果i不是质因子，</span></span><br><span class="line"><span class="comment">则一i定能分成更小的因子，对应的更小的因子一定在之前出现过了，与之矛盾，</span></span><br><span class="line"><span class="comment">所以i一定不能分割成更小的因子，即i为n的质因子。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n/=i,ret*=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i,ret*=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ret*=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="打表计算"><a href="#打表计算" class="headerlink" title="打表计算"></a>打表计算</h5><h4 id="欧拉函数性质"><a href="#欧拉函数性质" class="headerlink" title="欧拉函数性质"></a>欧拉函数性质</h4><h5 id="互质数之和"><a href="#互质数之和" class="headerlink" title="互质数之和"></a>互质数之和</h5><p>小于n的正整数中与n互质的数的数字之和为<br>$$<br>f(n)={n}*\frac{\varphi(n)}{2}<br>$$</p><p>证明如下：</p><blockquote><p>对于每个小于 n 的数正整数 a ，如果gcd( n , a )=1,则gcd( n , n-a )=1（ 此处为gcd相关性质，不再证明。）。</p><p>所以对于每个与 n 互质的正整数 a ，一定有一个与之对应的与 n 互质数的 n - a ;</p><p>由此可知，欧拉函数的值总为偶数（1除外），并且总有一对之和为 n，</p><p>至此，小于n的正整数中与n互质的数的数字之和就可以计算出来了。</p></blockquote><h5 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h5><p>欧拉函数是一个积性函数，如果 n , m 互质，则：<br>$$<br>\varphi(nm)=\varphi(n)*\varphi(m)<br>$$<br>可以推出，如果n为质数，则：<br>$$<br>\varphi(2n)=\varphi(n)<br>$$</p><h5 id="欧拉定理变式"><a href="#欧拉定理变式" class="headerlink" title="欧拉定理变式"></a>欧拉定理变式</h5><p>对于任何两个互质的正整数 a , n ，(n&gt;2)<br>$$<br>{a}^{\varphi(n)}\equiv 1 mod n<br>$$</p><h5 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h5><p>当 n = p 且 a 与素数 p 互质时，上式可变为</p><p>$$<br>{a}^{p-1}\equiv 1 mod p<br>$$</p><h5 id="n的因数（包括1和它自己）的欧拉函数之和等于n"><a href="#n的因数（包括1和它自己）的欧拉函数之和等于n" class="headerlink" title="n的因数（包括1和它自己）的欧拉函数之和等于n"></a>n的因数（包括1和它自己）的欧拉函数之和等于n</h5><p>写成数学表达式的形式即为<br>$$<br>n=\sum_{d|n}\varphi(d)<br>$$<br>其中 d|n 表示 n 能被 d 整除。</p><p>证明如下：</p><blockquote><p>对于每个 x ( 0 &lt;= x &lt;= n ) 都存在一个gcd( x , n )，可以证得，其值必然为n的因子。</p><p>假设gcd( x , n ) = d ,（ d | n ） ，则gcd（ x / d , n / d ）= 1 ，即 x / d 与 n / d 互质。</p><p>因此，我们可以求出 gcd( x , n ) 的值为 d 时对应的的数字个数，个数就是 n / d 所对应的欧拉函数值。</p><p>由第一行可知，gcd( x , n )的值必然为n的因子，并且只有唯一对应值，因此就可推导出上述公式。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;欧拉函数&quot;&gt;&lt;a href=&quot;#欧拉函数&quot; class=&quot;headerlink&quot; title=&quot;欧拉函数&quot;&gt;&lt;/a&gt;欧拉函数&lt;/h3&gt;&lt;h4 id=&quot;欧拉函数-1&quot;&gt;&lt;a href=&quot;#欧拉函数-1&quot; class=&quot;headerlink&quot; title=&quot;欧拉函数&quot;&gt;&lt;/a&gt;欧拉函数&lt;/h4&gt;&lt;p&gt;在数论，&lt;strong&gt;对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）&lt;/strong&gt;。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。 从欧拉函数引伸出来在环论方面的事实和拉格朗日定理构成了欧拉定理的证明。&lt;/p&gt;
&lt;p&gt;欧拉函数的适用范围非常大，许多题目中都会用到欧拉函数的性质。&lt;/p&gt;
    
    </summary>
    
      <category term="数论" scheme="https://boctorio.github.io/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="https://boctorio.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="欧拉函数" scheme="https://boctorio.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>HDU-2036（多边形面积）</title>
    <link href="https://boctorio.github.io/2019/01/17/HDU-2036/"/>
    <id>https://boctorio.github.io/2019/01/17/HDU-2036/</id>
    <published>2019-01-17T06:52:20.000Z</published>
    <updated>2019-03-26T06:27:35.670Z</updated>
    
    <content type="html"><![CDATA[<p>题目大意：</p><p>给你一个多边形，求它的面积。</p><p>多边形面积可以用向量知识来求解。</p><p>对于一个<strong>凸多边形</strong>，如下：</p><a id="more"></a><p><img src="/2019/01/17/HDU-2036/凸.png" alt=""></p><p>其面积可以表示为 S = S△OAB+S△OBC+S△OCD+S△ODE</p><p>对于△OAB 其面积用向量表示为 0.5 * |OA| * |OB| * sin∠AOB=0.5 * | <strong>OA</strong> x <strong>OB</strong>|</p><p>其中<strong>OA</strong> x <strong>OB</strong>表示叉乘（非点乘，具体详见百度百科“向量积”）</p><p>但因为向量叉乘有正有负，所以我们取的是绝对值，保证题目答案的正负。（正负取决于两条边的位置状态）</p><p>这时候就可以简单的计算出多边形的面积。</p><p>对于一个 <strong>凹多边形</strong>，如下：</p><p><img src="/2019/01/17/HDU-2036/凹.png" alt=""></p><p>其面积依然就可以用向量的方法求解</p><p>假设点O为坐标原点，则 S = S△OAB+S△OBC+S△OCD+S△ODE+S△OEA</p><p>S△OAB = 0.5 * <strong>OA</strong> x <strong>OB</strong> =0.5 * ( A.x * B.y - A.y * B.x )</p><p>其中S均表示在叉乘意义下的值，由于其具有正负之分，所以可以用来计算凹多边形的面积（具体证明过程略）。</p><p>这时候就可以计算出多边形的面积。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,i;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">double</span> b[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>]=a[n];</span><br><span class="line">b[<span class="number">0</span>]=b[n];</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">res=res+(a[i]*b[i+<span class="number">1</span>]-b[i]*a[i+<span class="number">1</span>])/<span class="number">2</span>;<span class="comment">//由于是逆时针方向，所以求出来结果为正。 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目大意：&lt;/p&gt;
&lt;p&gt;给你一个多边形，求它的面积。&lt;/p&gt;
&lt;p&gt;多边形面积可以用向量知识来求解。&lt;/p&gt;
&lt;p&gt;对于一个&lt;strong&gt;凸多边形&lt;/strong&gt;，如下：&lt;/p&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="几何" scheme="https://boctorio.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>广西大学第一届程序设计大赛-数论只会GCD</title>
    <link href="https://boctorio.github.io/2019/01/16/%E5%B9%BF%E8%A5%BF%E5%A4%A7%E5%AD%A6%E7%AC%AC%E4%B8%80%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-D%E9%A2%98/"/>
    <id>https://boctorio.github.io/2019/01/16/广西大学第一届程序设计大赛-D题/</id>
    <published>2019-01-16T09:01:38.000Z</published>
    <updated>2019-03-26T06:23:48.721Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong></p><blockquote><p>  小西买了一堆肥宅快乐水和肥宅快乐茶，准备和室友比谁更肥宅。 </p><p>  快乐水有A瓶，快乐茶B瓶。 </p><p>  小西和室友的规则是这样的： </p><ol><li><p>小西先手，轮流到每个人的回合，每个回合只能喝剩余数量较多的饮料 </p></li><li><p>满足规则1的同时，每次只能喝另一种饮料剩余数量的正整数倍 </p></li><li><p>满足1、2的同时，不能超额喝饮料，也就是说剩下2瓶的时候不能喝大于2瓶的数量。 </p></li><li><p>每个人在自己的回合如果能喝完剩下的其中一种饮料，那么就获得胜利。 </p><p>例如A=10，B=2。 </p><p>小西只能喝快乐水，且只能喝2/4/6/8/10瓶快乐水。小西可以喝10瓶快乐水直接获得胜利。 </p><p>小西和室友都是肥宅，所以他们都会才采取为了胜利最优的行动。 </p><p>现在请你判断小西是否能赢得胜利。 </p></li></ol></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>第一行输入一个整数T，表示有T组数据</p><p>接下来T行，每行为一组数据，每行有两个正整数表示A和B的初始数量</p><p>1 ≤ T ≤ 500 , 1 ≤ A,B ≤ 10^12 </p></blockquote><p>输出描述:</p><blockquote><p>对于每组数据，若小西可以获得胜利则输出一行“wula”，否则输出一行“mmp”，不需要输出引号</p></blockquote><p>你真的会GCD吗</p><p>这道题其实就和求GCD的过程有关。</p><p>求GCD的过程就是GCD( a , b ) = GCD( b , a % b )，其过程就是把 a 减去 b 的正整数倍，然后依次递归求解。</p><p>那么对于这个题，最后的状态一定是一个数量为 0 ，一个数量为正整数。而逆推就可以得到题目给出的 A , B 值。</p><ol><li>假设 A &lt; 2 * B,那么接下来的操作之后一定是（ A - B , B），接下来也一直持续这个过程，而且这个过程是可以一直递推求出来唯一解的。</li></ol><ol start="2"><li>假如 A &gt; 2 * B , 那么因为两人足够聪明，接下来的状态可以变为（ A , A%B）或者（ A , A % B + A ）。</li></ol><p>可以看到，第二个状态只能有一种操作：（ A , A % B + A ）- &gt;（ A , A%B）,因此这个时候可操作的人就能够随意挑选这两种状态之一来掌握自己的胜负。</p><ol start="3"><li>假设A % B=0 那就不多说了，直接就赢了。</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll t,a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b);</span><br><span class="line">ll flag=<span class="number">1</span>;<span class="comment">//用flag来记录当前的赢家，因为此时我们并不知道谁有主动权 </span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;<span class="comment">//遇到可以判断赢家的条件时，循环就结束了 </span></span><br><span class="line"><span class="keyword">if</span>(a&gt;b) swap(a,b);</span><br><span class="line"><span class="keyword">if</span>(b%a==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a*<span class="number">2</span>&lt;b) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">flag*=<span class="number">-1</span>;</span><br><span class="line">b=b-a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"wula\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"mmp\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  小西买了一堆肥宅快乐水和肥宅快乐茶，准备和室友比谁更肥宅。 &lt;/p&gt;
&lt;p&gt;  快乐水有A瓶，快乐茶B瓶。 &lt;/p&gt;
&lt;p&gt;  小西和室友的规则是这样的： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;小西先手，轮流到每个人的回合，每个回合只能喝剩余数量较多的饮料 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;满足规则1的同时，每次只能喝另一种饮料剩余数量的正整数倍 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;满足1、2的同时，不能超额喝饮料，也就是说剩下2瓶的时候不能喝大于2瓶的数量。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个人在自己的回合如果能喝完剩下的其中一种饮料，那么就获得胜利。 &lt;/p&gt;
&lt;p&gt;例如A=10，B=2。 &lt;/p&gt;
&lt;p&gt;小西只能喝快乐水，且只能喝2/4/6/8/10瓶快乐水。小西可以喝10瓶快乐水直接获得胜利。 &lt;/p&gt;
&lt;p&gt;小西和室友都是肥宅，所以他们都会才采取为了胜利最优的行动。 &lt;/p&gt;
&lt;p&gt;现在请你判断小西是否能赢得胜利。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OJ系统题目" scheme="https://boctorio.github.io/categories/OJ%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="博弈" scheme="https://boctorio.github.io/tags/%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
</feed>
